(globalThis["webpackChunkpeertube_client"] = globalThis["webpackChunkpeertube_client"] || []).push([["vendors-node_modules_https-browserify_index_js-node_modules_stream-browserify_index_js-node_m-974c59"],{

/***/ "./node_modules/addr-to-ip-port/index.js":
/*!***********************************************!*\
  !*** ./node_modules/addr-to-ip-port/index.js ***!
  \***********************************************/
/***/ ((module) => {

const ADDR_RE = /^\[?([^\]]+)]?:(\d+)$/; // ipv4/ipv6/hostname + port

let cache = new Map(); // reset cache when it gets to 100,000 elements (~ 600KB of ipv4 addresses)
// so it will not grow to consume all memory in long-running processes

module.exports = function addrToIPPort(addr) {
  if (cache.size === 100000) cache.clear();

  if (!cache.has(addr)) {
    const m = ADDR_RE.exec(addr);
    if (!m) throw new Error("invalid addr: ".concat(addr));
    cache.set(addr, [m[1], Number(m[2])]);
  }

  return cache.get(addr);
};

/***/ }),

/***/ "./node_modules/bencode/lib/decode.js":
/*!********************************************!*\
  !*** ./node_modules/bencode/lib/decode.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
const INTEGER_START = 0x69; // 'i'

const STRING_DELIM = 0x3A; // ':'

const DICTIONARY_START = 0x64; // 'd'

const LIST_START = 0x6C; // 'l'

const END_OF_TYPE = 0x65; // 'e'

/**
 * replaces parseInt(buffer.toString('ascii', start, end)).
 * For strings with less then ~30 charachters, this is actually a lot faster.
 *
 * @param {Buffer} data
 * @param {Number} start
 * @param {Number} end
 * @return {Number} calculated number
 */

function getIntFromBuffer(buffer, start, end) {
  let sum = 0;
  let sign = 1;

  for (let i = start; i < end; i++) {
    const num = buffer[i];

    if (num < 58 && num >= 48) {
      sum = sum * 10 + (num - 48);
      continue;
    }

    if (i === start && num === 43) {
      // +
      continue;
    }

    if (i === start && num === 45) {
      // -
      sign = -1;
      continue;
    }

    if (num === 46) {
      // .
      // its a float. break here.
      break;
    }

    throw new Error('not a number: buffer[' + i + '] = ' + num);
  }

  return sum * sign;
}
/**
 * Decodes bencoded data.
 *
 * @param  {Buffer} data
 * @param  {Number} start (optional)
 * @param  {Number} end (optional)
 * @param  {String} encoding (optional)
 * @return {Object|Array|Buffer|String|Number}
 */


function decode(data, start, end, encoding) {
  if (data == null || data.length === 0) {
    return null;
  }

  if (typeof start !== 'number' && encoding == null) {
    encoding = start;
    start = undefined;
  }

  if (typeof end !== 'number' && encoding == null) {
    encoding = end;
    end = undefined;
  }

  decode.position = 0;
  decode.encoding = encoding || null;
  decode.data = !Buffer.isBuffer(data) ? Buffer.from(data) : data.slice(start, end);
  decode.bytes = decode.data.length;
  return decode.next();
}

decode.bytes = 0;
decode.position = 0;
decode.data = null;
decode.encoding = null;

decode.next = function () {
  switch (decode.data[decode.position]) {
    case DICTIONARY_START:
      return decode.dictionary();

    case LIST_START:
      return decode.list();

    case INTEGER_START:
      return decode.integer();

    default:
      return decode.buffer();
  }
};

decode.find = function (chr) {
  let i = decode.position;
  const c = decode.data.length;
  const d = decode.data;

  while (i < c) {
    if (d[i] === chr) return i;
    i++;
  }

  throw new Error('Invalid data: Missing delimiter "' + String.fromCharCode(chr) + '" [0x' + chr.toString(16) + ']');
};

decode.dictionary = function () {
  decode.position++;
  const dict = {};

  while (decode.data[decode.position] !== END_OF_TYPE) {
    dict[decode.buffer()] = decode.next();
  }

  decode.position++;
  return dict;
};

decode.list = function () {
  decode.position++;
  const lst = [];

  while (decode.data[decode.position] !== END_OF_TYPE) {
    lst.push(decode.next());
  }

  decode.position++;
  return lst;
};

decode.integer = function () {
  const end = decode.find(END_OF_TYPE);
  const number = getIntFromBuffer(decode.data, decode.position + 1, end);
  decode.position += end + 1 - decode.position;
  return number;
};

decode.buffer = function () {
  let sep = decode.find(STRING_DELIM);
  const length = getIntFromBuffer(decode.data, decode.position, sep);
  const end = ++sep + length;
  decode.position = end;
  return decode.encoding ? decode.data.toString(decode.encoding, sep, end) : decode.data.slice(sep, end);
};

module.exports = decode;

/***/ }),

/***/ "./node_modules/bencode/lib/encode.js":
/*!********************************************!*\
  !*** ./node_modules/bencode/lib/encode.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
const {
  getType
} = __webpack_require__(/*! ./util.js */ "./node_modules/bencode/lib/util.js");
/**
 * Encodes data in bencode.
 *
 * @param  {Buffer|Array|String|Object|Number|Boolean} data
 * @return {Buffer}
 */


function encode(data, buffer, offset) {
  const buffers = [];
  let result = null;

  encode._encode(buffers, data);

  result = Buffer.concat(buffers);
  encode.bytes = result.length;

  if (Buffer.isBuffer(buffer)) {
    result.copy(buffer, offset);
    return buffer;
  }

  return result;
}

encode.bytes = -1;
encode._floatConversionDetected = false;

encode._encode = function (buffers, data) {
  if (data == null) {
    return;
  }

  switch (getType(data)) {
    case 'buffer':
      encode.buffer(buffers, data);
      break;

    case 'object':
      encode.dict(buffers, data);
      break;

    case 'map':
      encode.dictMap(buffers, data);
      break;

    case 'array':
      encode.list(buffers, data);
      break;

    case 'set':
      encode.listSet(buffers, data);
      break;

    case 'string':
      encode.string(buffers, data);
      break;

    case 'number':
      encode.number(buffers, data);
      break;

    case 'boolean':
      encode.number(buffers, data);
      break;

    case 'arraybufferview':
      encode.buffer(buffers, Buffer.from(data.buffer, data.byteOffset, data.byteLength));
      break;

    case 'arraybuffer':
      encode.buffer(buffers, Buffer.from(data));
      break;
  }
};

const buffE = Buffer.from('e');
const buffD = Buffer.from('d');
const buffL = Buffer.from('l');

encode.buffer = function (buffers, data) {
  buffers.push(Buffer.from(data.length + ':'), data);
};

encode.string = function (buffers, data) {
  buffers.push(Buffer.from(Buffer.byteLength(data) + ':' + data));
};

encode.number = function (buffers, data) {
  const maxLo = 0x80000000;
  const hi = data / maxLo << 0;
  const lo = data % maxLo << 0;
  const val = hi * maxLo + lo;
  buffers.push(Buffer.from('i' + val + 'e'));

  if (val !== data && !encode._floatConversionDetected) {
    encode._floatConversionDetected = true;
    console.warn('WARNING: Possible data corruption detected with value "' + data + '":', 'Bencoding only defines support for integers, value was converted to "' + val + '"');
    console.trace();
  }
};

encode.dict = function (buffers, data) {
  buffers.push(buffD);
  let j = 0;
  let k; // fix for issue #13 - sorted dicts

  const keys = Object.keys(data).sort();
  const kl = keys.length;

  for (; j < kl; j++) {
    k = keys[j];
    if (data[k] == null) continue;
    encode.string(buffers, k);

    encode._encode(buffers, data[k]);
  }

  buffers.push(buffE);
};

encode.dictMap = function (buffers, data) {
  buffers.push(buffD);
  const keys = Array.from(data.keys()).sort();

  for (const key of keys) {
    if (data.get(key) == null) continue;
    Buffer.isBuffer(key) ? encode._encode(buffers, key) : encode.string(buffers, String(key));

    encode._encode(buffers, data.get(key));
  }

  buffers.push(buffE);
};

encode.list = function (buffers, data) {
  let i = 0;
  const c = data.length;
  buffers.push(buffL);

  for (; i < c; i++) {
    if (data[i] == null) continue;

    encode._encode(buffers, data[i]);
  }

  buffers.push(buffE);
};

encode.listSet = function (buffers, data) {
  buffers.push(buffL);

  for (const item of data) {
    if (item == null) continue;

    encode._encode(buffers, item);
  }

  buffers.push(buffE);
};

module.exports = encode;

/***/ }),

/***/ "./node_modules/bencode/lib/encoding-length.js":
/*!*****************************************************!*\
  !*** ./node_modules/bencode/lib/encoding-length.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
const {
  digitCount,
  getType
} = __webpack_require__(/*! ./util.js */ "./node_modules/bencode/lib/util.js");

function listLength(list) {
  let length = 1 + 1; // type marker + end-of-type marker

  for (const value of list) {
    length += encodingLength(value);
  }

  return length;
}

function mapLength(map) {
  let length = 1 + 1; // type marker + end-of-type marker

  for (const [key, value] of map) {
    const keyLength = Buffer.byteLength(key);
    length += digitCount(keyLength) + 1 + keyLength;
    length += encodingLength(value);
  }

  return length;
}

function objectLength(value) {
  let length = 1 + 1; // type marker + end-of-type marker

  const keys = Object.keys(value);

  for (let i = 0; i < keys.length; i++) {
    const keyLength = Buffer.byteLength(keys[i]);
    length += digitCount(keyLength) + 1 + keyLength;
    length += encodingLength(value[keys[i]]);
  }

  return length;
}

function stringLength(value) {
  const length = Buffer.byteLength(value);
  return digitCount(length) + 1 + length;
}

function arrayBufferLength(value) {
  const length = value.byteLength - value.byteOffset;
  return digitCount(length) + 1 + length;
}

function encodingLength(value) {
  const length = 0;
  if (value == null) return length;
  const type = getType(value);

  switch (type) {
    case 'buffer':
      return digitCount(value.length) + 1 + value.length;

    case 'arraybufferview':
      return arrayBufferLength(value);

    case 'string':
      return stringLength(value);

    case 'array':
    case 'set':
      return listLength(value);

    case 'number':
      return 1 + digitCount(Math.floor(value)) + 1;

    case 'bigint':
      return 1 + value.toString().length + 1;

    case 'object':
      return objectLength(value);

    case 'map':
      return mapLength(value);

    default:
      throw new TypeError("Unsupported value of type \"".concat(type, "\""));
  }
}

module.exports = encodingLength;

/***/ }),

/***/ "./node_modules/bencode/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/bencode/lib/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const bencode = module.exports;
bencode.encode = __webpack_require__(/*! ./encode.js */ "./node_modules/bencode/lib/encode.js");
bencode.decode = __webpack_require__(/*! ./decode.js */ "./node_modules/bencode/lib/decode.js");
/**
 * Determines the amount of bytes
 * needed to encode the given value
 * @param  {Object|Array|Buffer|String|Number|Boolean} value
 * @return {Number} byteCount
 */

bencode.byteLength = bencode.encodingLength = __webpack_require__(/*! ./encoding-length.js */ "./node_modules/bencode/lib/encoding-length.js");

/***/ }),

/***/ "./node_modules/bencode/lib/util.js":
/*!******************************************!*\
  !*** ./node_modules/bencode/lib/util.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
const util = module.exports;

util.digitCount = function digitCount(value) {
  // Add a digit for negative numbers, as the sign will be prefixed
  const sign = value < 0 ? 1 : 0; // Guard against negative numbers & zero going into log10(),
  // as that would return -Infinity

  value = Math.abs(Number(value || 1));
  return Math.floor(Math.log10(value)) + 1 + sign;
};

util.getType = function getType(value) {
  if (Buffer.isBuffer(value)) return 'buffer';
  if (ArrayBuffer.isView(value)) return 'arraybufferview';
  if (Array.isArray(value)) return 'array';
  if (value instanceof Number) return 'number';
  if (value instanceof Boolean) return 'boolean';
  if (value instanceof Set) return 'set';
  if (value instanceof Map) return 'map';
  if (value instanceof String) return 'string';
  if (value instanceof ArrayBuffer) return 'arraybuffer';
  return typeof value;
};

/***/ }),

/***/ "./node_modules/bep53-range/index.js":
/*!*******************************************!*\
  !*** ./node_modules/bep53-range/index.js ***!
  \*******************************************/
/***/ ((module) => {

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

module.exports = parseRange;
module.exports.parse = parseRange;
module.exports.compose = composeRange;

function composeRange(range) {
  return range.reduce((acc, cur, idx, arr) => {
    if (idx === 0 || cur !== arr[idx - 1] + 1) acc.push([]);
    acc[acc.length - 1].push(cur);
    return acc;
  }, []).map(cur => {
    return cur.length > 1 ? "".concat(cur[0], "-").concat(cur[cur.length - 1]) : "".concat(cur[0]);
  });
}

function parseRange(range) {
  const generateRange = function (start) {
    let end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : start;
    return Array.from({
      length: end - start + 1
    }, (cur, idx) => idx + start);
  };

  return range.reduce((acc, cur, idx, arr) => {
    const r = cur.split('-').map(cur => parseInt(cur));
    return acc.concat(generateRange.apply(void 0, _toConsumableArray(r)));
  }, []);
}

/***/ }),

/***/ "./node_modules/binary-search/index.js":
/*!*********************************************!*\
  !*** ./node_modules/binary-search/index.js ***!
  \*********************************************/
/***/ ((module) => {

module.exports = function (haystack, needle, comparator, low, high) {
  var mid, cmp;
  if (low === undefined) low = 0;else {
    low = low | 0;
    if (low < 0 || low >= haystack.length) throw new RangeError("invalid lower bound");
  }
  if (high === undefined) high = haystack.length - 1;else {
    high = high | 0;
    if (high < low || high >= haystack.length) throw new RangeError("invalid upper bound");
  }

  while (low <= high) {
    // The naive `low + high >>> 1` could fail for array lengths > 2**31
    // because `>>>` converts its operands to int32. `low + (high - low >>> 1)`
    // works for array lengths <= 2**32-1 which is also Javascript's max array
    // length.
    mid = low + (high - low >>> 1);
    cmp = +comparator(haystack[mid], needle, mid, haystack); // Too low.

    if (cmp < 0.0) low = mid + 1; // Too high.
    else if (cmp > 0.0) high = mid - 1; // Key found.
    else return mid;
  } // Key not found.


  return ~low;
};

/***/ }),

/***/ "./node_modules/bitfield/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/bitfield/lib/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

function getByteSize(num) {
  var out = num >> 3;
  if (num % 8 !== 0) out++;
  return out;
}

var BitField =
/** @class */
function () {
  /**
   *
   *
   * @param data Either a number representing the maximum number of supported bytes, or a Uint8Array.
   * @param opts Options for the bitfield.
   */
  function BitField(data, opts) {
    if (data === void 0) {
      data = 0;
    }

    var grow = opts === null || opts === void 0 ? void 0 : opts.grow;
    this.grow = grow && isFinite(grow) && getByteSize(grow) || grow || 0;
    this.buffer = typeof data === "number" ? new Uint8Array(getByteSize(data)) : data;
  }
  /**
   * Get a particular bit.
   *
   * @param i Bit index to retrieve.
   * @returns A boolean indicating whether the `i`th bit is set.
   */


  BitField.prototype.get = function (i) {
    var j = i >> 3;
    return j < this.buffer.length && !!(this.buffer[j] & 128 >> i % 8);
  };
  /**
   * Set a particular bit.
   *
   * Will grow the underlying array if the bit is out of bounds and the `grow` option is set.
   *
   * @param i Bit index to set.
   * @param value Value to set the bit to. Defaults to `true`.
   */


  BitField.prototype.set = function (i, value) {
    if (value === void 0) {
      value = true;
    }

    var j = i >> 3;

    if (value) {
      if (this.buffer.length < j + 1) {
        var length = Math.max(j + 1, Math.min(2 * this.buffer.length, this.grow));

        if (length <= this.grow) {
          var newBuffer = new Uint8Array(length);
          newBuffer.set(this.buffer);
          this.buffer = newBuffer;
        }
      } // Set


      this.buffer[j] |= 128 >> i % 8;
    } else if (j < this.buffer.length) {
      // Clear
      this.buffer[j] &= ~(128 >> i % 8);
    }
  };
  /**
   * Loop through the bits in the bitfield.
   *
   * @param fn Function to be called with the bit value and index.
   * @param start Index of the first bit to look at.
   * @param end Index of the first bit that should no longer be considered.
   */


  BitField.prototype.forEach = function (fn, start, end) {
    if (start === void 0) {
      start = 0;
    }

    if (end === void 0) {
      end = this.buffer.length * 8;
    }

    for (var i = start, j = i >> 3, y = 128 >> i % 8, byte = this.buffer[j]; i < end; i++) {
      fn(!!(byte & y), i);
      y = y === 1 ? (byte = this.buffer[++j], 128) : y >> 1;
    }
  };

  return BitField;
}();

exports["default"] = BitField;

/***/ }),

/***/ "./node_modules/bittorrent-protocol/index.js":
/*!***************************************************!*\
  !*** ./node_modules/bittorrent-protocol/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*! bittorrent-protocol. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
const arrayRemove = __webpack_require__(/*! unordered-array-remove */ "./node_modules/unordered-array-remove/index.js");

const bencode = __webpack_require__(/*! bencode */ "./node_modules/bencode/lib/index.js");

const BitField = (__webpack_require__(/*! bitfield */ "./node_modules/bitfield/lib/index.js")["default"]);

const crypto = __webpack_require__(/*! crypto */ "./src/shims/noop.ts");

const debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")('bittorrent-protocol');

const randombytes = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js");

const sha1 = __webpack_require__(/*! simple-sha1 */ "./node_modules/simple-sha1/browser.js");

const speedometer = __webpack_require__(/*! speedometer */ "./node_modules/speedometer/index.js");

const stream = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js");

const RC4 = __webpack_require__(/*! rc4 */ "./node_modules/rc4/rc4.js");

const BITFIELD_GROW = 400000;
const KEEP_ALIVE_TIMEOUT = 55000;
const ALLOWED_FAST_SET_MAX_LENGTH = 100;
const MESSAGE_PROTOCOL = Buffer.from('\u0013BitTorrent protocol');
const MESSAGE_KEEP_ALIVE = Buffer.from([0x00, 0x00, 0x00, 0x00]);
const MESSAGE_CHOKE = Buffer.from([0x00, 0x00, 0x00, 0x01, 0x00]);
const MESSAGE_UNCHOKE = Buffer.from([0x00, 0x00, 0x00, 0x01, 0x01]);
const MESSAGE_INTERESTED = Buffer.from([0x00, 0x00, 0x00, 0x01, 0x02]);
const MESSAGE_UNINTERESTED = Buffer.from([0x00, 0x00, 0x00, 0x01, 0x03]);
const MESSAGE_RESERVED = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
const MESSAGE_PORT = [0x00, 0x00, 0x00, 0x03, 0x09, 0x00, 0x00]; // BEP6 Fast Extension

const MESSAGE_HAVE_ALL = Buffer.from([0x00, 0x00, 0x00, 0x01, 0x0E]);
const MESSAGE_HAVE_NONE = Buffer.from([0x00, 0x00, 0x00, 0x01, 0x0F]);
const DH_PRIME = 'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a36210000000000090563';
const DH_GENERATOR = 2;
const VC = Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
const CRYPTO_PROVIDE = Buffer.from([0x00, 0x00, 0x01, 0x02]);
const CRYPTO_SELECT = Buffer.from([0x00, 0x00, 0x00, 0x02]); // always try to choose RC4 encryption instead of plaintext

function xor(a, b) {
  for (let len = a.length; len--;) a[len] ^= b[len];

  return a;
}

let Request = /*#__PURE__*/_createClass(function Request(piece, offset, length, callback) {
  _classCallCheck(this, Request);

  this.piece = piece;
  this.offset = offset;
  this.length = length;
  this.callback = callback;
});

let HaveAllBitField = /*#__PURE__*/function () {
  function HaveAllBitField() {
    _classCallCheck(this, HaveAllBitField);

    this.buffer = new Uint8Array(); // dummy
  }

  _createClass(HaveAllBitField, [{
    key: "get",
    value: function get(index) {
      return true;
    }
  }, {
    key: "set",
    value: function set(index) {}
  }]);

  return HaveAllBitField;
}();

let Wire = /*#__PURE__*/function (_stream$Duplex) {
  _inherits(Wire, _stream$Duplex);

  var _super = _createSuper(Wire);

  function Wire() {
    var _this;

    let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    let retries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let peEnabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    _classCallCheck(this, Wire);

    _this = _super.call(this);
    _this._debugId = randombytes(4).toString('hex');

    _this._debug('new wire');

    _this.peerId = null; // remote peer id (hex string)

    _this.peerIdBuffer = null; // remote peer id (buffer)

    _this.type = type; // connection type ('webrtc', 'tcpIncoming', 'tcpOutgoing', 'webSeed')

    _this.amChoking = true; // are we choking the peer?

    _this.amInterested = false; // are we interested in the peer?

    _this.peerChoking = true; // is the peer choking us?

    _this.peerInterested = false; // is the peer interested in us?
    // The largest torrent that I know of (the Geocities archive) is ~641 GB and has
    // ~41,000 pieces. Therefore, cap bitfield to 10x larger (400,000 bits) to support all
    // possible torrents but prevent malicious peers from growing bitfield to fill memory.

    _this.peerPieces = new BitField(0, {
      grow: BITFIELD_GROW
    });
    _this.extensions = {};
    _this.peerExtensions = {};
    _this.requests = []; // outgoing

    _this.peerRequests = []; // incoming

    _this.extendedMapping = {}; // number -> string, ex: 1 -> 'ut_metadata'

    _this.peerExtendedMapping = {}; // string -> number, ex: 9 -> 'ut_metadata'
    // The extended handshake to send, minus the "m" field, which gets automatically
    // filled from `this.extendedMapping`

    _this.extendedHandshake = {};
    _this.peerExtendedHandshake = {}; // remote peer's extended handshake
    // BEP6 Fast Estension

    _this.hasFast = false; // is fast extension enabled?

    _this.allowedFastSet = []; // allowed fast set

    _this.peerAllowedFastSet = []; // peer's allowed fast set

    _this._ext = {}; // string -> function, ex 'ut_metadata' -> ut_metadata()

    _this._nextExt = 1;
    _this.uploaded = 0;
    _this.downloaded = 0;
    _this.uploadSpeed = speedometer();
    _this.downloadSpeed = speedometer();
    _this._keepAliveInterval = null;
    _this._timeout = null;
    _this._timeoutMs = 0;
    _this._timeoutExpiresAt = null;
    _this.destroyed = false; // was the wire ended by calling `destroy`?

    _this._finished = false;
    _this._parserSize = 0; // number of needed bytes to parse next message from remote peer

    _this._parser = null; // function to call once `this._parserSize` bytes are available

    _this._buffer = []; // incomplete message data

    _this._bufferSize = 0; // cached total length of buffers in `this._buffer`

    _this._peEnabled = peEnabled;

    if (peEnabled) {
      _this._dh = crypto.createDiffieHellman(DH_PRIME, 'hex', DH_GENERATOR); // crypto object used to generate keys/secret

      _this._myPubKey = _this._dh.generateKeys('hex'); // my DH public key
    } else {
      _this._myPubKey = null;
    }

    _this._peerPubKey = null; // peer's DH public key

    _this._sharedSecret = null; // shared DH secret

    _this._peerCryptoProvide = []; // encryption methods provided by peer; we expect this to always contain 0x02

    _this._cryptoHandshakeDone = false;
    _this._cryptoSyncPattern = null; // the pattern to search for when resynchronizing after receiving pe1/pe2

    _this._waitMaxBytes = null; // the maximum number of bytes resynchronization must occur within

    _this._encryptionMethod = null; // 1 for plaintext, 2 for RC4

    _this._encryptGenerator = null; // RC4 keystream generator for encryption

    _this._decryptGenerator = null; // RC4 keystream generator for decryption

    _this._setGenerators = false; // a flag for whether setEncrypt() has successfully completed

    _this.once('finish', () => _this._onFinish());

    _this.on('finish', _this._onFinish);

    _this._debug('type:', _this.type);

    if (_this.type === 'tcpIncoming' && _this._peEnabled) {
      // If we are not the initiator, we should wait to see if the client begins
      // with PE/MSE handshake or the standard bittorrent handshake.
      _this._determineHandshakeType();
    } else if (_this.type === 'tcpOutgoing' && _this._peEnabled && retries === 0) {
      _this._parsePe2();
    } else {
      _this._parseHandshake(null);
    }

    return _this;
  }
  /**
   * Set whether to send a "keep-alive" ping (sent every 55s)
   * @param {boolean} enable
   */


  _createClass(Wire, [{
    key: "setKeepAlive",
    value: function setKeepAlive(enable) {
      this._debug('setKeepAlive %s', enable);

      clearInterval(this._keepAliveInterval);
      if (enable === false) return;
      this._keepAliveInterval = setInterval(() => {
        this.keepAlive();
      }, KEEP_ALIVE_TIMEOUT);
    }
    /**
     * Set the amount of time to wait before considering a request to be "timed out"
     * @param {number} ms
     * @param {boolean=} unref (should the timer be unref'd? default: false)
     */

  }, {
    key: "setTimeout",
    value: function setTimeout(ms, unref) {
      this._debug('setTimeout ms=%d unref=%s', ms, unref);

      this._timeoutMs = ms;
      this._timeoutUnref = !!unref;

      this._resetTimeout(true);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.destroyed) return;
      this.destroyed = true;

      this._debug('destroy');

      this.emit('close');
      this.end();
      return this;
    }
  }, {
    key: "end",
    value: function end() {
      var _get2;

      this._debug('end');

      this._onUninterested();

      this._onChoke();

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return (_get2 = _get(_getPrototypeOf(Wire.prototype), "end", this)).call.apply(_get2, [this].concat(args));
    }
    /**
     * Use the specified protocol extension.
     * @param  {function} Extension
     */

  }, {
    key: "use",
    value: function use(Extension) {
      const name = Extension.prototype.name;

      if (!name) {
        throw new Error('Extension class requires a "name" property on the prototype');
      }

      this._debug('use extension.name=%s', name);

      const ext = this._nextExt;
      const handler = new Extension(this);

      function noop() {}

      if (typeof handler.onHandshake !== 'function') {
        handler.onHandshake = noop;
      }

      if (typeof handler.onExtendedHandshake !== 'function') {
        handler.onExtendedHandshake = noop;
      }

      if (typeof handler.onMessage !== 'function') {
        handler.onMessage = noop;
      }

      this.extendedMapping[ext] = name;
      this._ext[name] = handler;
      this[name] = handler;
      this._nextExt += 1;
    } //
    // OUTGOING MESSAGES
    //

    /**
     * Message "keep-alive": <len=0000>
     */

  }, {
    key: "keepAlive",
    value: function keepAlive() {
      this._debug('keep-alive');

      this._push(MESSAGE_KEEP_ALIVE);
    }
  }, {
    key: "sendPe1",
    value: function sendPe1() {
      if (this._peEnabled) {
        const padALen = Math.floor(Math.random() * 513);
        const padA = randombytes(padALen);

        this._push(Buffer.concat([Buffer.from(this._myPubKey, 'hex'), padA]));
      }
    }
  }, {
    key: "sendPe2",
    value: function sendPe2() {
      const padBLen = Math.floor(Math.random() * 513);
      const padB = randombytes(padBLen);

      this._push(Buffer.concat([Buffer.from(this._myPubKey, 'hex'), padB]));
    }
  }, {
    key: "sendPe3",
    value: function sendPe3(infoHash) {
      this.setEncrypt(this._sharedSecret, infoHash);
      const hash1Buffer = Buffer.from(sha1.sync(Buffer.from(this._utfToHex('req1') + this._sharedSecret, 'hex')), 'hex');
      const hash2Buffer = Buffer.from(sha1.sync(Buffer.from(this._utfToHex('req2') + infoHash, 'hex')), 'hex');
      const hash3Buffer = Buffer.from(sha1.sync(Buffer.from(this._utfToHex('req3') + this._sharedSecret, 'hex')), 'hex');
      const hashesXorBuffer = xor(hash2Buffer, hash3Buffer);
      const padCLen = randombytes(2).readUInt16BE(0) % 512;
      const padCBuffer = randombytes(padCLen);
      let vcAndProvideBuffer = Buffer.alloc(8 + 4 + 2 + padCLen + 2);
      VC.copy(vcAndProvideBuffer);
      CRYPTO_PROVIDE.copy(vcAndProvideBuffer, 8);
      vcAndProvideBuffer.writeInt16BE(padCLen, 12); // pad C length

      padCBuffer.copy(vcAndProvideBuffer, 14);
      vcAndProvideBuffer.writeInt16BE(0, 14 + padCLen); // IA length

      vcAndProvideBuffer = this._encryptHandshake(vcAndProvideBuffer);

      this._push(Buffer.concat([hash1Buffer, hashesXorBuffer, vcAndProvideBuffer]));
    }
  }, {
    key: "sendPe4",
    value: function sendPe4(infoHash) {
      this.setEncrypt(this._sharedSecret, infoHash);
      const padDLen = randombytes(2).readUInt16BE(0) % 512;
      const padDBuffer = randombytes(padDLen);
      let vcAndSelectBuffer = Buffer.alloc(8 + 4 + 2 + padDLen);
      VC.copy(vcAndSelectBuffer);
      CRYPTO_SELECT.copy(vcAndSelectBuffer, 8);
      vcAndSelectBuffer.writeInt16BE(padDLen, 12); // lenD?

      padDBuffer.copy(vcAndSelectBuffer, 14);
      vcAndSelectBuffer = this._encryptHandshake(vcAndSelectBuffer);

      this._push(vcAndSelectBuffer);

      this._cryptoHandshakeDone = true;

      this._debug('completed crypto handshake');
    }
    /**
     * Message: "handshake" <pstrlen><pstr><reserved><info_hash><peer_id>
     * @param  {Buffer|string} infoHash (as Buffer or *hex* string)
     * @param  {Buffer|string} peerId
     * @param  {Object} extensions
     */

  }, {
    key: "handshake",
    value: function handshake(infoHash, peerId, extensions) {
      let infoHashBuffer;
      let peerIdBuffer;

      if (typeof infoHash === 'string') {
        infoHash = infoHash.toLowerCase();
        infoHashBuffer = Buffer.from(infoHash, 'hex');
      } else {
        infoHashBuffer = infoHash;
        infoHash = infoHashBuffer.toString('hex');
      }

      if (typeof peerId === 'string') {
        peerIdBuffer = Buffer.from(peerId, 'hex');
      } else {
        peerIdBuffer = peerId;
        peerId = peerIdBuffer.toString('hex');
      }

      this._infoHash = infoHashBuffer;

      if (infoHashBuffer.length !== 20 || peerIdBuffer.length !== 20) {
        throw new Error('infoHash and peerId MUST have length 20');
      }

      this._debug('handshake i=%s p=%s exts=%o', infoHash, peerId, extensions);

      const reserved = Buffer.from(MESSAGE_RESERVED);
      this.extensions = {
        extended: true,
        dht: !!(extensions && extensions.dht),
        fast: !!(extensions && extensions.fast)
      };
      reserved[5] |= 0x10; // enable extended message

      if (this.extensions.dht) reserved[7] |= 0x01;
      if (this.extensions.fast) reserved[7] |= 0x04; // BEP6 Fast Extension: The extension is enabled only if both ends of the connection set this bit.

      if (this.extensions.fast && this.peerExtensions.fast) {
        this._debug('fast extension is enabled');

        this.hasFast = true;
      }

      this._push(Buffer.concat([MESSAGE_PROTOCOL, reserved, infoHashBuffer, peerIdBuffer]));

      this._handshakeSent = true;

      if (this.peerExtensions.extended && !this._extendedHandshakeSent) {
        // Peer's handshake indicated support already
        // (incoming connection)
        this._sendExtendedHandshake();
      }
    }
    /* Peer supports BEP-0010, send extended handshake.
     *
     * This comes after the 'handshake' event to give the user a chance to populate
     * `this.extendedHandshake` and `this.extendedMapping` before the extended handshake
     * is sent to the remote peer.
     */

  }, {
    key: "_sendExtendedHandshake",
    value: function _sendExtendedHandshake() {
      // Create extended message object from registered extensions
      const msg = Object.assign({}, this.extendedHandshake);
      msg.m = {};

      for (const ext in this.extendedMapping) {
        const name = this.extendedMapping[ext];
        msg.m[name] = Number(ext);
      } // Send extended handshake


      this.extended(0, bencode.encode(msg));
      this._extendedHandshakeSent = true;
    }
    /**
     * Message "choke": <len=0001><id=0>
     */

  }, {
    key: "choke",
    value: function choke() {
      if (this.amChoking) return;
      this.amChoking = true;

      this._debug('choke');

      this._push(MESSAGE_CHOKE);

      if (this.hasFast) {
        // BEP6: If a peer sends a choke, it MUST reject all requests from the peer to whom the choke
        // was sent except it SHOULD NOT reject requests for pieces that are in the allowed fast set.
        let allowedCount = 0;

        while (this.peerRequests.length > allowedCount) {
          // until only allowed requests are left
          const request = this.peerRequests[allowedCount]; // first non-allowed request

          if (this.allowedFastSet.includes(request.piece)) {
            ++allowedCount; // count request as allowed
          } else {
            this.reject(request.piece, request.offset, request.length); // removes from this.peerRequests
          }
        }
      } else {
        while (this.peerRequests.length) {
          this.peerRequests.pop();
        }
      }
    }
    /**
     * Message "unchoke": <len=0001><id=1>
     */

  }, {
    key: "unchoke",
    value: function unchoke() {
      if (!this.amChoking) return;
      this.amChoking = false;

      this._debug('unchoke');

      this._push(MESSAGE_UNCHOKE);
    }
    /**
     * Message "interested": <len=0001><id=2>
     */

  }, {
    key: "interested",
    value: function interested() {
      if (this.amInterested) return;
      this.amInterested = true;

      this._debug('interested');

      this._push(MESSAGE_INTERESTED);
    }
    /**
     * Message "uninterested": <len=0001><id=3>
     */

  }, {
    key: "uninterested",
    value: function uninterested() {
      if (!this.amInterested) return;
      this.amInterested = false;

      this._debug('uninterested');

      this._push(MESSAGE_UNINTERESTED);
    }
    /**
     * Message "have": <len=0005><id=4><piece index>
     * @param  {number} index
     */

  }, {
    key: "have",
    value: function have(index) {
      this._debug('have %d', index);

      this._message(4, [index], null);
    }
    /**
     * Message "bitfield": <len=0001+X><id=5><bitfield>
     * @param  {BitField|Buffer} bitfield
     */

  }, {
    key: "bitfield",
    value: function bitfield(_bitfield) {
      this._debug('bitfield');

      if (!Buffer.isBuffer(_bitfield)) _bitfield = _bitfield.buffer;

      this._message(5, [], _bitfield);
    }
    /**
     * Message "request": <len=0013><id=6><index><begin><length>
     * @param  {number}   index
     * @param  {number}   offset
     * @param  {number}   length
     * @param  {function} cb
     */

  }, {
    key: "request",
    value: function request(index, offset, length, cb) {
      if (!cb) cb = () => {};
      if (this._finished) return cb(new Error('wire is closed'));

      if (this.peerChoking && !(this.hasFast && this.peerAllowedFastSet.includes(index))) {
        return cb(new Error('peer is choking'));
      }

      this._debug('request index=%d offset=%d length=%d', index, offset, length);

      this.requests.push(new Request(index, offset, length, cb));

      if (!this._timeout) {
        this._resetTimeout(true);
      }

      this._message(6, [index, offset, length], null);
    }
    /**
     * Message "piece": <len=0009+X><id=7><index><begin><block>
     * @param  {number} index
     * @param  {number} offset
     * @param  {Buffer} buffer
     */

  }, {
    key: "piece",
    value: function piece(index, offset, buffer) {
      this._debug('piece index=%d offset=%d', index, offset);

      this._message(7, [index, offset], buffer);

      this.uploaded += buffer.length;
      this.uploadSpeed(buffer.length);
      this.emit('upload', buffer.length);
    }
    /**
     * Message "cancel": <len=0013><id=8><index><begin><length>
     * @param  {number} index
     * @param  {number} offset
     * @param  {number} length
     */

  }, {
    key: "cancel",
    value: function cancel(index, offset, length) {
      this._debug('cancel index=%d offset=%d length=%d', index, offset, length);

      this._callback(this._pull(this.requests, index, offset, length), new Error('request was cancelled'), null);

      this._message(8, [index, offset, length], null);
    }
    /**
     * Message: "port" <len=0003><id=9><listen-port>
     * @param {Number} port
     */

  }, {
    key: "port",
    value: function port(_port) {
      this._debug('port %d', _port);

      const message = Buffer.from(MESSAGE_PORT);
      message.writeUInt16BE(_port, 5);

      this._push(message);
    }
    /**
     * Message: "suggest" <len=0x0005><id=0x0D><piece index> (BEP6)
     * @param {number} index
     */

  }, {
    key: "suggest",
    value: function suggest(index) {
      if (!this.hasFast) throw Error('fast extension is disabled');

      this._debug('suggest %d', index);

      this._message(0x0D, [index], null);
    }
    /**
     * Message: "have-all" <len=0x0001><id=0x0E> (BEP6)
     */

  }, {
    key: "haveAll",
    value: function haveAll() {
      if (!this.hasFast) throw Error('fast extension is disabled');

      this._debug('have-all');

      this._push(MESSAGE_HAVE_ALL);
    }
    /**
     * Message: "have-none" <len=0x0001><id=0x0F> (BEP6)
     */

  }, {
    key: "haveNone",
    value: function haveNone() {
      if (!this.hasFast) throw Error('fast extension is disabled');

      this._debug('have-none');

      this._push(MESSAGE_HAVE_NONE);
    }
    /**
     * Message "reject": <len=0x000D><id=0x10><index><offset><length> (BEP6)
     * @param  {number}   index
     * @param  {number}   offset
     * @param  {number}   length
     */

  }, {
    key: "reject",
    value: function reject(index, offset, length) {
      if (!this.hasFast) throw Error('fast extension is disabled');

      this._debug('reject index=%d offset=%d length=%d', index, offset, length);

      this._pull(this.peerRequests, index, offset, length);

      this._message(0x10, [index, offset, length], null);
    }
    /**
     * Message: "allowed-fast" <len=0x0005><id=0x11><piece index> (BEP6)
     * @param {number} index
     */

  }, {
    key: "allowedFast",
    value: function allowedFast(index) {
      if (!this.hasFast) throw Error('fast extension is disabled');

      this._debug('allowed-fast %d', index);

      if (!this.allowedFastSet.includes(index)) this.allowedFastSet.push(index);

      this._message(0x11, [index], null);
    }
    /**
     * Message: "extended" <len=0005+X><id=20><ext-number><payload>
     * @param  {number|string} ext
     * @param  {Object} obj
     */

  }, {
    key: "extended",
    value: function extended(ext, obj) {
      this._debug('extended ext=%s', ext);

      if (typeof ext === 'string' && this.peerExtendedMapping[ext]) {
        ext = this.peerExtendedMapping[ext];
      }

      if (typeof ext === 'number') {
        const extId = Buffer.from([ext]);
        const buf = Buffer.isBuffer(obj) ? obj : bencode.encode(obj);

        this._message(20, [], Buffer.concat([extId, buf]));
      } else {
        throw new Error("Unrecognized extension: ".concat(ext));
      }
    }
    /**
     * Sets the encryption method for this wire, as per PSE/ME specification
     *
     * @param {string} sharedSecret:  A hex-encoded string, which is the shared secret agreed
     *                                upon from DH key exchange
     * @param {string} infoHash:  A hex-encoded info hash
     * @returns boolean, true if encryption setting succeeds, false if it fails.
     */

  }, {
    key: "setEncrypt",
    value: function setEncrypt(sharedSecret, infoHash) {
      let encryptKey;
      let decryptKey;
      let encryptKeyBuf;
      let encryptKeyIntArray;
      let decryptKeyBuf;
      let decryptKeyIntArray;

      switch (this.type) {
        case 'tcpIncoming':
          encryptKey = sha1.sync(Buffer.from(this._utfToHex('keyB') + sharedSecret + infoHash, 'hex'));
          decryptKey = sha1.sync(Buffer.from(this._utfToHex('keyA') + sharedSecret + infoHash, 'hex'));
          encryptKeyBuf = Buffer.from(encryptKey, 'hex');
          encryptKeyIntArray = [];

          for (const value of encryptKeyBuf.values()) {
            encryptKeyIntArray.push(value);
          }

          decryptKeyBuf = Buffer.from(decryptKey, 'hex');
          decryptKeyIntArray = [];

          for (const value of decryptKeyBuf.values()) {
            decryptKeyIntArray.push(value);
          }

          this._encryptGenerator = new RC4(encryptKeyIntArray);
          this._decryptGenerator = new RC4(decryptKeyIntArray);
          break;

        case 'tcpOutgoing':
          encryptKey = sha1.sync(Buffer.from(this._utfToHex('keyA') + sharedSecret + infoHash, 'hex'));
          decryptKey = sha1.sync(Buffer.from(this._utfToHex('keyB') + sharedSecret + infoHash, 'hex'));
          encryptKeyBuf = Buffer.from(encryptKey, 'hex');
          encryptKeyIntArray = [];

          for (const value of encryptKeyBuf.values()) {
            encryptKeyIntArray.push(value);
          }

          decryptKeyBuf = Buffer.from(decryptKey, 'hex');
          decryptKeyIntArray = [];

          for (const value of decryptKeyBuf.values()) {
            decryptKeyIntArray.push(value);
          }

          this._encryptGenerator = new RC4(encryptKeyIntArray);
          this._decryptGenerator = new RC4(decryptKeyIntArray);
          break;

        default:
          return false;
      } // Discard the first 1024 bytes, as per MSE/PE implementation


      for (let i = 0; i < 1024; i++) {
        this._encryptGenerator.randomByte();

        this._decryptGenerator.randomByte();
      }

      this._setGenerators = true;
      return true;
    }
    /**
     * Duplex stream method. Called whenever the remote peer stream wants data. No-op
     * since we'll just push data whenever we get it.
     */

  }, {
    key: "_read",
    value: function _read() {}
    /**
     * Send a message to the remote peer.
     */

  }, {
    key: "_message",
    value: function _message(id, numbers, data) {
      const dataLength = data ? data.length : 0;
      const buffer = Buffer.allocUnsafe(5 + 4 * numbers.length);
      buffer.writeUInt32BE(buffer.length + dataLength - 4, 0);
      buffer[4] = id;

      for (let i = 0; i < numbers.length; i++) {
        buffer.writeUInt32BE(numbers[i], 5 + 4 * i);
      }

      this._push(buffer);

      if (data) this._push(data);
    }
  }, {
    key: "_push",
    value: function _push(data) {
      if (this._finished) return;

      if (this._encryptionMethod === 2 && this._cryptoHandshakeDone) {
        data = this._encrypt(data);
      }

      return this.push(data);
    } //
    // INCOMING MESSAGES
    //

  }, {
    key: "_onKeepAlive",
    value: function _onKeepAlive() {
      this._debug('got keep-alive');

      this.emit('keep-alive');
    }
  }, {
    key: "_onPe1",
    value: function _onPe1(pubKeyBuffer) {
      this._peerPubKey = pubKeyBuffer.toString('hex');
      this._sharedSecret = this._dh.computeSecret(this._peerPubKey, 'hex', 'hex');
      this.emit('pe1');
    }
  }, {
    key: "_onPe2",
    value: function _onPe2(pubKeyBuffer) {
      this._peerPubKey = pubKeyBuffer.toString('hex');
      this._sharedSecret = this._dh.computeSecret(this._peerPubKey, 'hex', 'hex');
      this.emit('pe2');
    }
  }, {
    key: "_onPe3",
    value: function _onPe3(hashesXorBuffer) {
      const hash3 = sha1.sync(Buffer.from(this._utfToHex('req3') + this._sharedSecret, 'hex'));
      const sKeyHash = xor(Buffer.from(hash3, 'hex'), hashesXorBuffer).toString('hex');
      this.emit('pe3', sKeyHash);
    }
  }, {
    key: "_onPe3Encrypted",
    value: function _onPe3Encrypted(vcBuffer, peerProvideBuffer) {
      if (!vcBuffer.equals(VC)) {
        this._debug('Error: verification constant did not match');

        this.destroy();
        return;
      }

      for (const provideByte of peerProvideBuffer.values()) {
        if (provideByte !== 0) {
          this._peerCryptoProvide.push(provideByte);
        }
      }

      if (this._peerCryptoProvide.includes(2)) {
        this._encryptionMethod = 2;
      } else {
        this._debug('Error: RC4 encryption method not provided by peer');

        this.destroy();
      }
    }
  }, {
    key: "_onPe4",
    value: function _onPe4(peerSelectBuffer) {
      this._encryptionMethod = peerSelectBuffer.readUInt8(3);

      if (!CRYPTO_PROVIDE.includes(this._encryptionMethod)) {
        this._debug('Error: peer selected invalid crypto method');

        this.destroy();
      }

      this._cryptoHandshakeDone = true;

      this._debug('crypto handshake done');

      this.emit('pe4');
    }
  }, {
    key: "_onHandshake",
    value: function _onHandshake(infoHashBuffer, peerIdBuffer, extensions) {
      const infoHash = infoHashBuffer.toString('hex');
      const peerId = peerIdBuffer.toString('hex');

      this._debug('got handshake i=%s p=%s exts=%o', infoHash, peerId, extensions);

      this.peerId = peerId;
      this.peerIdBuffer = peerIdBuffer;
      this.peerExtensions = extensions; // BEP6 Fast Extension: The extension is enabled only if both ends of the connection set this bit.

      if (this.extensions.fast && this.peerExtensions.fast) {
        this._debug('fast extension is enabled');

        this.hasFast = true;
      }

      this.emit('handshake', infoHash, peerId, extensions);

      for (const name in this._ext) {
        this._ext[name].onHandshake(infoHash, peerId, extensions);
      }

      if (extensions.extended && this._handshakeSent && !this._extendedHandshakeSent) {
        // outgoing connection
        this._sendExtendedHandshake();
      }
    }
  }, {
    key: "_onChoke",
    value: function _onChoke() {
      this.peerChoking = true;

      this._debug('got choke');

      this.emit('choke');

      if (!this.hasFast) {
        // BEP6 Fast Extension: Choke no longer implicitly rejects all pending requests
        while (this.requests.length) {
          this._callback(this.requests.pop(), new Error('peer is choking'), null);
        }
      }
    }
  }, {
    key: "_onUnchoke",
    value: function _onUnchoke() {
      this.peerChoking = false;

      this._debug('got unchoke');

      this.emit('unchoke');
    }
  }, {
    key: "_onInterested",
    value: function _onInterested() {
      this.peerInterested = true;

      this._debug('got interested');

      this.emit('interested');
    }
  }, {
    key: "_onUninterested",
    value: function _onUninterested() {
      this.peerInterested = false;

      this._debug('got uninterested');

      this.emit('uninterested');
    }
  }, {
    key: "_onHave",
    value: function _onHave(index) {
      if (this.peerPieces.get(index)) return;

      this._debug('got have %d', index);

      this.peerPieces.set(index, true);
      this.emit('have', index);
    }
  }, {
    key: "_onBitField",
    value: function _onBitField(buffer) {
      this.peerPieces = new BitField(buffer);

      this._debug('got bitfield');

      this.emit('bitfield', this.peerPieces);
    }
  }, {
    key: "_onRequest",
    value: function _onRequest(index, offset, length) {
      if (this.amChoking && !(this.hasFast && this.allowedFastSet.includes(index))) {
        // BEP6: If a peer receives a request from a peer its choking, the peer receiving
        // the request SHOULD send a reject unless the piece is in the allowed fast set.
        if (this.hasFast) this.reject(index, offset, length);
        return;
      }

      this._debug('got request index=%d offset=%d length=%d', index, offset, length);

      const respond = (err, buffer) => {
        if (request !== this._pull(this.peerRequests, index, offset, length)) return;

        if (err) {
          this._debug('error satisfying request index=%d offset=%d length=%d (%s)', index, offset, length, err.message);

          if (this.hasFast) this.reject(index, offset, length);
          return;
        }

        this.piece(index, offset, buffer);
      };

      const request = new Request(index, offset, length, respond);
      this.peerRequests.push(request);
      this.emit('request', index, offset, length, respond);
    }
  }, {
    key: "_onPiece",
    value: function _onPiece(index, offset, buffer) {
      this._debug('got piece index=%d offset=%d', index, offset);

      this._callback(this._pull(this.requests, index, offset, buffer.length), null, buffer);

      this.downloaded += buffer.length;
      this.downloadSpeed(buffer.length);
      this.emit('download', buffer.length);
      this.emit('piece', index, offset, buffer);
    }
  }, {
    key: "_onCancel",
    value: function _onCancel(index, offset, length) {
      this._debug('got cancel index=%d offset=%d length=%d', index, offset, length);

      this._pull(this.peerRequests, index, offset, length);

      this.emit('cancel', index, offset, length);
    }
  }, {
    key: "_onPort",
    value: function _onPort(port) {
      this._debug('got port %d', port);

      this.emit('port', port);
    }
  }, {
    key: "_onSuggest",
    value: function _onSuggest(index) {
      if (!this.hasFast) {
        // BEP6: the peer MUST close the connection
        this._debug('Error: got suggest whereas fast extension is disabled');

        this.destroy();
        return;
      }

      this._debug('got suggest %d', index);

      this.emit('suggest', index);
    }
  }, {
    key: "_onHaveAll",
    value: function _onHaveAll() {
      if (!this.hasFast) {
        // BEP6: the peer MUST close the connection
        this._debug('Error: got have-all whereas fast extension is disabled');

        this.destroy();
        return;
      }

      this._debug('got have-all');

      this.peerPieces = new HaveAllBitField();
      this.emit('have-all');
    }
  }, {
    key: "_onHaveNone",
    value: function _onHaveNone() {
      if (!this.hasFast) {
        // BEP6: the peer MUST close the connection
        this._debug('Error: got have-none whereas fast extension is disabled');

        this.destroy();
        return;
      }

      this._debug('got have-none');

      this.emit('have-none');
    }
  }, {
    key: "_onReject",
    value: function _onReject(index, offset, length) {
      if (!this.hasFast) {
        // BEP6: the peer MUST close the connection
        this._debug('Error: got reject whereas fast extension is disabled');

        this.destroy();
        return;
      }

      this._debug('got reject index=%d offset=%d length=%d', index, offset, length);

      this._callback(this._pull(this.requests, index, offset, length), new Error('request was rejected'), null);

      this.emit('reject', index, offset, length);
    }
  }, {
    key: "_onAllowedFast",
    value: function _onAllowedFast(index) {
      if (!this.hasFast) {
        // BEP6: the peer MUST close the connection
        this._debug('Error: got allowed-fast whereas fast extension is disabled');

        this.destroy();
        return;
      }

      this._debug('got allowed-fast %d', index);

      if (!this.peerAllowedFastSet.includes(index)) this.peerAllowedFastSet.push(index);
      if (this.peerAllowedFastSet.length > ALLOWED_FAST_SET_MAX_LENGTH) this.peerAllowedFastSet.shift();
      this.emit('allowed-fast', index);
    }
  }, {
    key: "_onExtended",
    value: function _onExtended(ext, buf) {
      if (ext === 0) {
        let info;

        try {
          info = bencode.decode(buf);
        } catch (err) {
          this._debug('ignoring invalid extended handshake: %s', err.message || err);
        }

        if (!info) return;
        this.peerExtendedHandshake = info;

        if (typeof info.m === 'object') {
          for (const name in info.m) {
            this.peerExtendedMapping[name] = Number(info.m[name].toString());
          }
        }

        for (const name in this._ext) {
          if (this.peerExtendedMapping[name]) {
            this._ext[name].onExtendedHandshake(this.peerExtendedHandshake);
          }
        }

        this._debug('got extended handshake');

        this.emit('extended', 'handshake', this.peerExtendedHandshake);
      } else {
        if (this.extendedMapping[ext]) {
          ext = this.extendedMapping[ext]; // friendly name for extension

          if (this._ext[ext]) {
            // there is an registered extension handler, so call it
            this._ext[ext].onMessage(buf);
          }
        }

        this._debug('got extended message ext=%s', ext);

        this.emit('extended', ext, buf);
      }
    }
  }, {
    key: "_onTimeout",
    value: function _onTimeout() {
      this._debug('request timed out');

      this._callback(this.requests.shift(), new Error('request has timed out'), null);

      this.emit('timeout');
    }
    /**
     * Duplex stream method. Called whenever the remote peer has data for us. Data that the
     * remote peer sends gets buffered (i.e. not actually processed) until the right number
     * of bytes have arrived, determined by the last call to `this._parse(number, callback)`.
     * Once enough bytes have arrived to process the message, the callback function
     * (i.e. `this._parser`) gets called with the full buffer of data.
     * @param  {Buffer} data
     * @param  {string} encoding
     * @param  {function} cb
     */

  }, {
    key: "_write",
    value: function _write(data, encoding, cb) {
      if (this._encryptionMethod === 2 && this._cryptoHandshakeDone) {
        data = this._decrypt(data);
      }

      this._bufferSize += data.length;

      this._buffer.push(data);

      if (this._buffer.length > 1) {
        this._buffer = [Buffer.concat(this._buffer, this._bufferSize)];
      } // now this._buffer is an array containing a single Buffer


      if (this._cryptoSyncPattern) {
        const index = this._buffer[0].indexOf(this._cryptoSyncPattern);

        if (index !== -1) {
          this._buffer[0] = this._buffer[0].slice(index + this._cryptoSyncPattern.length);
          this._bufferSize -= index + this._cryptoSyncPattern.length;
          this._cryptoSyncPattern = null;
        } else if (this._bufferSize + data.length > this._waitMaxBytes + this._cryptoSyncPattern.length) {
          this._debug('Error: could not resynchronize');

          this.destroy();
          return;
        }
      }

      while (this._bufferSize >= this._parserSize && !this._cryptoSyncPattern) {
        if (this._parserSize === 0) {
          this._parser(Buffer.from([]));
        } else {
          const buffer = this._buffer[0]; // console.log('buffer:', this._buffer)

          this._bufferSize -= this._parserSize;
          this._buffer = this._bufferSize ? [buffer.slice(this._parserSize)] : [];

          this._parser(buffer.slice(0, this._parserSize));
        }
      }

      cb(null); // Signal that we're ready for more data
    }
  }, {
    key: "_callback",
    value: function _callback(request, err, buffer) {
      if (!request) return;

      this._resetTimeout(!this.peerChoking && !this._finished);

      request.callback(err, buffer);
    }
  }, {
    key: "_resetTimeout",
    value: function _resetTimeout(setAgain) {
      if (!setAgain || !this._timeoutMs || !this.requests.length) {
        clearTimeout(this._timeout);
        this._timeout = null;
        this._timeoutExpiresAt = null;
        return;
      }

      const timeoutExpiresAt = Date.now() + this._timeoutMs;

      if (this._timeout) {
        // If existing expiration is already within 5% of correct, it's close enough
        if (timeoutExpiresAt - this._timeoutExpiresAt < this._timeoutMs * 0.05) {
          return;
        }

        clearTimeout(this._timeout);
      }

      this._timeoutExpiresAt = timeoutExpiresAt;
      this._timeout = setTimeout(() => this._onTimeout(), this._timeoutMs);
      if (this._timeoutUnref && this._timeout.unref) this._timeout.unref();
    }
    /**
     * Takes a number of bytes that the local peer is waiting to receive from the remote peer
     * in order to parse a complete message, and a callback function to be called once enough
     * bytes have arrived.
     * @param  {number} size
     * @param  {function} parser
     */

  }, {
    key: "_parse",
    value: function _parse(size, parser) {
      this._parserSize = size;
      this._parser = parser;
    }
  }, {
    key: "_parseUntil",
    value: function _parseUntil(pattern, maxBytes) {
      this._cryptoSyncPattern = pattern;
      this._waitMaxBytes = maxBytes;
    }
    /**
     * Handle the first 4 bytes of a message, to determine the length of bytes that must be
     * waited for in order to have the whole message.
     * @param  {Buffer} buffer
     */

  }, {
    key: "_onMessageLength",
    value: function _onMessageLength(buffer) {
      const length = buffer.readUInt32BE(0);

      if (length > 0) {
        this._parse(length, this._onMessage);
      } else {
        this._onKeepAlive();

        this._parse(4, this._onMessageLength);
      }
    }
    /**
     * Handle a message from the remote peer.
     * @param  {Buffer} buffer
     */

  }, {
    key: "_onMessage",
    value: function _onMessage(buffer) {
      this._parse(4, this._onMessageLength);

      switch (buffer[0]) {
        case 0:
          return this._onChoke();

        case 1:
          return this._onUnchoke();

        case 2:
          return this._onInterested();

        case 3:
          return this._onUninterested();

        case 4:
          return this._onHave(buffer.readUInt32BE(1));

        case 5:
          return this._onBitField(buffer.slice(1));

        case 6:
          return this._onRequest(buffer.readUInt32BE(1), buffer.readUInt32BE(5), buffer.readUInt32BE(9));

        case 7:
          return this._onPiece(buffer.readUInt32BE(1), buffer.readUInt32BE(5), buffer.slice(9));

        case 8:
          return this._onCancel(buffer.readUInt32BE(1), buffer.readUInt32BE(5), buffer.readUInt32BE(9));

        case 9:
          return this._onPort(buffer.readUInt16BE(1));

        case 0x0D:
          return this._onSuggest(buffer.readUInt32BE(1));

        case 0x0E:
          return this._onHaveAll();

        case 0x0F:
          return this._onHaveNone();

        case 0x10:
          return this._onReject(buffer.readUInt32BE(1), buffer.readUInt32BE(5), buffer.readUInt32BE(9));

        case 0x11:
          return this._onAllowedFast(buffer.readUInt32BE(1));

        case 20:
          return this._onExtended(buffer.readUInt8(1), buffer.slice(2));

        default:
          this._debug('got unknown message');

          return this.emit('unknownmessage', buffer);
      }
    }
  }, {
    key: "_determineHandshakeType",
    value: function _determineHandshakeType() {
      this._parse(1, pstrLenBuffer => {
        const pstrlen = pstrLenBuffer.readUInt8(0);

        if (pstrlen === 19) {
          this._parse(pstrlen + 48, this._onHandshakeBuffer);
        } else {
          this._parsePe1(pstrLenBuffer);
        }
      });
    }
  }, {
    key: "_parsePe1",
    value: function _parsePe1(pubKeyPrefix) {
      this._parse(95, pubKeySuffix => {
        this._onPe1(Buffer.concat([pubKeyPrefix, pubKeySuffix]));

        this._parsePe3();
      });
    }
  }, {
    key: "_parsePe2",
    value: function _parsePe2() {
      this._parse(96, pubKey => {
        this._onPe2(pubKey);

        while (!this._setGenerators) {// Wait until generators have been set
        }

        this._parsePe4();
      });
    } // Handles the unencrypted portion of step 4

  }, {
    key: "_parsePe3",
    value: function _parsePe3() {
      const hash1Buffer = Buffer.from(sha1.sync(Buffer.from(this._utfToHex('req1') + this._sharedSecret, 'hex')), 'hex'); // synchronize on HASH('req1', S)

      this._parseUntil(hash1Buffer, 512);

      this._parse(20, buffer => {
        this._onPe3(buffer);

        while (!this._setGenerators) {// Wait until generators have been set
        }

        this._parsePe3Encrypted();
      });
    }
  }, {
    key: "_parsePe3Encrypted",
    value: function _parsePe3Encrypted() {
      this._parse(14, buffer => {
        const vcBuffer = this._decryptHandshake(buffer.slice(0, 8));

        const peerProvideBuffer = this._decryptHandshake(buffer.slice(8, 12));

        const padCLen = this._decryptHandshake(buffer.slice(12, 14)).readUInt16BE(0);

        this._parse(padCLen, padCBuffer => {
          padCBuffer = this._decryptHandshake(padCBuffer);

          this._parse(2, iaLenBuf => {
            const iaLen = this._decryptHandshake(iaLenBuf).readUInt16BE(0);

            this._parse(iaLen, iaBuffer => {
              iaBuffer = this._decryptHandshake(iaBuffer);

              this._onPe3Encrypted(vcBuffer, peerProvideBuffer, padCBuffer, iaBuffer);

              const pstrlen = iaLen ? iaBuffer.readUInt8(0) : null;
              const protocol = iaLen ? iaBuffer.slice(1, 20) : null;

              if (pstrlen === 19 && protocol.toString() === 'BitTorrent protocol') {
                this._onHandshakeBuffer(iaBuffer.slice(1));
              } else {
                this._parseHandshake();
              }
            });
          });
        });
      });
    }
  }, {
    key: "_parsePe4",
    value: function _parsePe4() {
      // synchronize on ENCRYPT(VC).
      // since we encrypt using bitwise xor, decryption and encryption are the same operation.
      // calling _decryptHandshake here advances the decrypt generator keystream forward 8 bytes
      const vcBufferEncrypted = this._decryptHandshake(VC);

      this._parseUntil(vcBufferEncrypted, 512);

      this._parse(6, buffer => {
        const peerSelectBuffer = this._decryptHandshake(buffer.slice(0, 4));

        const padDLen = this._decryptHandshake(buffer.slice(4, 6)).readUInt16BE(0);

        this._parse(padDLen, padDBuf => {
          this._decryptHandshake(padDBuf);

          this._onPe4(peerSelectBuffer);

          this._parseHandshake(null);
        });
      });
    }
    /**
     * Reads the handshake as specified by the bittorrent wire protocol.
     */

  }, {
    key: "_parseHandshake",
    value: function _parseHandshake() {
      this._parse(1, buffer => {
        const pstrlen = buffer.readUInt8(0);

        if (pstrlen !== 19) {
          this._debug('Error: wire not speaking BitTorrent protocol (%s)', pstrlen.toString());

          this.end();
          return;
        }

        this._parse(pstrlen + 48, this._onHandshakeBuffer);
      });
    }
  }, {
    key: "_onHandshakeBuffer",
    value: function _onHandshakeBuffer(handshake) {
      const protocol = handshake.slice(0, 19);

      if (protocol.toString() !== 'BitTorrent protocol') {
        this._debug('Error: wire not speaking BitTorrent protocol (%s)', protocol.toString());

        this.end();
        return;
      }

      handshake = handshake.slice(19);

      this._onHandshake(handshake.slice(8, 28), handshake.slice(28, 48), {
        dht: !!(handshake[7] & 0x01),
        // see bep_0005
        fast: !!(handshake[7] & 0x04),
        // see bep_0006
        extended: !!(handshake[5] & 0x10) // see bep_0010

      });

      this._parse(4, this._onMessageLength);
    }
  }, {
    key: "_onFinish",
    value: function _onFinish() {
      this._finished = true;
      this.push(null); // stream cannot be half open, so signal the end of it

      while (this.read()) {// body intentionally empty
        // consume and discard the rest of the stream data
      }

      clearInterval(this._keepAliveInterval);

      this._parse(Number.MAX_VALUE, () => {});

      while (this.peerRequests.length) {
        this.peerRequests.pop();
      }

      while (this.requests.length) {
        this._callback(this.requests.pop(), new Error('wire was closed'), null);
      }
    }
  }, {
    key: "_debug",
    value: function _debug() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      args[0] = "[".concat(this._debugId, "] ").concat(args[0]);
      debug.apply(void 0, args);
    }
  }, {
    key: "_pull",
    value: function _pull(requests, piece, offset, length) {
      for (let i = 0; i < requests.length; i++) {
        const req = requests[i];

        if (req.piece === piece && req.offset === offset && req.length === length) {
          arrayRemove(requests, i);
          return req;
        }
      }

      return null;
    }
  }, {
    key: "_encryptHandshake",
    value: function _encryptHandshake(buf) {
      const crypt = Buffer.from(buf);

      if (!this._encryptGenerator) {
        this._debug('Warning: Encrypting without any generator');

        return crypt;
      }

      for (let i = 0; i < buf.length; i++) {
        const keystream = this._encryptGenerator.randomByte();

        crypt[i] = crypt[i] ^ keystream;
      }

      return crypt;
    }
  }, {
    key: "_encrypt",
    value: function _encrypt(buf) {
      const crypt = Buffer.from(buf);

      if (!this._encryptGenerator || this._encryptionMethod !== 2) {
        return crypt;
      }

      for (let i = 0; i < buf.length; i++) {
        const keystream = this._encryptGenerator.randomByte();

        crypt[i] = crypt[i] ^ keystream;
      }

      return crypt;
    }
  }, {
    key: "_decryptHandshake",
    value: function _decryptHandshake(buf) {
      const decrypt = Buffer.from(buf);

      if (!this._decryptGenerator) {
        this._debug('Warning: Decrypting without any generator');

        return decrypt;
      }

      for (let i = 0; i < buf.length; i++) {
        const keystream = this._decryptGenerator.randomByte();

        decrypt[i] = decrypt[i] ^ keystream;
      }

      return decrypt;
    }
  }, {
    key: "_decrypt",
    value: function _decrypt(buf) {
      const decrypt = Buffer.from(buf);

      if (!this._decryptGenerator || this._encryptionMethod !== 2) {
        return decrypt;
      }

      for (let i = 0; i < buf.length; i++) {
        const keystream = this._decryptGenerator.randomByte();

        decrypt[i] = decrypt[i] ^ keystream;
      }

      return decrypt;
    }
  }, {
    key: "_utfToHex",
    value: function _utfToHex(str) {
      return Buffer.from(str, 'utf8').toString('hex');
    }
  }]);

  return Wire;
}(stream.Duplex);

module.exports = Wire;

/***/ }),

/***/ "./node_modules/blob-to-buffer/index.js":
/*!**********************************************!*\
  !*** ./node_modules/blob-to-buffer/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
/*! blob-to-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

/* global Blob, FileReader */
module.exports = function blobToBuffer(blob, cb) {
  if (typeof Blob === 'undefined' || !(blob instanceof Blob)) {
    throw new Error('first argument must be a Blob');
  }

  if (typeof cb !== 'function') {
    throw new Error('second argument must be a function');
  }

  const reader = new FileReader();

  function onLoadEnd(e) {
    reader.removeEventListener('loadend', onLoadEnd, false);
    if (e.error) cb(e.error);else cb(null, Buffer.from(reader.result));
  }

  reader.addEventListener('loadend', onLoadEnd, false);
  reader.readAsArrayBuffer(blob);
};

/***/ }),

/***/ "./node_modules/block-stream2/index.js":
/*!*********************************************!*\
  !*** ./node_modules/block-stream2/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

const {
  Transform
} = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js");

let Block = /*#__PURE__*/function (_Transform) {
  _inherits(Block, _Transform);

  var _super = _createSuper(Block);

  function Block(size) {
    var _this;

    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Block);

    _this = _super.call(this, opts);

    if (typeof size === 'object') {
      opts = size;
      size = opts.size;
    }

    _this.size = size || 512;
    const {
      nopad,
      zeroPadding = true
    } = opts;
    if (nopad) _this._zeroPadding = false;else _this._zeroPadding = !!zeroPadding;
    _this._buffered = [];
    _this._bufferedBytes = 0;
    return _this;
  }

  _createClass(Block, [{
    key: "_transform",
    value: function _transform(buf, enc, next) {
      this._bufferedBytes += buf.length;

      this._buffered.push(buf);

      while (this._bufferedBytes >= this.size) {
        this._bufferedBytes -= this.size; // Assemble the buffers that will compose the final block

        const blockBufs = [];
        let blockBufsBytes = 0;

        while (blockBufsBytes < this.size) {
          const b = this._buffered.shift();

          if (blockBufsBytes + b.length <= this.size) {
            blockBufs.push(b);
            blockBufsBytes += b.length;
          } else {
            // If the last buffer is larger than needed for the block, just
            // use the needed part
            const neededSize = this.size - blockBufsBytes;
            blockBufs.push(b.slice(0, neededSize));
            blockBufsBytes += neededSize;

            this._buffered.unshift(b.slice(neededSize));
          }
        } // Then concat just those buffers, leaving the rest untouched in _buffered


        this.push(Buffer.concat(blockBufs, this.size));
      }

      next();
    }
  }, {
    key: "_flush",
    value: function _flush() {
      if (this._bufferedBytes && this._zeroPadding) {
        const zeroes = Buffer.alloc(this.size - this._bufferedBytes);

        this._buffered.push(zeroes);

        this.push(Buffer.concat(this._buffered));
        this._buffered = null;
      } else if (this._bufferedBytes) {
        this.push(Buffer.concat(this._buffered));
        this._buffered = null;
      }

      this.push(null);
    }
  }]);

  return Block;
}(Transform);

module.exports = Block;

/***/ }),

/***/ "./node_modules/buffer-alloc-unsafe/index.js":
/*!***************************************************!*\
  !*** ./node_modules/buffer-alloc-unsafe/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
function allocUnsafe(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  }

  if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }

  if (Buffer.allocUnsafe) {
    return Buffer.allocUnsafe(size);
  } else {
    return new Buffer(size);
  }
}

module.exports = allocUnsafe;

/***/ }),

/***/ "./node_modules/buffer-alloc/index.js":
/*!********************************************!*\
  !*** ./node_modules/buffer-alloc/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
var bufferFill = __webpack_require__(/*! buffer-fill */ "./node_modules/buffer-fill/index.js");

var allocUnsafe = __webpack_require__(/*! buffer-alloc-unsafe */ "./node_modules/buffer-alloc-unsafe/index.js");

module.exports = function alloc(size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  }

  if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }

  if (Buffer.alloc) {
    return Buffer.alloc(size, fill, encoding);
  }

  var buffer = allocUnsafe(size);

  if (size === 0) {
    return buffer;
  }

  if (fill === undefined) {
    return bufferFill(buffer, 0);
  }

  if (typeof encoding !== 'string') {
    encoding = undefined;
  }

  return bufferFill(buffer, fill, encoding);
};

/***/ }),

/***/ "./node_modules/buffer-fill/index.js":
/*!*******************************************!*\
  !*** ./node_modules/buffer-fill/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
/* Node.js 6.4.0 and up has full support */
var hasFullSupport = function () {
  try {
    if (!Buffer.isEncoding('latin1')) {
      return false;
    }

    var buf = Buffer.alloc ? Buffer.alloc(4) : new Buffer(4);
    buf.fill('ab', 'ucs2');
    return buf.toString('hex') === '61006200';
  } catch (_) {
    return false;
  }
}();

function isSingleByte(val) {
  return val.length === 1 && val.charCodeAt(0) < 256;
}

function fillWithNumber(buffer, val, start, end) {
  if (start < 0 || end > buffer.length) {
    throw new RangeError('Out of range index');
  }

  start = start >>> 0;
  end = end === undefined ? buffer.length : end >>> 0;

  if (end > start) {
    buffer.fill(val, start, end);
  }

  return buffer;
}

function fillWithBuffer(buffer, val, start, end) {
  if (start < 0 || end > buffer.length) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return buffer;
  }

  start = start >>> 0;
  end = end === undefined ? buffer.length : end >>> 0;
  var pos = start;
  var len = val.length;

  while (pos <= end - len) {
    val.copy(buffer, pos);
    pos += len;
  }

  if (pos !== end) {
    val.copy(buffer, pos, 0, end - pos);
  }

  return buffer;
}

function fill(buffer, val, start, end, encoding) {
  if (hasFullSupport) {
    return buffer.fill(val, start, end, encoding);
  }

  if (typeof val === 'number') {
    return fillWithNumber(buffer, val, start, end);
  }

  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = buffer.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = buffer.length;
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (encoding === 'latin1') {
      encoding = 'binary';
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }

    if (val === '') {
      return fillWithNumber(buffer, 0, start, end);
    }

    if (isSingleByte(val)) {
      return fillWithNumber(buffer, val.charCodeAt(0), start, end);
    }

    val = new Buffer(val, encoding);
  }

  if (Buffer.isBuffer(val)) {
    return fillWithBuffer(buffer, val, start, end);
  } // Other values (e.g. undefined, boolean, object) results in zero-fill


  return fillWithNumber(buffer, 0, start, end);
}

module.exports = fill;

/***/ }),

/***/ "./node_modules/builtin-status-codes/browser.js":
/*!******************************************************!*\
  !*** ./node_modules/builtin-status-codes/browser.js ***!
  \******************************************************/
/***/ ((module) => {

module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};

/***/ }),

/***/ "./node_modules/cache-chunk-store/index.js":
/*!*************************************************!*\
  !*** ./node_modules/cache-chunk-store/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/*! cache-chunk-store. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
const LRU = __webpack_require__(/*! lru */ "./node_modules/lru/index.js");

const queueMicrotask = __webpack_require__(/*! queue-microtask */ "./node_modules/queue-microtask/index.js");

let CacheStore = /*#__PURE__*/function () {
  function CacheStore(store, opts) {
    _classCallCheck(this, CacheStore);

    this.store = store;
    this.chunkLength = store.chunkLength;
    this.inProgressGets = new Map(); // Map from chunk index to info on callbacks waiting for that chunk

    if (!this.store || !this.store.get || !this.store.put) {
      throw new Error('First argument must be abstract-chunk-store compliant');
    }

    this.cache = new LRU(opts);
  }

  _createClass(CacheStore, [{
    key: "put",
    value: function put(index, buf) {
      let cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};

      if (!this.cache) {
        return queueMicrotask(() => cb(new Error('CacheStore closed')));
      }

      this.cache.remove(index);
      this.store.put(index, buf, cb);
    }
  }, {
    key: "get",
    value: function get(index, opts) {
      let cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
      if (typeof opts === 'function') return this.get(index, null, opts);

      if (!this.cache) {
        return queueMicrotask(() => cb(new Error('CacheStore closed')));
      }

      if (!opts) opts = {};
      let buf = this.cache.get(index);

      if (buf) {
        const offset = opts.offset || 0;
        const len = opts.length || buf.length - offset;

        if (offset !== 0 || len !== buf.length) {
          buf = buf.slice(offset, len + offset);
        }

        return queueMicrotask(() => cb(null, buf));
      } // See if a get for this index has already started


      let waiters = this.inProgressGets.get(index);
      const getAlreadyStarted = !!waiters;

      if (!waiters) {
        waiters = [];
        this.inProgressGets.set(index, waiters);
      }

      waiters.push({
        opts,
        cb
      });

      if (!getAlreadyStarted) {
        this.store.get(index, (err, buf) => {
          if (!err && this.cache != null) this.cache.set(index, buf);
          const inProgressEntry = this.inProgressGets.get(index);
          this.inProgressGets.delete(index);

          for (const {
            opts,
            cb
          } of inProgressEntry) {
            if (err) {
              cb(err);
            } else {
              const offset = opts.offset || 0;
              const len = opts.length || buf.length - offset;
              let slicedBuf = buf;

              if (offset !== 0 || len !== buf.length) {
                slicedBuf = buf.slice(offset, len + offset);
              }

              cb(null, slicedBuf);
            }
          }
        });
      }
    }
  }, {
    key: "close",
    value: function close() {
      let cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};

      if (!this.cache) {
        return queueMicrotask(() => cb(new Error('CacheStore closed')));
      }

      this.cache = null;
      this.store.close(cb);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      let cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};

      if (!this.cache) {
        return queueMicrotask(() => cb(new Error('CacheStore closed')));
      }

      this.cache = null;
      this.store.destroy(cb);
    }
  }]);

  return CacheStore;
}();

module.exports = CacheStore;

/***/ }),

/***/ "./node_modules/chunk-store-stream/write.js":
/*!**************************************************!*\
  !*** ./node_modules/chunk-store-stream/write.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

const BlockStream = __webpack_require__(/*! block-stream2 */ "./node_modules/block-stream2/index.js");

const stream = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js");

let ChunkStoreWriteStream = /*#__PURE__*/function (_stream$Writable) {
  _inherits(ChunkStoreWriteStream, _stream$Writable);

  var _super = _createSuper(ChunkStoreWriteStream);

  function ChunkStoreWriteStream(store, chunkLength) {
    var _this;

    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, ChunkStoreWriteStream);

    _this = _super.call(this, opts);

    if (!store || !store.put || !store.get) {
      throw new Error('First argument must be an abstract-chunk-store compliant store');
    }

    chunkLength = Number(chunkLength);
    if (!chunkLength) throw new Error('Second argument must be a chunk length');
    const zeroPadding = opts.zeroPadding === undefined ? false : opts.zeroPadding;
    _this._blockstream = new BlockStream(chunkLength, _objectSpread(_objectSpread({}, opts), {}, {
      zeroPadding
    }));
    _this._outstandingPuts = 0;
    _this._storeMaxOutstandingPuts = opts.storeMaxOutstandingPuts || 16;
    let index = 0;

    const onData = chunk => {
      if (_this.destroyed) return;
      _this._outstandingPuts += 1;

      if (_this._outstandingPuts >= _this._storeMaxOutstandingPuts) {
        _this._blockstream.pause();
      }

      store.put(index, chunk, err => {
        if (err) return _this.destroy(err);
        _this._outstandingPuts -= 1;

        if (_this._outstandingPuts < _this._storeMaxOutstandingPuts) {
          _this._blockstream.resume();
        }

        if (_this._outstandingPuts === 0 && typeof _this._finalCb === 'function') {
          _this._finalCb(null);

          _this._finalCb = null;
        }
      });
      index += 1;
    };

    _this._blockstream.on('data', onData).on('error', err => {
      _this.destroy(err);
    });

    return _this;
  }

  _createClass(ChunkStoreWriteStream, [{
    key: "_write",
    value: function _write(chunk, encoding, callback) {
      this._blockstream.write(chunk, encoding, callback);
    }
  }, {
    key: "_final",
    value: function _final(cb) {
      this._blockstream.end();

      this._blockstream.once('end', () => {
        if (this._outstandingPuts === 0) cb(null);else this._finalCb = cb;
      });
    }
  }, {
    key: "destroy",
    value: function destroy(err) {
      if (this.destroyed) return;
      this.destroyed = true;
      if (err) this.emit('error', err);
      this.emit('close');
    }
  }]);

  return ChunkStoreWriteStream;
}(stream.Writable);

module.exports = ChunkStoreWriteStream;

/***/ }),

/***/ "./node_modules/cpus/browser.js":
/*!**************************************!*\
  !*** ./node_modules/cpus/browser.js ***!
  \**************************************/
/***/ ((module) => {

module.exports = function cpus() {
  var num = navigator.hardwareConcurrency || 1;
  var cpus = [];

  for (var i = 0; i < num; i++) {
    cpus.push({
      model: '',
      speed: 0,
      times: {
        user: 0,
        nice: 0,
        sys: 0,
        idle: 0,
        irq: 0
      }
    });
  }

  return cpus;
};

/***/ }),

/***/ "./node_modules/create-torrent/index.js":
/*!**********************************************!*\
  !*** ./node_modules/create-torrent/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
/*! create-torrent. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
const bencode = __webpack_require__(/*! bencode */ "./node_modules/bencode/lib/index.js");

const BlockStream = __webpack_require__(/*! block-stream2 */ "./node_modules/block-stream2/index.js");

const calcPieceLength = __webpack_require__(/*! piece-length */ "./node_modules/piece-length/index.js");

const corePath = __webpack_require__(/*! path */ "./src/shims/path.ts");

const {
  BlobReadStream
} = __webpack_require__(/*! fast-blob-stream */ "./node_modules/fast-blob-stream/index.js");

const isFile = __webpack_require__(/*! is-file */ "?f12c");

const junk = __webpack_require__(/*! junk */ "./node_modules/junk/index.js");

const MultiStream = __webpack_require__(/*! multistream */ "./node_modules/multistream/index.js");

const once = __webpack_require__(/*! once */ "./node_modules/once/once.js");

const parallel = __webpack_require__(/*! run-parallel */ "./node_modules/run-parallel/index.js");

const queueMicrotask = __webpack_require__(/*! queue-microtask */ "./node_modules/queue-microtask/index.js");

const sha1 = __webpack_require__(/*! simple-sha1 */ "./node_modules/simple-sha1/browser.js");

const stream = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js");

const getFiles = __webpack_require__(/*! ./get-files */ "?3b18"); // browser exclude


const announceList = [['udp://tracker.leechers-paradise.org:6969'], ['udp://tracker.coppersurfer.tk:6969'], ['udp://tracker.opentrackr.org:1337'], ['udp://explodie.org:6969'], ['udp://tracker.empire-js.us:1337'], ['wss://tracker.btorrent.xyz'], ['wss://tracker.openwebtorrent.com']];
/**
 * Create a torrent.
 * @param  {string|File|FileList|Buffer|Stream|Array.<string|File|Buffer|Stream>} input
 * @param  {Object} opts
 * @param  {string=} opts.name
 * @param  {Date=} opts.creationDate
 * @param  {string=} opts.comment
 * @param  {string=} opts.createdBy
 * @param  {boolean|number=} opts.private
 * @param  {number=} opts.pieceLength
 * @param  {Array.<Array.<string>>=} opts.announceList
 * @param  {Array.<string>=} opts.urlList
 * @param  {Object=} opts.info
 * @param  {Function} opts.onProgress
 * @param  {function} cb
 * @return {Buffer} buffer of .torrent file data
 */

function createTorrent(input, opts, cb) {
  if (typeof opts === 'function') [opts, cb] = [cb, opts];
  opts = opts ? Object.assign({}, opts) : {};

  _parseInput(input, opts, (err, files, singleFileTorrent) => {
    if (err) return cb(err);
    opts.singleFileTorrent = singleFileTorrent;
    onFiles(files, opts, cb);
  });
}

function parseInput(input, opts, cb) {
  if (typeof opts === 'function') [opts, cb] = [cb, opts];
  opts = opts ? Object.assign({}, opts) : {};

  _parseInput(input, opts, cb);
}

const pathSymbol = Symbol('itemPath');
/**
 * Parse input file and return file information.
 */

function _parseInput(input, opts, cb) {
  if (isFileList(input)) input = Array.from(input);
  if (!Array.isArray(input)) input = [input];
  if (input.length === 0) throw new Error('invalid input type');
  input.forEach(item => {
    if (item == null) throw new Error("invalid input type: ".concat(item));
  }); // In Electron, use the true file path

  input = input.map(item => {
    if (isBlob(item) && typeof item.path === 'string' && typeof getFiles === 'function') return item.path;
    return item;
  }); // If there's just one file, allow the name to be set by `opts.name`

  if (input.length === 1 && typeof input[0] !== 'string' && !input[0].name) input[0].name = opts.name;
  let commonPrefix = null;
  input.forEach((item, i) => {
    if (typeof item === 'string') {
      return;
    }

    let path = item.fullPath || item.name;

    if (!path) {
      path = "Unknown File ".concat(i + 1);
      item.unknownName = true;
    }

    item[pathSymbol] = path.split('/'); // Remove initial slash

    if (!item[pathSymbol][0]) {
      item[pathSymbol].shift();
    }

    if (item[pathSymbol].length < 2) {
      // No real prefix
      commonPrefix = null;
    } else if (i === 0 && input.length > 1) {
      // The first file has a prefix
      commonPrefix = item[pathSymbol][0];
    } else if (item[pathSymbol][0] !== commonPrefix) {
      // The prefix doesn't match
      commonPrefix = null;
    }
  });
  const filterJunkFiles = opts.filterJunkFiles === undefined ? true : opts.filterJunkFiles;

  if (filterJunkFiles) {
    // Remove junk files
    input = input.filter(item => {
      if (typeof item === 'string') {
        return true;
      }

      return !isJunkPath(item[pathSymbol]);
    });
  }

  if (commonPrefix) {
    input.forEach(item => {
      const pathless = (Buffer.isBuffer(item) || isReadable(item)) && !item[pathSymbol];
      if (typeof item === 'string' || pathless) return;
      item[pathSymbol].shift();
    });
  }

  if (!opts.name && commonPrefix) {
    opts.name = commonPrefix;
  }

  if (!opts.name) {
    // use first user-set file name
    input.some(item => {
      if (typeof item === 'string') {
        opts.name = corePath.basename(item);
        return true;
      } else if (!item.unknownName) {
        opts.name = item[pathSymbol][item[pathSymbol].length - 1];
        return true;
      }

      return false;
    });
  }

  if (!opts.name) {
    opts.name = "Unnamed Torrent ".concat(Date.now());
  }

  const numPaths = input.reduce((sum, item) => sum + Number(typeof item === 'string'), 0);
  let isSingleFileTorrent = input.length === 1;

  if (input.length === 1 && typeof input[0] === 'string') {
    if (typeof getFiles !== 'function') {
      throw new Error('filesystem paths do not work in the browser');
    } // If there's a single path, verify it's a file before deciding this is a single
    // file torrent


    isFile(input[0], (err, pathIsFile) => {
      if (err) return cb(err);
      isSingleFileTorrent = pathIsFile;
      processInput();
    });
  } else {
    queueMicrotask(processInput);
  }

  function processInput() {
    parallel(input.map(item => cb => {
      const file = {};

      if (isBlob(item)) {
        file.getStream = getBlobStream(item);
        file.length = item.size;
      } else if (Buffer.isBuffer(item)) {
        file.getStream = getBufferStream(item);
        file.length = item.length;
      } else if (isReadable(item)) {
        file.getStream = getStreamStream(item, file);
        file.length = 0;
      } else if (typeof item === 'string') {
        if (typeof getFiles !== 'function') {
          throw new Error('filesystem paths do not work in the browser');
        }

        const keepRoot = numPaths > 1 || isSingleFileTorrent;
        getFiles(item, keepRoot, cb);
        return; // early return!
      } else {
        throw new Error('invalid input type');
      }

      file.path = item[pathSymbol];
      cb(null, file);
    }), (err, files) => {
      if (err) return cb(err);
      files = files.flat();
      cb(null, files, isSingleFileTorrent);
    });
  }
}

const MAX_OUTSTANDING_HASHES = 5;

function getPieceList(files, pieceLength, estimatedTorrentLength, opts, cb) {
  cb = once(cb);
  const pieces = [];
  let length = 0;
  let hashedLength = 0;
  const streams = files.map(file => file.getStream);
  let remainingHashes = 0;
  let pieceNum = 0;
  let ended = false;
  const multistream = new MultiStream(streams);
  const blockstream = new BlockStream(pieceLength, {
    zeroPadding: false
  });
  multistream.on('error', onError);
  multistream.pipe(blockstream).on('data', onData).on('end', onEnd).on('error', onError);

  function onData(chunk) {
    length += chunk.length;
    const i = pieceNum;
    sha1(chunk, hash => {
      pieces[i] = hash;
      remainingHashes -= 1;

      if (remainingHashes < MAX_OUTSTANDING_HASHES) {
        blockstream.resume();
      }

      hashedLength += chunk.length;
      if (opts.onProgress) opts.onProgress(hashedLength, estimatedTorrentLength);
      maybeDone();
    });
    remainingHashes += 1;

    if (remainingHashes >= MAX_OUTSTANDING_HASHES) {
      blockstream.pause();
    }

    pieceNum += 1;
  }

  function onEnd() {
    ended = true;
    maybeDone();
  }

  function onError(err) {
    cleanup();
    cb(err);
  }

  function cleanup() {
    multistream.removeListener('error', onError);
    blockstream.removeListener('data', onData);
    blockstream.removeListener('end', onEnd);
    blockstream.removeListener('error', onError);
  }

  function maybeDone() {
    if (ended && remainingHashes === 0) {
      cleanup();
      cb(null, Buffer.from(pieces.join(''), 'hex'), length);
    }
  }
}

function onFiles(files, opts, cb) {
  let announceList = opts.announceList;

  if (!announceList) {
    if (typeof opts.announce === 'string') announceList = [[opts.announce]];else if (Array.isArray(opts.announce)) {
      announceList = opts.announce.map(u => [u]);
    }
  }

  if (!announceList) announceList = [];

  if (globalThis.WEBTORRENT_ANNOUNCE) {
    if (typeof globalThis.WEBTORRENT_ANNOUNCE === 'string') {
      announceList.push([[globalThis.WEBTORRENT_ANNOUNCE]]);
    } else if (Array.isArray(globalThis.WEBTORRENT_ANNOUNCE)) {
      announceList = announceList.concat(globalThis.WEBTORRENT_ANNOUNCE.map(u => [u]));
    }
  } // When no trackers specified, use some reasonable defaults


  if (opts.announce === undefined && opts.announceList === undefined) {
    announceList = announceList.concat(module.exports.announceList);
  }

  if (typeof opts.urlList === 'string') opts.urlList = [opts.urlList];
  const torrent = {
    info: {
      name: opts.name
    },
    'creation date': Math.ceil((Number(opts.creationDate) || Date.now()) / 1000),
    encoding: 'UTF-8'
  };

  if (announceList.length !== 0) {
    torrent.announce = announceList[0][0];
    torrent['announce-list'] = announceList;
  }

  if (opts.comment !== undefined) torrent.comment = opts.comment;
  if (opts.createdBy !== undefined) torrent['created by'] = opts.createdBy;
  if (opts.private !== undefined) torrent.info.private = Number(opts.private);
  if (opts.info !== undefined) Object.assign(torrent.info, opts.info); // "ssl-cert" key is for SSL torrents, see:
  //   - http://blog.libtorrent.org/2012/01/bittorrent-over-ssl/
  //   - http://www.libtorrent.org/manual-ref.html#ssl-torrents
  //   - http://www.libtorrent.org/reference-Create_Torrents.html

  if (opts.sslCert !== undefined) torrent.info['ssl-cert'] = opts.sslCert;
  if (opts.urlList !== undefined) torrent['url-list'] = opts.urlList;
  const estimatedTorrentLength = files.reduce(sumLength, 0);
  const pieceLength = opts.pieceLength || calcPieceLength(estimatedTorrentLength);
  torrent.info['piece length'] = pieceLength;
  getPieceList(files, pieceLength, estimatedTorrentLength, opts, (err, pieces, torrentLength) => {
    if (err) return cb(err);
    torrent.info.pieces = pieces;
    files.forEach(file => {
      delete file.getStream;
    });

    if (opts.singleFileTorrent) {
      torrent.info.length = torrentLength;
    } else {
      torrent.info.files = files;
    }

    cb(null, bencode.encode(torrent));
  });
}
/**
 * Determine if a a file is junk based on its path
 * (defined as hidden OR recognized by the `junk` package)
 *
 * @param  {string} path
 * @return {boolean}
 */


function isJunkPath(path) {
  const filename = path[path.length - 1];
  return filename[0] === '.' && junk.is(filename);
}
/**
 * Accumulator to sum file lengths
 * @param  {number} sum
 * @param  {Object} file
 * @return {number}
 */


function sumLength(sum, file) {
  return sum + file.length;
}
/**
 * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
 * @param  {*} obj
 * @return {boolean}
 */


function isBlob(obj) {
  return typeof Blob !== 'undefined' && obj instanceof Blob;
}
/**
 * Check if `obj` is a W3C `FileList` object
 * @param  {*} obj
 * @return {boolean}
 */


function isFileList(obj) {
  return typeof FileList !== 'undefined' && obj instanceof FileList;
}
/**
 * Check if `obj` is a node Readable stream
 * @param  {*} obj
 * @return {boolean}
 */


function isReadable(obj) {
  return typeof obj === 'object' && obj != null && typeof obj.pipe === 'function';
}
/**
 * Convert a `File` to a lazy readable stream.
 * @param  {File|Blob} file
 * @return {function}
 */


function getBlobStream(file) {
  return () => new BlobReadStream(file);
}
/**
 * Convert a `Buffer` to a lazy readable stream.
 * @param  {Buffer} buffer
 * @return {function}
 */


function getBufferStream(buffer) {
  return () => {
    const s = new stream.PassThrough();
    s.end(buffer);
    return s;
  };
}
/**
 * Convert a readable stream to a lazy readable stream. Adds instrumentation to track
 * the number of bytes in the stream and set `file.length`.
 *
 * @param  {Stream} readable
 * @param  {Object} file
 * @return {function}
 */


function getStreamStream(readable, file) {
  return () => {
    const counter = new stream.Transform();

    counter._transform = function (buf, enc, done) {
      file.length += buf.length;
      this.push(buf);
      done();
    };

    readable.pipe(counter);
    return counter;
  };
}

module.exports = createTorrent;
module.exports.parseInput = parseInput;
module.exports.announceList = announceList;
module.exports.isJunkPath = isJunkPath;

/***/ }),

/***/ "./node_modules/end-of-stream/index.js":
/*!*********************************************!*\
  !*** ./node_modules/end-of-stream/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");
var once = __webpack_require__(/*! once */ "./node_modules/once/once.js");

var noop = function () {};

var isRequest = function (stream) {
  return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function (stream) {
  return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
};

var eos = function (stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var ws = stream._writableState;
  var rs = stream._readableState;
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var cancelled = false;

  var onlegacyfinish = function () {
    if (!stream.writable) onfinish();
  };

  var onfinish = function () {
    writable = false;
    if (!readable) callback.call(stream);
  };

  var onend = function () {
    readable = false;
    if (!writable) callback.call(stream);
  };

  var onexit = function (exitCode) {
    callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
  };

  var onerror = function (err) {
    callback.call(stream, err);
  };

  var onclose = function () {
    process.nextTick(onclosenexttick);
  };

  var onclosenexttick = function () {
    if (cancelled) return;
    if (readable && !(rs && rs.ended && !rs.destroyed)) return callback.call(stream, new Error('premature close'));
    if (writable && !(ws && ws.ended && !ws.destroyed)) return callback.call(stream, new Error('premature close'));
  };

  var onrequest = function () {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !ws) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  if (isChildProcess(stream)) stream.on('exit', onexit);
  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    cancelled = true;
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('exit', onexit);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
};

module.exports = eos;

/***/ }),

/***/ "./node_modules/fast-blob-stream/index.js":
/*!************************************************!*\
  !*** ./node_modules/fast-blob-stream/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

const {
  Readable,
  Writable
} = __webpack_require__(/*! streamx */ "./node_modules/streamx/index.js");

__webpack_require__(/*! fast-readable-async-iterator */ "./node_modules/fast-readable-async-iterator/index.js");

function BlobReadStream(blob) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return Readable.from(blob.stream(), opts);
}

let BlobWriteStream = /*#__PURE__*/function (_Writable) {
  _inherits(BlobWriteStream, _Writable);

  var _super = _createSuper(BlobWriteStream);

  function BlobWriteStream(callback) {
    var _this;

    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, BlobWriteStream);

    _this = _super.call(this, Object.assign({
      decodeStrings: false
    }, opts));
    _this.chunks = [];
    const mimeType = opts.mimeType;

    _this.once('close', () => {
      const blob = mimeType != null ? new Blob(_this.chunks, {
        type: mimeType
      }) : new Blob(_this.chunks);
      callback(blob);

      _this.emit('blob', blob);
    });

    return _this;
  }

  _createClass(BlobWriteStream, [{
    key: "_write",
    value: function _write(data, cb) {
      this.chunks.push(data);
      cb();
    }
  }]);

  return BlobWriteStream;
}(Writable);

module.exports = {
  BlobWriteStream,
  BlobReadStream
};

/***/ }),

/***/ "./node_modules/fast-fifo/fixed-size.js":
/*!**********************************************!*\
  !*** ./node_modules/fast-fifo/fixed-size.js ***!
  \**********************************************/
/***/ ((module) => {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

module.exports = /*#__PURE__*/function () {
  function FixedFIFO(hwm) {
    _classCallCheck(this, FixedFIFO);

    if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) throw new Error('Max size for a FixedFIFO should be a power of two');
    this.buffer = new Array(hwm);
    this.mask = hwm - 1;
    this.top = 0;
    this.btm = 0;
    this.next = null;
  }

  _createClass(FixedFIFO, [{
    key: "push",
    value: function push(data) {
      if (this.buffer[this.top] !== undefined) return false;
      this.buffer[this.top] = data;
      this.top = this.top + 1 & this.mask;
      return true;
    }
  }, {
    key: "shift",
    value: function shift() {
      const last = this.buffer[this.btm];
      if (last === undefined) return undefined;
      this.buffer[this.btm] = undefined;
      this.btm = this.btm + 1 & this.mask;
      return last;
    }
  }, {
    key: "peek",
    value: function peek() {
      return this.buffer[this.btm];
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.buffer[this.btm] === undefined;
    }
  }]);

  return FixedFIFO;
}();

/***/ }),

/***/ "./node_modules/fast-fifo/index.js":
/*!*****************************************!*\
  !*** ./node_modules/fast-fifo/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

const FixedFIFO = __webpack_require__(/*! ./fixed-size */ "./node_modules/fast-fifo/fixed-size.js");

module.exports = /*#__PURE__*/function () {
  function FastFIFO(hwm) {
    _classCallCheck(this, FastFIFO);

    this.hwm = hwm || 16;
    this.head = new FixedFIFO(this.hwm);
    this.tail = this.head;
  }

  _createClass(FastFIFO, [{
    key: "push",
    value: function push(val) {
      if (!this.head.push(val)) {
        const prev = this.head;
        this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
        this.head.push(val);
      }
    }
  }, {
    key: "shift",
    value: function shift() {
      const val = this.tail.shift();

      if (val === undefined && this.tail.next) {
        const next = this.tail.next;
        this.tail.next = null;
        this.tail = next;
        return this.tail.shift();
      }

      return val;
    }
  }, {
    key: "peek",
    value: function peek() {
      return this.tail.peek();
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.head.isEmpty();
    }
  }]);

  return FastFIFO;
}();

/***/ }),

/***/ "./node_modules/fast-readable-async-iterator/index.js":
/*!************************************************************!*\
  !*** ./node_modules/fast-readable-async-iterator/index.js ***!
  \************************************************************/
/***/ (() => {

if (typeof ReadableStream !== 'undefined' && !ReadableStream.prototype[Symbol.asyncIterator]) {
  ReadableStream.prototype[Symbol.asyncIterator] = function () {
    const reader = this.getReader();
    let last = reader.read();
    return {
      next() {
        const temp = last;
        last = reader.read();
        return temp;
      },

      return() {
        last.then(() => reader.releaseLock());
      },

      throw(err) {
        this.return();
        throw err;
      },

      [Symbol.asyncIterator]() {
        return this;
      }

    };
  };
}

/***/ }),

/***/ "./node_modules/https-browserify/index.js":
/*!************************************************!*\
  !*** ./node_modules/https-browserify/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var http = __webpack_require__(/*! http */ "./src/shims/http.ts");

var url = __webpack_require__(/*! url */ "./node_modules/url/url.js");

var https = module.exports;

for (var key in http) {
  if (http.hasOwnProperty(key)) https[key] = http[key];
}

https.request = function (params, cb) {
  params = validateParams(params);
  return http.request.call(this, params, cb);
};

https.get = function (params, cb) {
  params = validateParams(params);
  return http.get.call(this, params, cb);
};

function validateParams(params) {
  if (typeof params === 'string') {
    params = url.parse(params);
  }

  if (!params.protocol) {
    params.protocol = 'https:';
  }

  if (params.protocol !== 'https:') {
    throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"');
  }

  return params;
}

/***/ }),

/***/ "./node_modules/immediate-chunk-store/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/immediate-chunk-store/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/*! immediate-chunk-store. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
// TODO: remove when window.queueMicrotask() is well supported
const queueMicrotask = __webpack_require__(/*! queue-microtask */ "./node_modules/queue-microtask/index.js");

let ImmediateStore = /*#__PURE__*/function () {
  function ImmediateStore(store) {
    _classCallCheck(this, ImmediateStore);

    this.store = store;
    this.chunkLength = store.chunkLength;

    if (!this.store || !this.store.get || !this.store.put) {
      throw new Error('First argument must be abstract-chunk-store compliant');
    }

    this.mem = [];
  }

  _createClass(ImmediateStore, [{
    key: "put",
    value: function put(index, buf) {
      let cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
      this.mem[index] = buf;
      this.store.put(index, buf, err => {
        this.mem[index] = null;
        cb(err);
      });
    }
  }, {
    key: "get",
    value: function get(index, opts) {
      let cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
      if (typeof opts === 'function') return this.get(index, null, opts);
      let buf = this.mem[index]; // if the chunk isn't in the immediate memory cache

      if (!buf) {
        return this.store.get(index, opts, cb);
      }

      if (!opts) opts = {};
      const offset = opts.offset || 0;
      const len = opts.length || buf.length - offset;

      if (offset !== 0 || len !== buf.length) {
        buf = buf.slice(offset, len + offset);
      }

      queueMicrotask(() => cb(null, buf));
    }
  }, {
    key: "close",
    value: function close() {
      let cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};
      this.store.close(cb);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      let cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};
      this.store.destroy(cb);
    }
  }]);

  return ImmediateStore;
}();

module.exports = ImmediateStore;

/***/ }),

/***/ "./node_modules/is-ascii/index.js":
/*!****************************************!*\
  !*** ./node_modules/is-ascii/index.js ***!
  \****************************************/
/***/ ((module) => {

/* (c) 2016 Ari Porad (@ariporad) <http://ariporad.com>. License: ariporad.mit-license.org */
// Partially from http://stackoverflow.com/a/94049/1928484, and from another SO answer, which told me that the highest
// char code that's ascii is 127, but I can't find the link for. Sorry.
var MAX_ASCII_CHAR_CODE = 127;

module.exports = function isAscii(str) {
  for (var i = 0, strLen = str.length; i < strLen; ++i) {
    if (str.charCodeAt(i) > MAX_ASCII_CHAR_CODE) return false;
  }

  return true;
};

/***/ }),

/***/ "./node_modules/junk/index.js":
/*!************************************!*\
  !*** ./node_modules/junk/index.js ***!
  \************************************/
/***/ ((module, exports) => {

"use strict";


const blacklist = [// # All
'^npm-debug\\.log$', // Error log for npm
'^\\..*\\.swp$', // Swap file for vim state
// # macOS
'^\\.DS_Store$', // Stores custom folder attributes
'^\\.AppleDouble$', // Stores additional file resources
'^\\.LSOverride$', // Contains the absolute path to the app to be used
'^Icon\\r$', // Custom Finder icon: http://superuser.com/questions/298785/icon-file-on-os-x-desktop
'^\\._.*', // Thumbnail
'^\\.Spotlight-V100(?:$|\\/)', // Directory that might appear on external disk
'\\.Trashes', // File that might appear on external disk
'^__MACOSX$', // Resource fork
// # Linux
'~$', // Backup file
// # Windows
'^Thumbs\\.db$', // Image file cache
'^ehthumbs\\.db$', // Folder config file
'^Desktop\\.ini$', // Stores custom folder attributes
'@eaDir$' // Synology Diskstation "hidden" folder where the server stores thumbnails
];

exports.re = () => {
  throw new Error('`junk.re` was renamed to `junk.regex`');
};

exports.regex = new RegExp(blacklist.join('|'));

exports.is = filename => exports.regex.test(filename);

exports.not = filename => !exports.is(filename); // TODO: Remove this for the next major release


exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/limiter/index.js":
/*!***************************************!*\
  !*** ./node_modules/limiter/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.RateLimiter = __webpack_require__(/*! ./lib/rateLimiter */ "./node_modules/limiter/lib/rateLimiter.js");
exports.TokenBucket = __webpack_require__(/*! ./lib/tokenBucket */ "./node_modules/limiter/lib/tokenBucket.js");

/***/ }),

/***/ "./node_modules/limiter/lib/clock.js":
/*!*******************************************!*\
  !*** ./node_modules/limiter/lib/clock.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");
var getMilliseconds = function () {
  if (typeof process !== 'undefined' && process.hrtime) {
    var hrtime = process.hrtime();
    var seconds = hrtime[0];
    var nanoseconds = hrtime[1];
    return seconds * 1e3 + Math.floor(nanoseconds / 1e6);
  }

  return new Date().getTime();
};

module.exports = getMilliseconds;

/***/ }),

/***/ "./node_modules/limiter/lib/rateLimiter.js":
/*!*************************************************!*\
  !*** ./node_modules/limiter/lib/rateLimiter.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");
var TokenBucket = __webpack_require__(/*! ./tokenBucket */ "./node_modules/limiter/lib/tokenBucket.js");

var getMilliseconds = __webpack_require__(/*! ./clock */ "./node_modules/limiter/lib/clock.js");
/**
 * A generic rate limiter. Underneath the hood, this uses a token bucket plus
 * an additional check to limit how many tokens we can remove each interval.
 * @author John Hurliman <jhurliman@jhurliman.org>
 *
 * @param {Number} tokensPerInterval Maximum number of tokens that can be
 *  removed at any given moment and over the course of one interval.
 * @param {String|Number} interval The interval length in milliseconds, or as
 *  one of the following strings: 'second', 'minute', 'hour', day'.
 * @param {Boolean} fireImmediately Optional. Whether or not the callback
 *  will fire immediately when rate limiting is in effect (default is false).
 */


var RateLimiter = function (tokensPerInterval, interval, fireImmediately) {
  this.tokenBucket = new TokenBucket(tokensPerInterval, tokensPerInterval, interval, null); // Fill the token bucket to start

  this.tokenBucket.content = tokensPerInterval;
  this.curIntervalStart = getMilliseconds();
  this.tokensThisInterval = 0;
  this.fireImmediately = fireImmediately;
};

RateLimiter.prototype = {
  tokenBucket: null,
  curIntervalStart: 0,
  tokensThisInterval: 0,
  fireImmediately: false,

  /**
   * Remove the requested number of tokens and fire the given callback. If the
   * rate limiter contains enough tokens and we haven't spent too many tokens
   * in this interval already, this will happen immediately. Otherwise, the
   * removal and callback will happen when enough tokens become available.
   * @param {Number} count The number of tokens to remove.
   * @param {Function} callback(err, remainingTokens)
   * @returns {Boolean} True if the callback was fired immediately, otherwise
   *  false.
   */
  removeTokens: function (count, callback) {
    // Make sure the request isn't for more than we can handle
    if (count > this.tokenBucket.bucketSize) {
      process.nextTick(callback.bind(null, 'Requested tokens ' + count + ' exceeds maximum tokens per interval ' + this.tokenBucket.bucketSize, null));
      return false;
    }

    var self = this;
    var now = getMilliseconds(); // Advance the current interval and reset the current interval token count
    // if needed

    if (now < this.curIntervalStart || now - this.curIntervalStart >= this.tokenBucket.interval) {
      this.curIntervalStart = now;
      this.tokensThisInterval = 0;
    } // If we don't have enough tokens left in this interval, wait until the
    // next interval


    if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval) {
      if (this.fireImmediately) {
        process.nextTick(callback.bind(null, null, -1));
      } else {
        var waitInterval = Math.ceil(this.curIntervalStart + this.tokenBucket.interval - now);
        setTimeout(function () {
          self.tokenBucket.removeTokens(count, afterTokensRemoved);
        }, waitInterval);
      }

      return false;
    } // Remove the requested number of tokens from the token bucket


    return this.tokenBucket.removeTokens(count, afterTokensRemoved);

    function afterTokensRemoved(err, tokensRemaining) {
      if (err) return callback(err, null);
      self.tokensThisInterval += count;
      callback(null, tokensRemaining);
    }
  },

  /**
   * Attempt to remove the requested number of tokens and return immediately.
   * If the bucket (and any parent buckets) contains enough tokens and we
   * haven't spent too many tokens in this interval already, this will return
   * true. Otherwise, false is returned.
   * @param {Number} count The number of tokens to remove.
   * @param {Boolean} True if the tokens were successfully removed, otherwise
   *  false.
   */
  tryRemoveTokens: function (count) {
    // Make sure the request isn't for more than we can handle
    if (count > this.tokenBucket.bucketSize) return false;
    var now = getMilliseconds(); // Advance the current interval and reset the current interval token count
    // if needed

    if (now < this.curIntervalStart || now - this.curIntervalStart >= this.tokenBucket.interval) {
      this.curIntervalStart = now;
      this.tokensThisInterval = 0;
    } // If we don't have enough tokens left in this interval, return false


    if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval) return false; // Try to remove the requested number of tokens from the token bucket

    var removed = this.tokenBucket.tryRemoveTokens(count);

    if (removed) {
      this.tokensThisInterval += count;
    }

    return removed;
  },

  /**
   * Returns the number of tokens remaining in the TokenBucket.
   * @returns {Number} The number of tokens remaining.
   */
  getTokensRemaining: function () {
    this.tokenBucket.drip();
    return this.tokenBucket.content;
  }
};
module.exports = RateLimiter;

/***/ }),

/***/ "./node_modules/limiter/lib/tokenBucket.js":
/*!*************************************************!*\
  !*** ./node_modules/limiter/lib/tokenBucket.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");
/**
 * A hierarchical token bucket for rate limiting. See
 * http://en.wikipedia.org/wiki/Token_bucket for more information.
 * @author John Hurliman <jhurliman@cull.tv>
 *
 * @param {Number} bucketSize Maximum number of tokens to hold in the bucket.
 *  Also known as the burst rate.
 * @param {Number} tokensPerInterval Number of tokens to drip into the bucket
 *  over the course of one interval.
 * @param {String|Number} interval The interval length in milliseconds, or as
 *  one of the following strings: 'second', 'minute', 'hour', day'.
 * @param {TokenBucket} parentBucket Optional. A token bucket that will act as
 *  the parent of this bucket.
 */
var TokenBucket = function (bucketSize, tokensPerInterval, interval, parentBucket) {
  this.bucketSize = bucketSize;
  this.tokensPerInterval = tokensPerInterval;

  if (typeof interval === 'string') {
    switch (interval) {
      case 'sec':
      case 'second':
        this.interval = 1000;
        break;

      case 'min':
      case 'minute':
        this.interval = 1000 * 60;
        break;

      case 'hr':
      case 'hour':
        this.interval = 1000 * 60 * 60;
        break;

      case 'day':
        this.interval = 1000 * 60 * 60 * 24;
        break;

      default:
        throw new Error('Invaid interval ' + interval);
    }
  } else {
    this.interval = interval;
  }

  this.parentBucket = parentBucket;
  this.content = 0;
  this.lastDrip = +new Date();
};

TokenBucket.prototype = {
  bucketSize: 1,
  tokensPerInterval: 1,
  interval: 1000,
  parentBucket: null,
  content: 0,
  lastDrip: 0,

  /**
   * Remove the requested number of tokens and fire the given callback. If the
   * bucket (and any parent buckets) contains enough tokens this will happen
   * immediately. Otherwise, the removal and callback will happen when enough
   * tokens become available.
   * @param {Number} count The number of tokens to remove.
   * @param {Function} callback(err, remainingTokens)
   * @returns {Boolean} True if the callback was fired immediately, otherwise
   *  false.
   */
  removeTokens: function (count, callback) {
    var self = this; // Is this an infinite size bucket?

    if (!this.bucketSize) {
      process.nextTick(callback.bind(null, null, count, Number.POSITIVE_INFINITY));
      return true;
    } // Make sure the bucket can hold the requested number of tokens


    if (count > this.bucketSize) {
      process.nextTick(callback.bind(null, 'Requested tokens ' + count + ' exceeds bucket size ' + this.bucketSize, null));
      return false;
    } // Drip new tokens into this bucket


    this.drip(); // If we don't have enough tokens in this bucket, come back later

    if (count > this.content) return comeBackLater();

    if (this.parentBucket) {
      // Remove the requested from the parent bucket first
      return this.parentBucket.removeTokens(count, function (err, remainingTokens) {
        if (err) return callback(err, null); // Check that we still have enough tokens in this bucket

        if (count > self.content) return comeBackLater(); // Tokens were removed from the parent bucket, now remove them from
        // this bucket and fire the callback. Note that we look at the current
        // bucket and parent bucket's remaining tokens and return the smaller
        // of the two values

        self.content -= count;
        callback(null, Math.min(remainingTokens, self.content));
      });
    } else {
      // Remove the requested tokens from this bucket and fire the callback
      this.content -= count;
      process.nextTick(callback.bind(null, null, this.content));
      return true;
    }

    function comeBackLater() {
      // How long do we need to wait to make up the difference in tokens?
      var waitInterval = Math.ceil((count - self.content) * (self.interval / self.tokensPerInterval));
      setTimeout(function () {
        self.removeTokens(count, callback);
      }, waitInterval);
      return false;
    }
  },

  /**
   * Attempt to remove the requested number of tokens and return immediately.
   * If the bucket (and any parent buckets) contains enough tokens this will
   * return true, otherwise false is returned.
   * @param {Number} count The number of tokens to remove.
   * @param {Boolean} True if the tokens were successfully removed, otherwise
   *  false.
   */
  tryRemoveTokens: function (count) {
    // Is this an infinite size bucket?
    if (!this.bucketSize) return true; // Make sure the bucket can hold the requested number of tokens

    if (count > this.bucketSize) return false; // Drip new tokens into this bucket

    this.drip(); // If we don't have enough tokens in this bucket, return false

    if (count > this.content) return false; // Try to remove the requested tokens from the parent bucket

    if (this.parentBucket && !this.parentBucket.tryRemoveTokens(count)) return false; // Remove the requested tokens from this bucket and return

    this.content -= count;
    return true;
  },

  /**
   * Add any new tokens to the bucket since the last drip.
   * @returns {Boolean} True if new tokens were added, otherwise false.
   */
  drip: function () {
    if (!this.tokensPerInterval) {
      this.content = this.bucketSize;
      return;
    }

    var now = +new Date();
    var deltaMS = Math.max(now - this.lastDrip, 0);
    this.lastDrip = now;
    var dripAmount = deltaMS * (this.tokensPerInterval / this.interval);
    this.content = Math.min(this.content + dripAmount, this.bucketSize);
  }
};
module.exports = TokenBucket;

/***/ }),

/***/ "./node_modules/lru/index.js":
/*!***********************************!*\
  !*** ./node_modules/lru/index.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var events = __webpack_require__(/*! events */ "./node_modules/events/events.js");

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

module.exports = LRU;

function LRU(opts) {
  if (!(this instanceof LRU)) return new LRU(opts);
  if (typeof opts === 'number') opts = {
    max: opts
  };
  if (!opts) opts = {};
  events.EventEmitter.call(this);
  this.cache = {};
  this.head = this.tail = null;
  this.length = 0;
  this.max = opts.max || 1000;
  this.maxAge = opts.maxAge || 0;
}

inherits(LRU, events.EventEmitter);
Object.defineProperty(LRU.prototype, 'keys', {
  get: function () {
    return Object.keys(this.cache);
  }
});

LRU.prototype.clear = function () {
  this.cache = {};
  this.head = this.tail = null;
  this.length = 0;
};

LRU.prototype.remove = function (key) {
  if (typeof key !== 'string') key = '' + key;
  if (!this.cache.hasOwnProperty(key)) return;
  var element = this.cache[key];
  delete this.cache[key];

  this._unlink(key, element.prev, element.next);

  return element.value;
};

LRU.prototype._unlink = function (key, prev, next) {
  this.length--;

  if (this.length === 0) {
    this.head = this.tail = null;
  } else {
    if (this.head === key) {
      this.head = prev;
      this.cache[this.head].next = null;
    } else if (this.tail === key) {
      this.tail = next;
      this.cache[this.tail].prev = null;
    } else {
      this.cache[prev].next = next;
      this.cache[next].prev = prev;
    }
  }
};

LRU.prototype.peek = function (key) {
  if (!this.cache.hasOwnProperty(key)) return;
  var element = this.cache[key];
  if (!this._checkAge(key, element)) return;
  return element.value;
};

LRU.prototype.set = function (key, value) {
  if (typeof key !== 'string') key = '' + key;
  var element;

  if (this.cache.hasOwnProperty(key)) {
    element = this.cache[key];
    element.value = value;
    if (this.maxAge) element.modified = Date.now(); // If it's already the head, there's nothing more to do:

    if (key === this.head) return value;

    this._unlink(key, element.prev, element.next);
  } else {
    element = {
      value: value,
      modified: 0,
      next: null,
      prev: null
    };
    if (this.maxAge) element.modified = Date.now();
    this.cache[key] = element; // Eviction is only possible if the key didn't already exist:

    if (this.length === this.max) this.evict();
  }

  this.length++;
  element.next = null;
  element.prev = this.head;
  if (this.head) this.cache[this.head].next = key;
  this.head = key;
  if (!this.tail) this.tail = key;
  return value;
};

LRU.prototype._checkAge = function (key, element) {
  if (this.maxAge && Date.now() - element.modified > this.maxAge) {
    this.remove(key);
    this.emit('evict', {
      key: key,
      value: element.value
    });
    return false;
  }

  return true;
};

LRU.prototype.get = function (key) {
  if (typeof key !== 'string') key = '' + key;
  if (!this.cache.hasOwnProperty(key)) return;
  var element = this.cache[key];
  if (!this._checkAge(key, element)) return;

  if (this.head !== key) {
    if (key === this.tail) {
      this.tail = element.next;
      this.cache[this.tail].prev = null;
    } else {
      // Set prev.next -> element.next:
      this.cache[element.prev].next = element.next;
    } // Set element.next.prev -> element.prev:


    this.cache[element.next].prev = element.prev; // Element is the new head

    this.cache[this.head].next = key;
    element.prev = this.head;
    element.next = null;
    this.head = key;
  }

  return element.value;
};

LRU.prototype.evict = function () {
  if (!this.tail) return;
  var key = this.tail;
  var value = this.remove(this.tail);
  this.emit('evict', {
    key: key,
    value: value
  });
};

/***/ }),

/***/ "./node_modules/lt_donthave/index.js":
/*!*******************************************!*\
  !*** ./node_modules/lt_donthave/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/*! lt_donthave. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
const arrayRemove = __webpack_require__(/*! unordered-array-remove */ "./node_modules/unordered-array-remove/index.js");

const {
  EventEmitter
} = __webpack_require__(/*! events */ "./node_modules/events/events.js");

const debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")('lt_donthave');

module.exports = () => {
  let ltDontHave = /*#__PURE__*/function (_EventEmitter) {
    _inherits(ltDontHave, _EventEmitter);

    var _super = _createSuper(ltDontHave);

    function ltDontHave(wire) {
      var _this;

      _classCallCheck(this, ltDontHave);

      _this = _super.call(this);
      _this._peerSupports = false;
      _this._wire = wire;
      return _this;
    }

    _createClass(ltDontHave, [{
      key: "onExtendedHandshake",
      value: function onExtendedHandshake() {
        this._peerSupports = true;
      }
    }, {
      key: "onMessage",
      value: function onMessage(buf) {
        let index;

        try {
          index = buf.readUInt32BE();
        } catch (err) {
          // drop invalid messages
          return;
        }

        if (!this._wire.peerPieces.get(index)) return;
        debug('got donthave %d', index);

        this._wire.peerPieces.set(index, false);

        this.emit('donthave', index);

        this._failRequests(index);
      }
    }, {
      key: "donthave",
      value: function donthave(index) {
        if (!this._peerSupports) return;
        debug('donthave %d', index);
        const buf = Buffer.alloc(4);
        buf.writeUInt32BE(index);

        this._wire.extended('lt_donthave', buf);
      }
    }, {
      key: "_failRequests",
      value: function _failRequests(index) {
        const requests = this._wire.requests;

        for (let i = 0; i < requests.length; i++) {
          const req = requests[i];

          if (req.piece === index) {
            arrayRemove(requests, i);
            i -= 1; // Check the new value at the same slot

            this._wire._callback(req, new Error('peer sent donthave'), null);
          }
        }
      }
    }]);

    return ltDontHave;
  }(EventEmitter); // Name of the bittorrent-protocol extension


  ltDontHave.prototype.name = 'lt_donthave';
  return ltDontHave;
};

/***/ }),

/***/ "./node_modules/magnet-uri/index.js":
/*!******************************************!*\
  !*** ./node_modules/magnet-uri/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
/*! magnet-uri. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
module.exports = magnetURIDecode;
module.exports.decode = magnetURIDecode;
module.exports.encode = magnetURIEncode;

const base32 = __webpack_require__(/*! thirty-two */ "./node_modules/thirty-two/lib/thirty-two/index.js");

const bep53Range = __webpack_require__(/*! bep53-range */ "./node_modules/bep53-range/index.js");
/**
 * Parse a magnet URI and return an object of keys/values
 *
 * @param  {string} uri
 * @return {Object} parsed uri
 */


function magnetURIDecode(uri) {
  const result = {}; // Support 'magnet:' and 'stream-magnet:' uris

  const data = uri.split('magnet:?')[1];
  const params = data && data.length >= 0 ? data.split('&') : [];
  params.forEach(param => {
    const keyval = param.split('='); // This keyval is invalid, skip it

    if (keyval.length !== 2) return;
    const key = keyval[0];
    let val = keyval[1]; // Clean up torrent name

    if (key === 'dn') val = decodeURIComponent(val).replace(/\+/g, ' '); // Address tracker (tr), exact source (xs), and acceptable source (as) are encoded
    // URIs, so decode them

    if (key === 'tr' || key === 'xs' || key === 'as' || key === 'ws') {
      val = decodeURIComponent(val);
    } // Return keywords as an array


    if (key === 'kt') val = decodeURIComponent(val).split('+'); // Cast file index (ix) to a number

    if (key === 'ix') val = Number(val); // bep53

    if (key === 'so') val = bep53Range.parse(decodeURIComponent(val).split(',')); // If there are repeated parameters, return an array of values

    if (result[key]) {
      if (!Array.isArray(result[key])) {
        result[key] = [result[key]];
      }

      result[key].push(val);
    } else {
      result[key] = val;
    }
  }); // Convenience properties for parity with `parse-torrent-file` module

  let m;

  if (result.xt) {
    const xts = Array.isArray(result.xt) ? result.xt : [result.xt];
    xts.forEach(xt => {
      if (m = xt.match(/^urn:btih:(.{40})/)) {
        result.infoHash = m[1].toLowerCase();
      } else if (m = xt.match(/^urn:btih:(.{32})/)) {
        const decodedStr = base32.decode(m[1]);
        result.infoHash = Buffer.from(decodedStr, 'binary').toString('hex');
      } else if (m = xt.match(/^urn:btmh:1220(.{64})/)) {
        result.infoHashV2 = m[1].toLowerCase();
      }
    });
  }

  if (result.xs) {
    const xss = Array.isArray(result.xs) ? result.xs : [result.xs];
    xss.forEach(xs => {
      if (m = xs.match(/^urn:btpk:(.{64})/)) {
        result.publicKey = m[1].toLowerCase();
      }
    });
  }

  if (result.infoHash) result.infoHashBuffer = Buffer.from(result.infoHash, 'hex');
  if (result.infoHashV2) result.infoHashV2Buffer = Buffer.from(result.infoHashV2, 'hex');
  if (result.publicKey) result.publicKeyBuffer = Buffer.from(result.publicKey, 'hex');
  if (result.dn) result.name = result.dn;
  if (result.kt) result.keywords = result.kt;
  result.announce = [];

  if (typeof result.tr === 'string' || Array.isArray(result.tr)) {
    result.announce = result.announce.concat(result.tr);
  }

  result.urlList = [];

  if (typeof result.as === 'string' || Array.isArray(result.as)) {
    result.urlList = result.urlList.concat(result.as);
  }

  if (typeof result.ws === 'string' || Array.isArray(result.ws)) {
    result.urlList = result.urlList.concat(result.ws);
  }

  result.peerAddresses = [];

  if (typeof result['x.pe'] === 'string' || Array.isArray(result['x.pe'])) {
    result.peerAddresses = result.peerAddresses.concat(result['x.pe']);
  } // remove duplicates by converting to Set and back


  result.announce = Array.from(new Set(result.announce));
  result.urlList = Array.from(new Set(result.urlList));
  result.peerAddresses = Array.from(new Set(result.peerAddresses));
  return result;
}

function magnetURIEncode(obj) {
  obj = Object.assign({}, obj); // clone obj, so we can mutate it
  // support using convenience names, in addition to spec names
  // (example: `infoHash` for `xt`, `name` for `dn`)
  // Deduplicate xt by using a set

  let xts = new Set();
  if (obj.xt && typeof obj.xt === 'string') xts.add(obj.xt);
  if (obj.xt && Array.isArray(obj.xt)) xts = new Set(obj.xt);
  if (obj.infoHashBuffer) xts.add("urn:btih:".concat(obj.infoHashBuffer.toString('hex')));
  if (obj.infoHash) xts.add("urn:btih:".concat(obj.infoHash));
  if (obj.infoHashV2Buffer) xts.add(obj.xt = "urn:btmh:1220".concat(obj.infoHashV2Buffer.toString('hex')));
  if (obj.infoHashV2) xts.add("urn:btmh:1220".concat(obj.infoHashV2));
  const xtsDeduped = Array.from(xts);
  if (xtsDeduped.length === 1) obj.xt = xtsDeduped[0];
  if (xtsDeduped.length > 1) obj.xt = xtsDeduped;
  if (obj.publicKeyBuffer) obj.xs = "urn:btpk:".concat(obj.publicKeyBuffer.toString('hex'));
  if (obj.publicKey) obj.xs = "urn:btpk:".concat(obj.publicKey);
  if (obj.name) obj.dn = obj.name;
  if (obj.keywords) obj.kt = obj.keywords;
  if (obj.announce) obj.tr = obj.announce;

  if (obj.urlList) {
    obj.ws = obj.urlList;
    delete obj.as;
  }

  if (obj.peerAddresses) obj['x.pe'] = obj.peerAddresses;
  let result = 'magnet:?';
  Object.keys(obj).filter(key => key.length === 2 || key === 'x.pe').forEach((key, i) => {
    const values = Array.isArray(obj[key]) ? obj[key] : [obj[key]];
    values.forEach((val, j) => {
      if ((i > 0 || j > 0) && (key !== 'kt' && key !== 'so' || j === 0)) result += '&';
      if (key === 'dn') val = encodeURIComponent(val).replace(/%20/g, '+');

      if (key === 'tr' || key === 'as' || key === 'ws') {
        val = encodeURIComponent(val);
      } // Don't URI encode BEP46 keys


      if (key === 'xs' && !val.startsWith('urn:btpk:')) {
        val = encodeURIComponent(val);
      }

      if (key === 'kt') val = encodeURIComponent(val);
      if (key === 'so') return;
      if (key === 'kt' && j > 0) result += "+".concat(val);else result += "".concat(key, "=").concat(val);
    });
    if (key === 'so') result += "".concat(key, "=").concat(bep53Range.compose(values));
  });
  return result;
}

/***/ }),

/***/ "./node_modules/mediasource/index.js":
/*!*******************************************!*\
  !*** ./node_modules/mediasource/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*! mediasource. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
module.exports = MediaElementWrapper;

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var stream = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js");

var toArrayBuffer = __webpack_require__(/*! to-arraybuffer */ "./node_modules/to-arraybuffer/index.js");

var MediaSource = typeof window !== 'undefined' && window.MediaSource;
var DEFAULT_BUFFER_DURATION = 60; // seconds

function MediaElementWrapper(elem, opts) {
  var self = this;
  if (!(self instanceof MediaElementWrapper)) return new MediaElementWrapper(elem, opts);
  if (!MediaSource) throw new Error('web browser lacks MediaSource support');
  if (!opts) opts = {};
  self._debug = opts.debug;
  self._bufferDuration = opts.bufferDuration || DEFAULT_BUFFER_DURATION;
  self._elem = elem;
  self._mediaSource = new MediaSource();
  self._streams = [];
  self.detailedError = null;

  self._errorHandler = function () {
    self._elem.removeEventListener('error', self._errorHandler);

    var streams = self._streams.slice();

    streams.forEach(function (stream) {
      stream.destroy(self._elem.error);
    });
  };

  self._elem.addEventListener('error', self._errorHandler);

  self._elem.src = window.URL.createObjectURL(self._mediaSource);
}
/*
 * `obj` can be a previous value returned by this function
 * or a string
 */


MediaElementWrapper.prototype.createWriteStream = function (obj) {
  var self = this;
  return new MediaSourceStream(self, obj);
};
/*
 * Use to trigger an error on the underlying media element
 */


MediaElementWrapper.prototype.error = function (err) {
  var self = this; // be careful not to overwrite any existing detailedError values

  if (!self.detailedError) {
    self.detailedError = err;
  }

  self._dumpDebugData();

  try {
    self._mediaSource.endOfStream('decode');
  } catch (err) {}

  try {
    // Attempt to clean up object URL
    window.URL.revokeObjectURL(self._elem.src);
  } catch (err) {}
};
/*
 * When self._debug is set, dump all data to files
 */


MediaElementWrapper.prototype._dumpDebugData = function () {
  var self = this;

  if (self._debug) {
    self._debug = false; // prevent multiple dumps on multiple errors

    self._streams.forEach(function (stream, i) {
      downloadBuffers(stream._debugBuffers, 'mediasource-stream-' + i);
    });
  }
};

inherits(MediaSourceStream, stream.Writable);

function MediaSourceStream(wrapper, obj) {
  var self = this;
  stream.Writable.call(self);
  self._wrapper = wrapper;
  self._elem = wrapper._elem;
  self._mediaSource = wrapper._mediaSource;
  self._allStreams = wrapper._streams;

  self._allStreams.push(self);

  self._bufferDuration = wrapper._bufferDuration;
  self._sourceBuffer = null;
  self._debugBuffers = [];

  self._openHandler = function () {
    self._onSourceOpen();
  };

  self._flowHandler = function () {
    self._flow();
  };

  self._errorHandler = function (err) {
    if (!self.destroyed) {
      self.emit('error', err);
    }
  };

  if (typeof obj === 'string') {
    self._type = obj; // Need to create a new sourceBuffer

    if (self._mediaSource.readyState === 'open') {
      self._createSourceBuffer();
    } else {
      self._mediaSource.addEventListener('sourceopen', self._openHandler);
    }
  } else if (obj._sourceBuffer === null) {
    obj.destroy();
    self._type = obj._type; // The old stream was created but hasn't finished initializing

    self._mediaSource.addEventListener('sourceopen', self._openHandler);
  } else if (obj._sourceBuffer) {
    obj.destroy();
    self._type = obj._type;
    self._sourceBuffer = obj._sourceBuffer; // Copy over the old sourceBuffer

    self._debugBuffers = obj._debugBuffers; // Copy over previous debug data

    self._sourceBuffer.addEventListener('updateend', self._flowHandler);

    self._sourceBuffer.addEventListener('error', self._errorHandler);
  } else {
    throw new Error('The argument to MediaElementWrapper.createWriteStream must be a string or a previous stream returned from that function');
  }

  self._elem.addEventListener('timeupdate', self._flowHandler);

  self.on('error', function (err) {
    self._wrapper.error(err);
  });
  self.on('finish', function () {
    if (self.destroyed) return;
    self._finished = true;

    if (self._allStreams.every(function (other) {
      return other._finished;
    })) {
      self._wrapper._dumpDebugData();

      try {
        self._mediaSource.endOfStream();
      } catch (err) {}
    }
  });
}

MediaSourceStream.prototype._onSourceOpen = function () {
  var self = this;
  if (self.destroyed) return;

  self._mediaSource.removeEventListener('sourceopen', self._openHandler);

  self._createSourceBuffer();
};

MediaSourceStream.prototype.destroy = function (err) {
  var self = this;
  if (self.destroyed) return;
  self.destroyed = true; // Remove from allStreams

  self._allStreams.splice(self._allStreams.indexOf(self), 1);

  self._mediaSource.removeEventListener('sourceopen', self._openHandler);

  self._elem.removeEventListener('timeupdate', self._flowHandler);

  if (self._sourceBuffer) {
    self._sourceBuffer.removeEventListener('updateend', self._flowHandler);

    self._sourceBuffer.removeEventListener('error', self._errorHandler);

    if (self._mediaSource.readyState === 'open') {
      self._sourceBuffer.abort();
    }
  }

  if (err) self.emit('error', err);
  self.emit('close');
};

MediaSourceStream.prototype._createSourceBuffer = function () {
  var self = this;
  if (self.destroyed) return;

  if (MediaSource.isTypeSupported(self._type)) {
    self._sourceBuffer = self._mediaSource.addSourceBuffer(self._type);

    self._sourceBuffer.addEventListener('updateend', self._flowHandler);

    self._sourceBuffer.addEventListener('error', self._errorHandler);

    if (self._cb) {
      var cb = self._cb;
      self._cb = null;
      cb();
    }
  } else {
    self.destroy(new Error('The provided type is not supported'));
  }
};

MediaSourceStream.prototype._write = function (chunk, encoding, cb) {
  var self = this;
  if (self.destroyed) return;

  if (!self._sourceBuffer) {
    self._cb = function (err) {
      if (err) return cb(err);

      self._write(chunk, encoding, cb);
    };

    return;
  }

  if (self._sourceBuffer.updating) {
    return cb(new Error('Cannot append buffer while source buffer updating'));
  }

  var arr = toArrayBuffer(chunk);

  if (self._wrapper._debug) {
    self._debugBuffers.push(arr);
  }

  try {
    self._sourceBuffer.appendBuffer(arr);
  } catch (err) {
    // appendBuffer can throw for a number of reasons, most notably when the data
    // being appended is invalid or if appendBuffer is called after another error
    // already occurred on the media element. In Chrome, there may be useful debugging
    // info in chrome://media-internals
    self.destroy(err);
    return;
  }

  self._cb = cb;
};

MediaSourceStream.prototype._flow = function () {
  var self = this;

  if (self.destroyed || !self._sourceBuffer || self._sourceBuffer.updating) {
    return;
  }

  if (self._mediaSource.readyState === 'open') {
    // check buffer size
    if (self._getBufferDuration() > self._bufferDuration) {
      return;
    }
  }

  if (self._cb) {
    var cb = self._cb;
    self._cb = null;
    cb();
  }
}; // TODO: if zero actually works in all browsers, remove the logic associated with this below


var EPSILON = 0;

MediaSourceStream.prototype._getBufferDuration = function () {
  var self = this;
  var buffered = self._sourceBuffer.buffered;
  var currentTime = self._elem.currentTime;
  var bufferEnd = -1; // end of the buffer
  // This is a little over complex because some browsers seem to separate the
  // buffered region into multiple sections with slight gaps.

  for (var i = 0; i < buffered.length; i++) {
    var start = buffered.start(i);
    var end = buffered.end(i) + EPSILON;

    if (start > currentTime) {
      // Reached past the joined buffer
      break;
    } else if (bufferEnd >= 0 || currentTime <= end) {
      // Found the start/continuation of the joined buffer
      bufferEnd = end;
    }
  }

  var bufferedTime = bufferEnd - currentTime;

  if (bufferedTime < 0) {
    bufferedTime = 0;
  }

  return bufferedTime;
};

function downloadBuffers(bufs, name) {
  var a = document.createElement('a');
  a.href = window.URL.createObjectURL(new window.Blob(bufs));
  a.download = name;
  a.click();
}

/***/ }),

/***/ "./node_modules/memory-chunk-store/index.js":
/*!**************************************************!*\
  !*** ./node_modules/memory-chunk-store/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = Storage;

const queueMicrotask = __webpack_require__(/*! queue-microtask */ "./node_modules/queue-microtask/index.js");

function Storage(chunkLength, opts) {
  if (!(this instanceof Storage)) return new Storage(chunkLength, opts);
  if (!opts) opts = {};
  this.chunkLength = Number(chunkLength);
  if (!this.chunkLength) throw new Error('First argument must be a chunk length');
  this.chunks = [];
  this.closed = false;
  this.length = Number(opts.length) || Infinity;

  if (this.length !== Infinity) {
    this.lastChunkLength = this.length % this.chunkLength || this.chunkLength;
    this.lastChunkIndex = Math.ceil(this.length / this.chunkLength) - 1;
  }
}

Storage.prototype.put = function (index, buf) {
  let cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
  if (this.closed) return queueMicrotask(() => cb(new Error('Storage is closed')));
  const isLastChunk = index === this.lastChunkIndex;

  if (isLastChunk && buf.length !== this.lastChunkLength) {
    return queueMicrotask(() => cb(new Error('Last chunk length must be ' + this.lastChunkLength)));
  }

  if (!isLastChunk && buf.length !== this.chunkLength) {
    return queueMicrotask(() => cb(new Error('Chunk length must be ' + this.chunkLength)));
  }

  this.chunks[index] = buf;
  queueMicrotask(() => cb(null));
};

Storage.prototype.get = function (index, opts) {
  let cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
  if (typeof opts === 'function') return this.get(index, null, opts);
  if (this.closed) return queueMicrotask(() => cb(new Error('Storage is closed')));
  let buf = this.chunks[index];

  if (!buf) {
    const err = new Error('Chunk not found');
    err.notFound = true;
    return queueMicrotask(() => cb(err));
  }

  if (!opts) opts = {};
  const offset = opts.offset || 0;
  const len = opts.length || buf.length - offset;

  if (offset !== 0 || len !== buf.length) {
    buf = buf.slice(offset, len + offset);
  }

  queueMicrotask(() => cb(null, buf));
};

Storage.prototype.close = Storage.prototype.destroy = function () {
  let cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};
  if (this.closed) return queueMicrotask(() => cb(new Error('Storage is closed')));
  this.closed = true;
  this.chunks = null;
  queueMicrotask(() => cb(null));
};

/***/ }),

/***/ "./node_modules/mime/Mime.js":
/*!***********************************!*\
  !*** ./node_modules/mime/Mime.js ***!
  \***********************************/
/***/ ((module) => {

"use strict";

/**
 * @param typeMap [Object] Map of MIME type -> Array[extensions]
 * @param ...
 */

function Mime() {
  this._types = Object.create(null);
  this._extensions = Object.create(null);

  for (let i = 0; i < arguments.length; i++) {
    this.define(arguments[i]);
  }

  this.define = this.define.bind(this);
  this.getType = this.getType.bind(this);
  this.getExtension = this.getExtension.bind(this);
}
/**
 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
 * to an array of extensions associated with the type.  The first extension is
 * used as the default extension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
 *
 * If a type declares an extension that has already been defined, an error will
 * be thrown.  To suppress this error and force the extension to be associated
 * with the new type, pass `force`=true.  Alternatively, you may prefix the
 * extension with "*" to map the type to extension, without mapping the
 * extension to the type.
 *
 * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});
 *
 *
 * @param map (Object) type definitions
 * @param force (Boolean) if true, force overriding of existing definitions
 */


Mime.prototype.define = function (typeMap, force) {
  for (let type in typeMap) {
    let extensions = typeMap[type].map(function (t) {
      return t.toLowerCase();
    });
    type = type.toLowerCase();

    for (let i = 0; i < extensions.length; i++) {
      const ext = extensions[i]; // '*' prefix = not the preferred type for this extension.  So fixup the
      // extension, and skip it.

      if (ext[0] === '*') {
        continue;
      }

      if (!force && ext in this._types) {
        throw new Error('Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".');
      }

      this._types[ext] = type;
    } // Use first extension as default


    if (force || !this._extensions[type]) {
      const ext = extensions[0];
      this._extensions[type] = ext[0] !== '*' ? ext : ext.substr(1);
    }
  }
};
/**
 * Lookup a mime type based on extension
 */


Mime.prototype.getType = function (path) {
  path = String(path);
  let last = path.replace(/^.*[/\\]/, '').toLowerCase();
  let ext = last.replace(/^.*\./, '').toLowerCase();
  let hasPath = last.length < path.length;
  let hasDot = ext.length < last.length - 1;
  return (hasDot || !hasPath) && this._types[ext] || null;
};
/**
 * Return file extension associated with a mime type
 */


Mime.prototype.getExtension = function (type) {
  type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
  return type && this._extensions[type.toLowerCase()] || null;
};

module.exports = Mime;

/***/ }),

/***/ "./node_modules/mime/index.js":
/*!************************************!*\
  !*** ./node_modules/mime/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Mime = __webpack_require__(/*! ./Mime */ "./node_modules/mime/Mime.js");

module.exports = new Mime(__webpack_require__(/*! ./types/standard */ "./node_modules/mime/types/standard.js"), __webpack_require__(/*! ./types/other */ "./node_modules/mime/types/other.js"));

/***/ }),

/***/ "./node_modules/mime/types/other.js":
/*!******************************************!*\
  !*** ./node_modules/mime/types/other.js ***!
  \******************************************/
/***/ ((module) => {

module.exports = {
  "application/prs.cww": ["cww"],
  "application/vnd.1000minds.decision-model+xml": ["1km"],
  "application/vnd.3gpp.pic-bw-large": ["plb"],
  "application/vnd.3gpp.pic-bw-small": ["psb"],
  "application/vnd.3gpp.pic-bw-var": ["pvb"],
  "application/vnd.3gpp2.tcap": ["tcap"],
  "application/vnd.3m.post-it-notes": ["pwn"],
  "application/vnd.accpac.simply.aso": ["aso"],
  "application/vnd.accpac.simply.imp": ["imp"],
  "application/vnd.acucobol": ["acu"],
  "application/vnd.acucorp": ["atc", "acutc"],
  "application/vnd.adobe.air-application-installer-package+zip": ["air"],
  "application/vnd.adobe.formscentral.fcdt": ["fcdt"],
  "application/vnd.adobe.fxp": ["fxp", "fxpl"],
  "application/vnd.adobe.xdp+xml": ["xdp"],
  "application/vnd.adobe.xfdf": ["xfdf"],
  "application/vnd.ahead.space": ["ahead"],
  "application/vnd.airzip.filesecure.azf": ["azf"],
  "application/vnd.airzip.filesecure.azs": ["azs"],
  "application/vnd.amazon.ebook": ["azw"],
  "application/vnd.americandynamics.acc": ["acc"],
  "application/vnd.amiga.ami": ["ami"],
  "application/vnd.android.package-archive": ["apk"],
  "application/vnd.anser-web-certificate-issue-initiation": ["cii"],
  "application/vnd.anser-web-funds-transfer-initiation": ["fti"],
  "application/vnd.antix.game-component": ["atx"],
  "application/vnd.apple.installer+xml": ["mpkg"],
  "application/vnd.apple.keynote": ["key"],
  "application/vnd.apple.mpegurl": ["m3u8"],
  "application/vnd.apple.numbers": ["numbers"],
  "application/vnd.apple.pages": ["pages"],
  "application/vnd.apple.pkpass": ["pkpass"],
  "application/vnd.aristanetworks.swi": ["swi"],
  "application/vnd.astraea-software.iota": ["iota"],
  "application/vnd.audiograph": ["aep"],
  "application/vnd.balsamiq.bmml+xml": ["bmml"],
  "application/vnd.blueice.multipass": ["mpm"],
  "application/vnd.bmi": ["bmi"],
  "application/vnd.businessobjects": ["rep"],
  "application/vnd.chemdraw+xml": ["cdxml"],
  "application/vnd.chipnuts.karaoke-mmd": ["mmd"],
  "application/vnd.cinderella": ["cdy"],
  "application/vnd.citationstyles.style+xml": ["csl"],
  "application/vnd.claymore": ["cla"],
  "application/vnd.cloanto.rp9": ["rp9"],
  "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"],
  "application/vnd.cluetrust.cartomobile-config": ["c11amc"],
  "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"],
  "application/vnd.commonspace": ["csp"],
  "application/vnd.contact.cmsg": ["cdbcmsg"],
  "application/vnd.cosmocaller": ["cmc"],
  "application/vnd.crick.clicker": ["clkx"],
  "application/vnd.crick.clicker.keyboard": ["clkk"],
  "application/vnd.crick.clicker.palette": ["clkp"],
  "application/vnd.crick.clicker.template": ["clkt"],
  "application/vnd.crick.clicker.wordbank": ["clkw"],
  "application/vnd.criticaltools.wbs+xml": ["wbs"],
  "application/vnd.ctc-posml": ["pml"],
  "application/vnd.cups-ppd": ["ppd"],
  "application/vnd.curl.car": ["car"],
  "application/vnd.curl.pcurl": ["pcurl"],
  "application/vnd.dart": ["dart"],
  "application/vnd.data-vision.rdz": ["rdz"],
  "application/vnd.dbf": ["dbf"],
  "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"],
  "application/vnd.dece.ttml+xml": ["uvt", "uvvt"],
  "application/vnd.dece.unspecified": ["uvx", "uvvx"],
  "application/vnd.dece.zip": ["uvz", "uvvz"],
  "application/vnd.denovo.fcselayout-link": ["fe_launch"],
  "application/vnd.dna": ["dna"],
  "application/vnd.dolby.mlp": ["mlp"],
  "application/vnd.dpgraph": ["dpg"],
  "application/vnd.dreamfactory": ["dfac"],
  "application/vnd.ds-keypoint": ["kpxx"],
  "application/vnd.dvb.ait": ["ait"],
  "application/vnd.dvb.service": ["svc"],
  "application/vnd.dynageo": ["geo"],
  "application/vnd.ecowin.chart": ["mag"],
  "application/vnd.enliven": ["nml"],
  "application/vnd.epson.esf": ["esf"],
  "application/vnd.epson.msf": ["msf"],
  "application/vnd.epson.quickanime": ["qam"],
  "application/vnd.epson.salt": ["slt"],
  "application/vnd.epson.ssf": ["ssf"],
  "application/vnd.eszigno3+xml": ["es3", "et3"],
  "application/vnd.ezpix-album": ["ez2"],
  "application/vnd.ezpix-package": ["ez3"],
  "application/vnd.fdf": ["fdf"],
  "application/vnd.fdsn.mseed": ["mseed"],
  "application/vnd.fdsn.seed": ["seed", "dataless"],
  "application/vnd.flographit": ["gph"],
  "application/vnd.fluxtime.clip": ["ftc"],
  "application/vnd.framemaker": ["fm", "frame", "maker", "book"],
  "application/vnd.frogans.fnc": ["fnc"],
  "application/vnd.frogans.ltf": ["ltf"],
  "application/vnd.fsc.weblaunch": ["fsc"],
  "application/vnd.fujitsu.oasys": ["oas"],
  "application/vnd.fujitsu.oasys2": ["oa2"],
  "application/vnd.fujitsu.oasys3": ["oa3"],
  "application/vnd.fujitsu.oasysgp": ["fg5"],
  "application/vnd.fujitsu.oasysprs": ["bh2"],
  "application/vnd.fujixerox.ddd": ["ddd"],
  "application/vnd.fujixerox.docuworks": ["xdw"],
  "application/vnd.fujixerox.docuworks.binder": ["xbd"],
  "application/vnd.fuzzysheet": ["fzs"],
  "application/vnd.genomatix.tuxedo": ["txd"],
  "application/vnd.geogebra.file": ["ggb"],
  "application/vnd.geogebra.tool": ["ggt"],
  "application/vnd.geometry-explorer": ["gex", "gre"],
  "application/vnd.geonext": ["gxt"],
  "application/vnd.geoplan": ["g2w"],
  "application/vnd.geospace": ["g3w"],
  "application/vnd.gmx": ["gmx"],
  "application/vnd.google-apps.document": ["gdoc"],
  "application/vnd.google-apps.presentation": ["gslides"],
  "application/vnd.google-apps.spreadsheet": ["gsheet"],
  "application/vnd.google-earth.kml+xml": ["kml"],
  "application/vnd.google-earth.kmz": ["kmz"],
  "application/vnd.grafeq": ["gqf", "gqs"],
  "application/vnd.groove-account": ["gac"],
  "application/vnd.groove-help": ["ghf"],
  "application/vnd.groove-identity-message": ["gim"],
  "application/vnd.groove-injector": ["grv"],
  "application/vnd.groove-tool-message": ["gtm"],
  "application/vnd.groove-tool-template": ["tpl"],
  "application/vnd.groove-vcard": ["vcg"],
  "application/vnd.hal+xml": ["hal"],
  "application/vnd.handheld-entertainment+xml": ["zmm"],
  "application/vnd.hbci": ["hbci"],
  "application/vnd.hhe.lesson-player": ["les"],
  "application/vnd.hp-hpgl": ["hpgl"],
  "application/vnd.hp-hpid": ["hpid"],
  "application/vnd.hp-hps": ["hps"],
  "application/vnd.hp-jlyt": ["jlt"],
  "application/vnd.hp-pcl": ["pcl"],
  "application/vnd.hp-pclxl": ["pclxl"],
  "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"],
  "application/vnd.ibm.minipay": ["mpy"],
  "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"],
  "application/vnd.ibm.rights-management": ["irm"],
  "application/vnd.ibm.secure-container": ["sc"],
  "application/vnd.iccprofile": ["icc", "icm"],
  "application/vnd.igloader": ["igl"],
  "application/vnd.immervision-ivp": ["ivp"],
  "application/vnd.immervision-ivu": ["ivu"],
  "application/vnd.insors.igm": ["igm"],
  "application/vnd.intercon.formnet": ["xpw", "xpx"],
  "application/vnd.intergeo": ["i2g"],
  "application/vnd.intu.qbo": ["qbo"],
  "application/vnd.intu.qfx": ["qfx"],
  "application/vnd.ipunplugged.rcprofile": ["rcprofile"],
  "application/vnd.irepository.package+xml": ["irp"],
  "application/vnd.is-xpr": ["xpr"],
  "application/vnd.isac.fcs": ["fcs"],
  "application/vnd.jam": ["jam"],
  "application/vnd.jcp.javame.midlet-rms": ["rms"],
  "application/vnd.jisp": ["jisp"],
  "application/vnd.joost.joda-archive": ["joda"],
  "application/vnd.kahootz": ["ktz", "ktr"],
  "application/vnd.kde.karbon": ["karbon"],
  "application/vnd.kde.kchart": ["chrt"],
  "application/vnd.kde.kformula": ["kfo"],
  "application/vnd.kde.kivio": ["flw"],
  "application/vnd.kde.kontour": ["kon"],
  "application/vnd.kde.kpresenter": ["kpr", "kpt"],
  "application/vnd.kde.kspread": ["ksp"],
  "application/vnd.kde.kword": ["kwd", "kwt"],
  "application/vnd.kenameaapp": ["htke"],
  "application/vnd.kidspiration": ["kia"],
  "application/vnd.kinar": ["kne", "knp"],
  "application/vnd.koan": ["skp", "skd", "skt", "skm"],
  "application/vnd.kodak-descriptor": ["sse"],
  "application/vnd.las.las+xml": ["lasxml"],
  "application/vnd.llamagraphics.life-balance.desktop": ["lbd"],
  "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"],
  "application/vnd.lotus-1-2-3": ["123"],
  "application/vnd.lotus-approach": ["apr"],
  "application/vnd.lotus-freelance": ["pre"],
  "application/vnd.lotus-notes": ["nsf"],
  "application/vnd.lotus-organizer": ["org"],
  "application/vnd.lotus-screencam": ["scm"],
  "application/vnd.lotus-wordpro": ["lwp"],
  "application/vnd.macports.portpkg": ["portpkg"],
  "application/vnd.mapbox-vector-tile": ["mvt"],
  "application/vnd.mcd": ["mcd"],
  "application/vnd.medcalcdata": ["mc1"],
  "application/vnd.mediastation.cdkey": ["cdkey"],
  "application/vnd.mfer": ["mwf"],
  "application/vnd.mfmp": ["mfm"],
  "application/vnd.micrografx.flo": ["flo"],
  "application/vnd.micrografx.igx": ["igx"],
  "application/vnd.mif": ["mif"],
  "application/vnd.mobius.daf": ["daf"],
  "application/vnd.mobius.dis": ["dis"],
  "application/vnd.mobius.mbk": ["mbk"],
  "application/vnd.mobius.mqy": ["mqy"],
  "application/vnd.mobius.msl": ["msl"],
  "application/vnd.mobius.plc": ["plc"],
  "application/vnd.mobius.txf": ["txf"],
  "application/vnd.mophun.application": ["mpn"],
  "application/vnd.mophun.certificate": ["mpc"],
  "application/vnd.mozilla.xul+xml": ["xul"],
  "application/vnd.ms-artgalry": ["cil"],
  "application/vnd.ms-cab-compressed": ["cab"],
  "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"],
  "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"],
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"],
  "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"],
  "application/vnd.ms-excel.template.macroenabled.12": ["xltm"],
  "application/vnd.ms-fontobject": ["eot"],
  "application/vnd.ms-htmlhelp": ["chm"],
  "application/vnd.ms-ims": ["ims"],
  "application/vnd.ms-lrm": ["lrm"],
  "application/vnd.ms-officetheme": ["thmx"],
  "application/vnd.ms-outlook": ["msg"],
  "application/vnd.ms-pki.seccat": ["cat"],
  "application/vnd.ms-pki.stl": ["*stl"],
  "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"],
  "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"],
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"],
  "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"],
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"],
  "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"],
  "application/vnd.ms-project": ["mpp", "mpt"],
  "application/vnd.ms-word.document.macroenabled.12": ["docm"],
  "application/vnd.ms-word.template.macroenabled.12": ["dotm"],
  "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"],
  "application/vnd.ms-wpl": ["wpl"],
  "application/vnd.ms-xpsdocument": ["xps"],
  "application/vnd.mseq": ["mseq"],
  "application/vnd.musician": ["mus"],
  "application/vnd.muvee.style": ["msty"],
  "application/vnd.mynfc": ["taglet"],
  "application/vnd.neurolanguage.nlu": ["nlu"],
  "application/vnd.nitf": ["ntf", "nitf"],
  "application/vnd.noblenet-directory": ["nnd"],
  "application/vnd.noblenet-sealer": ["nns"],
  "application/vnd.noblenet-web": ["nnw"],
  "application/vnd.nokia.n-gage.ac+xml": ["*ac"],
  "application/vnd.nokia.n-gage.data": ["ngdat"],
  "application/vnd.nokia.n-gage.symbian.install": ["n-gage"],
  "application/vnd.nokia.radio-preset": ["rpst"],
  "application/vnd.nokia.radio-presets": ["rpss"],
  "application/vnd.novadigm.edm": ["edm"],
  "application/vnd.novadigm.edx": ["edx"],
  "application/vnd.novadigm.ext": ["ext"],
  "application/vnd.oasis.opendocument.chart": ["odc"],
  "application/vnd.oasis.opendocument.chart-template": ["otc"],
  "application/vnd.oasis.opendocument.database": ["odb"],
  "application/vnd.oasis.opendocument.formula": ["odf"],
  "application/vnd.oasis.opendocument.formula-template": ["odft"],
  "application/vnd.oasis.opendocument.graphics": ["odg"],
  "application/vnd.oasis.opendocument.graphics-template": ["otg"],
  "application/vnd.oasis.opendocument.image": ["odi"],
  "application/vnd.oasis.opendocument.image-template": ["oti"],
  "application/vnd.oasis.opendocument.presentation": ["odp"],
  "application/vnd.oasis.opendocument.presentation-template": ["otp"],
  "application/vnd.oasis.opendocument.spreadsheet": ["ods"],
  "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"],
  "application/vnd.oasis.opendocument.text": ["odt"],
  "application/vnd.oasis.opendocument.text-master": ["odm"],
  "application/vnd.oasis.opendocument.text-template": ["ott"],
  "application/vnd.oasis.opendocument.text-web": ["oth"],
  "application/vnd.olpc-sugar": ["xo"],
  "application/vnd.oma.dd2+xml": ["dd2"],
  "application/vnd.openblox.game+xml": ["obgx"],
  "application/vnd.openofficeorg.extension": ["oxt"],
  "application/vnd.openstreetmap.data+xml": ["osm"],
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"],
  "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"],
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"],
  "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"],
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"],
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"],
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"],
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"],
  "application/vnd.osgeo.mapguide.package": ["mgp"],
  "application/vnd.osgi.dp": ["dp"],
  "application/vnd.osgi.subsystem": ["esa"],
  "application/vnd.palm": ["pdb", "pqa", "oprc"],
  "application/vnd.pawaafile": ["paw"],
  "application/vnd.pg.format": ["str"],
  "application/vnd.pg.osasli": ["ei6"],
  "application/vnd.picsel": ["efif"],
  "application/vnd.pmi.widget": ["wg"],
  "application/vnd.pocketlearn": ["plf"],
  "application/vnd.powerbuilder6": ["pbd"],
  "application/vnd.previewsystems.box": ["box"],
  "application/vnd.proteus.magazine": ["mgz"],
  "application/vnd.publishare-delta-tree": ["qps"],
  "application/vnd.pvi.ptid1": ["ptid"],
  "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"],
  "application/vnd.rar": ["rar"],
  "application/vnd.realvnc.bed": ["bed"],
  "application/vnd.recordare.musicxml": ["mxl"],
  "application/vnd.recordare.musicxml+xml": ["musicxml"],
  "application/vnd.rig.cryptonote": ["cryptonote"],
  "application/vnd.rim.cod": ["cod"],
  "application/vnd.rn-realmedia": ["rm"],
  "application/vnd.rn-realmedia-vbr": ["rmvb"],
  "application/vnd.route66.link66+xml": ["link66"],
  "application/vnd.sailingtracker.track": ["st"],
  "application/vnd.seemail": ["see"],
  "application/vnd.sema": ["sema"],
  "application/vnd.semd": ["semd"],
  "application/vnd.semf": ["semf"],
  "application/vnd.shana.informed.formdata": ["ifm"],
  "application/vnd.shana.informed.formtemplate": ["itp"],
  "application/vnd.shana.informed.interchange": ["iif"],
  "application/vnd.shana.informed.package": ["ipk"],
  "application/vnd.simtech-mindmapper": ["twd", "twds"],
  "application/vnd.smaf": ["mmf"],
  "application/vnd.smart.teacher": ["teacher"],
  "application/vnd.software602.filler.form+xml": ["fo"],
  "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"],
  "application/vnd.spotfire.dxp": ["dxp"],
  "application/vnd.spotfire.sfs": ["sfs"],
  "application/vnd.stardivision.calc": ["sdc"],
  "application/vnd.stardivision.draw": ["sda"],
  "application/vnd.stardivision.impress": ["sdd"],
  "application/vnd.stardivision.math": ["smf"],
  "application/vnd.stardivision.writer": ["sdw", "vor"],
  "application/vnd.stardivision.writer-global": ["sgl"],
  "application/vnd.stepmania.package": ["smzip"],
  "application/vnd.stepmania.stepchart": ["sm"],
  "application/vnd.sun.wadl+xml": ["wadl"],
  "application/vnd.sun.xml.calc": ["sxc"],
  "application/vnd.sun.xml.calc.template": ["stc"],
  "application/vnd.sun.xml.draw": ["sxd"],
  "application/vnd.sun.xml.draw.template": ["std"],
  "application/vnd.sun.xml.impress": ["sxi"],
  "application/vnd.sun.xml.impress.template": ["sti"],
  "application/vnd.sun.xml.math": ["sxm"],
  "application/vnd.sun.xml.writer": ["sxw"],
  "application/vnd.sun.xml.writer.global": ["sxg"],
  "application/vnd.sun.xml.writer.template": ["stw"],
  "application/vnd.sus-calendar": ["sus", "susp"],
  "application/vnd.svd": ["svd"],
  "application/vnd.symbian.install": ["sis", "sisx"],
  "application/vnd.syncml+xml": ["xsm"],
  "application/vnd.syncml.dm+wbxml": ["bdm"],
  "application/vnd.syncml.dm+xml": ["xdm"],
  "application/vnd.syncml.dmddf+xml": ["ddf"],
  "application/vnd.tao.intent-module-archive": ["tao"],
  "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"],
  "application/vnd.tmobile-livetv": ["tmo"],
  "application/vnd.trid.tpt": ["tpt"],
  "application/vnd.triscape.mxs": ["mxs"],
  "application/vnd.trueapp": ["tra"],
  "application/vnd.ufdl": ["ufd", "ufdl"],
  "application/vnd.uiq.theme": ["utz"],
  "application/vnd.umajin": ["umj"],
  "application/vnd.unity": ["unityweb"],
  "application/vnd.uoml+xml": ["uoml"],
  "application/vnd.vcx": ["vcx"],
  "application/vnd.visio": ["vsd", "vst", "vss", "vsw"],
  "application/vnd.visionary": ["vis"],
  "application/vnd.vsf": ["vsf"],
  "application/vnd.wap.wbxml": ["wbxml"],
  "application/vnd.wap.wmlc": ["wmlc"],
  "application/vnd.wap.wmlscriptc": ["wmlsc"],
  "application/vnd.webturbo": ["wtb"],
  "application/vnd.wolfram.player": ["nbp"],
  "application/vnd.wordperfect": ["wpd"],
  "application/vnd.wqd": ["wqd"],
  "application/vnd.wt.stf": ["stf"],
  "application/vnd.xara": ["xar"],
  "application/vnd.xfdl": ["xfdl"],
  "application/vnd.yamaha.hv-dic": ["hvd"],
  "application/vnd.yamaha.hv-script": ["hvs"],
  "application/vnd.yamaha.hv-voice": ["hvp"],
  "application/vnd.yamaha.openscoreformat": ["osf"],
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"],
  "application/vnd.yamaha.smaf-audio": ["saf"],
  "application/vnd.yamaha.smaf-phrase": ["spf"],
  "application/vnd.yellowriver-custom-menu": ["cmp"],
  "application/vnd.zul": ["zir", "zirz"],
  "application/vnd.zzazz.deck+xml": ["zaz"],
  "application/x-7z-compressed": ["7z"],
  "application/x-abiword": ["abw"],
  "application/x-ace-compressed": ["ace"],
  "application/x-apple-diskimage": ["*dmg"],
  "application/x-arj": ["arj"],
  "application/x-authorware-bin": ["aab", "x32", "u32", "vox"],
  "application/x-authorware-map": ["aam"],
  "application/x-authorware-seg": ["aas"],
  "application/x-bcpio": ["bcpio"],
  "application/x-bdoc": ["*bdoc"],
  "application/x-bittorrent": ["torrent"],
  "application/x-blorb": ["blb", "blorb"],
  "application/x-bzip": ["bz"],
  "application/x-bzip2": ["bz2", "boz"],
  "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"],
  "application/x-cdlink": ["vcd"],
  "application/x-cfs-compressed": ["cfs"],
  "application/x-chat": ["chat"],
  "application/x-chess-pgn": ["pgn"],
  "application/x-chrome-extension": ["crx"],
  "application/x-cocoa": ["cco"],
  "application/x-conference": ["nsc"],
  "application/x-cpio": ["cpio"],
  "application/x-csh": ["csh"],
  "application/x-debian-package": ["*deb", "udeb"],
  "application/x-dgc-compressed": ["dgc"],
  "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"],
  "application/x-doom": ["wad"],
  "application/x-dtbncx+xml": ["ncx"],
  "application/x-dtbook+xml": ["dtb"],
  "application/x-dtbresource+xml": ["res"],
  "application/x-dvi": ["dvi"],
  "application/x-envoy": ["evy"],
  "application/x-eva": ["eva"],
  "application/x-font-bdf": ["bdf"],
  "application/x-font-ghostscript": ["gsf"],
  "application/x-font-linux-psf": ["psf"],
  "application/x-font-pcf": ["pcf"],
  "application/x-font-snf": ["snf"],
  "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"],
  "application/x-freearc": ["arc"],
  "application/x-futuresplash": ["spl"],
  "application/x-gca-compressed": ["gca"],
  "application/x-glulx": ["ulx"],
  "application/x-gnumeric": ["gnumeric"],
  "application/x-gramps-xml": ["gramps"],
  "application/x-gtar": ["gtar"],
  "application/x-hdf": ["hdf"],
  "application/x-httpd-php": ["php"],
  "application/x-install-instructions": ["install"],
  "application/x-iso9660-image": ["*iso"],
  "application/x-iwork-keynote-sffkey": ["*key"],
  "application/x-iwork-numbers-sffnumbers": ["*numbers"],
  "application/x-iwork-pages-sffpages": ["*pages"],
  "application/x-java-archive-diff": ["jardiff"],
  "application/x-java-jnlp-file": ["jnlp"],
  "application/x-keepass2": ["kdbx"],
  "application/x-latex": ["latex"],
  "application/x-lua-bytecode": ["luac"],
  "application/x-lzh-compressed": ["lzh", "lha"],
  "application/x-makeself": ["run"],
  "application/x-mie": ["mie"],
  "application/x-mobipocket-ebook": ["prc", "mobi"],
  "application/x-ms-application": ["application"],
  "application/x-ms-shortcut": ["lnk"],
  "application/x-ms-wmd": ["wmd"],
  "application/x-ms-wmz": ["wmz"],
  "application/x-ms-xbap": ["xbap"],
  "application/x-msaccess": ["mdb"],
  "application/x-msbinder": ["obd"],
  "application/x-mscardfile": ["crd"],
  "application/x-msclip": ["clp"],
  "application/x-msdos-program": ["*exe"],
  "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"],
  "application/x-msmediaview": ["mvb", "m13", "m14"],
  "application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"],
  "application/x-msmoney": ["mny"],
  "application/x-mspublisher": ["pub"],
  "application/x-msschedule": ["scd"],
  "application/x-msterminal": ["trm"],
  "application/x-mswrite": ["wri"],
  "application/x-netcdf": ["nc", "cdf"],
  "application/x-ns-proxy-autoconfig": ["pac"],
  "application/x-nzb": ["nzb"],
  "application/x-perl": ["pl", "pm"],
  "application/x-pilot": ["*prc", "*pdb"],
  "application/x-pkcs12": ["p12", "pfx"],
  "application/x-pkcs7-certificates": ["p7b", "spc"],
  "application/x-pkcs7-certreqresp": ["p7r"],
  "application/x-rar-compressed": ["*rar"],
  "application/x-redhat-package-manager": ["rpm"],
  "application/x-research-info-systems": ["ris"],
  "application/x-sea": ["sea"],
  "application/x-sh": ["sh"],
  "application/x-shar": ["shar"],
  "application/x-shockwave-flash": ["swf"],
  "application/x-silverlight-app": ["xap"],
  "application/x-sql": ["sql"],
  "application/x-stuffit": ["sit"],
  "application/x-stuffitx": ["sitx"],
  "application/x-subrip": ["srt"],
  "application/x-sv4cpio": ["sv4cpio"],
  "application/x-sv4crc": ["sv4crc"],
  "application/x-t3vm-image": ["t3"],
  "application/x-tads": ["gam"],
  "application/x-tar": ["tar"],
  "application/x-tcl": ["tcl", "tk"],
  "application/x-tex": ["tex"],
  "application/x-tex-tfm": ["tfm"],
  "application/x-texinfo": ["texinfo", "texi"],
  "application/x-tgif": ["*obj"],
  "application/x-ustar": ["ustar"],
  "application/x-virtualbox-hdd": ["hdd"],
  "application/x-virtualbox-ova": ["ova"],
  "application/x-virtualbox-ovf": ["ovf"],
  "application/x-virtualbox-vbox": ["vbox"],
  "application/x-virtualbox-vbox-extpack": ["vbox-extpack"],
  "application/x-virtualbox-vdi": ["vdi"],
  "application/x-virtualbox-vhd": ["vhd"],
  "application/x-virtualbox-vmdk": ["vmdk"],
  "application/x-wais-source": ["src"],
  "application/x-web-app-manifest+json": ["webapp"],
  "application/x-x509-ca-cert": ["der", "crt", "pem"],
  "application/x-xfig": ["fig"],
  "application/x-xliff+xml": ["*xlf"],
  "application/x-xpinstall": ["xpi"],
  "application/x-xz": ["xz"],
  "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"],
  "audio/vnd.dece.audio": ["uva", "uvva"],
  "audio/vnd.digital-winds": ["eol"],
  "audio/vnd.dra": ["dra"],
  "audio/vnd.dts": ["dts"],
  "audio/vnd.dts.hd": ["dtshd"],
  "audio/vnd.lucent.voice": ["lvp"],
  "audio/vnd.ms-playready.media.pya": ["pya"],
  "audio/vnd.nuera.ecelp4800": ["ecelp4800"],
  "audio/vnd.nuera.ecelp7470": ["ecelp7470"],
  "audio/vnd.nuera.ecelp9600": ["ecelp9600"],
  "audio/vnd.rip": ["rip"],
  "audio/x-aac": ["aac"],
  "audio/x-aiff": ["aif", "aiff", "aifc"],
  "audio/x-caf": ["caf"],
  "audio/x-flac": ["flac"],
  "audio/x-m4a": ["*m4a"],
  "audio/x-matroska": ["mka"],
  "audio/x-mpegurl": ["m3u"],
  "audio/x-ms-wax": ["wax"],
  "audio/x-ms-wma": ["wma"],
  "audio/x-pn-realaudio": ["ram", "ra"],
  "audio/x-pn-realaudio-plugin": ["rmp"],
  "audio/x-realaudio": ["*ra"],
  "audio/x-wav": ["*wav"],
  "chemical/x-cdx": ["cdx"],
  "chemical/x-cif": ["cif"],
  "chemical/x-cmdf": ["cmdf"],
  "chemical/x-cml": ["cml"],
  "chemical/x-csml": ["csml"],
  "chemical/x-xyz": ["xyz"],
  "image/prs.btif": ["btif"],
  "image/prs.pti": ["pti"],
  "image/vnd.adobe.photoshop": ["psd"],
  "image/vnd.airzip.accelerator.azv": ["azv"],
  "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"],
  "image/vnd.djvu": ["djvu", "djv"],
  "image/vnd.dvb.subtitle": ["*sub"],
  "image/vnd.dwg": ["dwg"],
  "image/vnd.dxf": ["dxf"],
  "image/vnd.fastbidsheet": ["fbs"],
  "image/vnd.fpx": ["fpx"],
  "image/vnd.fst": ["fst"],
  "image/vnd.fujixerox.edmics-mmr": ["mmr"],
  "image/vnd.fujixerox.edmics-rlc": ["rlc"],
  "image/vnd.microsoft.icon": ["ico"],
  "image/vnd.ms-dds": ["dds"],
  "image/vnd.ms-modi": ["mdi"],
  "image/vnd.ms-photo": ["wdp"],
  "image/vnd.net-fpx": ["npx"],
  "image/vnd.pco.b16": ["b16"],
  "image/vnd.tencent.tap": ["tap"],
  "image/vnd.valve.source.texture": ["vtf"],
  "image/vnd.wap.wbmp": ["wbmp"],
  "image/vnd.xiff": ["xif"],
  "image/vnd.zbrush.pcx": ["pcx"],
  "image/x-3ds": ["3ds"],
  "image/x-cmu-raster": ["ras"],
  "image/x-cmx": ["cmx"],
  "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"],
  "image/x-icon": ["*ico"],
  "image/x-jng": ["jng"],
  "image/x-mrsid-image": ["sid"],
  "image/x-ms-bmp": ["*bmp"],
  "image/x-pcx": ["*pcx"],
  "image/x-pict": ["pic", "pct"],
  "image/x-portable-anymap": ["pnm"],
  "image/x-portable-bitmap": ["pbm"],
  "image/x-portable-graymap": ["pgm"],
  "image/x-portable-pixmap": ["ppm"],
  "image/x-rgb": ["rgb"],
  "image/x-tga": ["tga"],
  "image/x-xbitmap": ["xbm"],
  "image/x-xpixmap": ["xpm"],
  "image/x-xwindowdump": ["xwd"],
  "message/vnd.wfa.wsc": ["wsc"],
  "model/vnd.collada+xml": ["dae"],
  "model/vnd.dwf": ["dwf"],
  "model/vnd.gdl": ["gdl"],
  "model/vnd.gtw": ["gtw"],
  "model/vnd.mts": ["mts"],
  "model/vnd.opengex": ["ogex"],
  "model/vnd.parasolid.transmit.binary": ["x_b"],
  "model/vnd.parasolid.transmit.text": ["x_t"],
  "model/vnd.sap.vds": ["vds"],
  "model/vnd.usdz+zip": ["usdz"],
  "model/vnd.valve.source.compiled-map": ["bsp"],
  "model/vnd.vtu": ["vtu"],
  "text/prs.lines.tag": ["dsc"],
  "text/vnd.curl": ["curl"],
  "text/vnd.curl.dcurl": ["dcurl"],
  "text/vnd.curl.mcurl": ["mcurl"],
  "text/vnd.curl.scurl": ["scurl"],
  "text/vnd.dvb.subtitle": ["sub"],
  "text/vnd.fly": ["fly"],
  "text/vnd.fmi.flexstor": ["flx"],
  "text/vnd.graphviz": ["gv"],
  "text/vnd.in3d.3dml": ["3dml"],
  "text/vnd.in3d.spot": ["spot"],
  "text/vnd.sun.j2me.app-descriptor": ["jad"],
  "text/vnd.wap.wml": ["wml"],
  "text/vnd.wap.wmlscript": ["wmls"],
  "text/x-asm": ["s", "asm"],
  "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"],
  "text/x-component": ["htc"],
  "text/x-fortran": ["f", "for", "f77", "f90"],
  "text/x-handlebars-template": ["hbs"],
  "text/x-java-source": ["java"],
  "text/x-lua": ["lua"],
  "text/x-markdown": ["mkd"],
  "text/x-nfo": ["nfo"],
  "text/x-opml": ["opml"],
  "text/x-org": ["*org"],
  "text/x-pascal": ["p", "pas"],
  "text/x-processing": ["pde"],
  "text/x-sass": ["sass"],
  "text/x-scss": ["scss"],
  "text/x-setext": ["etx"],
  "text/x-sfv": ["sfv"],
  "text/x-suse-ymp": ["ymp"],
  "text/x-uuencode": ["uu"],
  "text/x-vcalendar": ["vcs"],
  "text/x-vcard": ["vcf"],
  "video/vnd.dece.hd": ["uvh", "uvvh"],
  "video/vnd.dece.mobile": ["uvm", "uvvm"],
  "video/vnd.dece.pd": ["uvp", "uvvp"],
  "video/vnd.dece.sd": ["uvs", "uvvs"],
  "video/vnd.dece.video": ["uvv", "uvvv"],
  "video/vnd.dvb.file": ["dvb"],
  "video/vnd.fvt": ["fvt"],
  "video/vnd.mpegurl": ["mxu", "m4u"],
  "video/vnd.ms-playready.media.pyv": ["pyv"],
  "video/vnd.uvvu.mp4": ["uvu", "uvvu"],
  "video/vnd.vivo": ["viv"],
  "video/x-f4v": ["f4v"],
  "video/x-fli": ["fli"],
  "video/x-flv": ["flv"],
  "video/x-m4v": ["m4v"],
  "video/x-matroska": ["mkv", "mk3d", "mks"],
  "video/x-mng": ["mng"],
  "video/x-ms-asf": ["asf", "asx"],
  "video/x-ms-vob": ["vob"],
  "video/x-ms-wm": ["wm"],
  "video/x-ms-wmv": ["wmv"],
  "video/x-ms-wmx": ["wmx"],
  "video/x-ms-wvx": ["wvx"],
  "video/x-msvideo": ["avi"],
  "video/x-sgi-movie": ["movie"],
  "video/x-smv": ["smv"],
  "x-conference/x-cooltalk": ["ice"]
};

/***/ }),

/***/ "./node_modules/mime/types/standard.js":
/*!*********************************************!*\
  !*** ./node_modules/mime/types/standard.js ***!
  \*********************************************/
/***/ ((module) => {

module.exports = {
  "application/andrew-inset": ["ez"],
  "application/applixware": ["aw"],
  "application/atom+xml": ["atom"],
  "application/atomcat+xml": ["atomcat"],
  "application/atomdeleted+xml": ["atomdeleted"],
  "application/atomsvc+xml": ["atomsvc"],
  "application/atsc-dwd+xml": ["dwd"],
  "application/atsc-held+xml": ["held"],
  "application/atsc-rsat+xml": ["rsat"],
  "application/bdoc": ["bdoc"],
  "application/calendar+xml": ["xcs"],
  "application/ccxml+xml": ["ccxml"],
  "application/cdfx+xml": ["cdfx"],
  "application/cdmi-capability": ["cdmia"],
  "application/cdmi-container": ["cdmic"],
  "application/cdmi-domain": ["cdmid"],
  "application/cdmi-object": ["cdmio"],
  "application/cdmi-queue": ["cdmiq"],
  "application/cu-seeme": ["cu"],
  "application/dash+xml": ["mpd"],
  "application/davmount+xml": ["davmount"],
  "application/docbook+xml": ["dbk"],
  "application/dssc+der": ["dssc"],
  "application/dssc+xml": ["xdssc"],
  "application/ecmascript": ["es", "ecma"],
  "application/emma+xml": ["emma"],
  "application/emotionml+xml": ["emotionml"],
  "application/epub+zip": ["epub"],
  "application/exi": ["exi"],
  "application/express": ["exp"],
  "application/fdt+xml": ["fdt"],
  "application/font-tdpfr": ["pfr"],
  "application/geo+json": ["geojson"],
  "application/gml+xml": ["gml"],
  "application/gpx+xml": ["gpx"],
  "application/gxf": ["gxf"],
  "application/gzip": ["gz"],
  "application/hjson": ["hjson"],
  "application/hyperstudio": ["stk"],
  "application/inkml+xml": ["ink", "inkml"],
  "application/ipfix": ["ipfix"],
  "application/its+xml": ["its"],
  "application/java-archive": ["jar", "war", "ear"],
  "application/java-serialized-object": ["ser"],
  "application/java-vm": ["class"],
  "application/javascript": ["js", "mjs"],
  "application/json": ["json", "map"],
  "application/json5": ["json5"],
  "application/jsonml+json": ["jsonml"],
  "application/ld+json": ["jsonld"],
  "application/lgr+xml": ["lgr"],
  "application/lost+xml": ["lostxml"],
  "application/mac-binhex40": ["hqx"],
  "application/mac-compactpro": ["cpt"],
  "application/mads+xml": ["mads"],
  "application/manifest+json": ["webmanifest"],
  "application/marc": ["mrc"],
  "application/marcxml+xml": ["mrcx"],
  "application/mathematica": ["ma", "nb", "mb"],
  "application/mathml+xml": ["mathml"],
  "application/mbox": ["mbox"],
  "application/mediaservercontrol+xml": ["mscml"],
  "application/metalink+xml": ["metalink"],
  "application/metalink4+xml": ["meta4"],
  "application/mets+xml": ["mets"],
  "application/mmt-aei+xml": ["maei"],
  "application/mmt-usd+xml": ["musd"],
  "application/mods+xml": ["mods"],
  "application/mp21": ["m21", "mp21"],
  "application/mp4": ["mp4s", "m4p"],
  "application/msword": ["doc", "dot"],
  "application/mxf": ["mxf"],
  "application/n-quads": ["nq"],
  "application/n-triples": ["nt"],
  "application/node": ["cjs"],
  "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"],
  "application/oda": ["oda"],
  "application/oebps-package+xml": ["opf"],
  "application/ogg": ["ogx"],
  "application/omdoc+xml": ["omdoc"],
  "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"],
  "application/oxps": ["oxps"],
  "application/p2p-overlay+xml": ["relo"],
  "application/patch-ops-error+xml": ["xer"],
  "application/pdf": ["pdf"],
  "application/pgp-encrypted": ["pgp"],
  "application/pgp-signature": ["asc", "sig"],
  "application/pics-rules": ["prf"],
  "application/pkcs10": ["p10"],
  "application/pkcs7-mime": ["p7m", "p7c"],
  "application/pkcs7-signature": ["p7s"],
  "application/pkcs8": ["p8"],
  "application/pkix-attr-cert": ["ac"],
  "application/pkix-cert": ["cer"],
  "application/pkix-crl": ["crl"],
  "application/pkix-pkipath": ["pkipath"],
  "application/pkixcmp": ["pki"],
  "application/pls+xml": ["pls"],
  "application/postscript": ["ai", "eps", "ps"],
  "application/provenance+xml": ["provx"],
  "application/pskc+xml": ["pskcxml"],
  "application/raml+yaml": ["raml"],
  "application/rdf+xml": ["rdf", "owl"],
  "application/reginfo+xml": ["rif"],
  "application/relax-ng-compact-syntax": ["rnc"],
  "application/resource-lists+xml": ["rl"],
  "application/resource-lists-diff+xml": ["rld"],
  "application/rls-services+xml": ["rs"],
  "application/route-apd+xml": ["rapd"],
  "application/route-s-tsid+xml": ["sls"],
  "application/route-usd+xml": ["rusd"],
  "application/rpki-ghostbusters": ["gbr"],
  "application/rpki-manifest": ["mft"],
  "application/rpki-roa": ["roa"],
  "application/rsd+xml": ["rsd"],
  "application/rss+xml": ["rss"],
  "application/rtf": ["rtf"],
  "application/sbml+xml": ["sbml"],
  "application/scvp-cv-request": ["scq"],
  "application/scvp-cv-response": ["scs"],
  "application/scvp-vp-request": ["spq"],
  "application/scvp-vp-response": ["spp"],
  "application/sdp": ["sdp"],
  "application/senml+xml": ["senmlx"],
  "application/sensml+xml": ["sensmlx"],
  "application/set-payment-initiation": ["setpay"],
  "application/set-registration-initiation": ["setreg"],
  "application/shf+xml": ["shf"],
  "application/sieve": ["siv", "sieve"],
  "application/smil+xml": ["smi", "smil"],
  "application/sparql-query": ["rq"],
  "application/sparql-results+xml": ["srx"],
  "application/srgs": ["gram"],
  "application/srgs+xml": ["grxml"],
  "application/sru+xml": ["sru"],
  "application/ssdl+xml": ["ssdl"],
  "application/ssml+xml": ["ssml"],
  "application/swid+xml": ["swidtag"],
  "application/tei+xml": ["tei", "teicorpus"],
  "application/thraud+xml": ["tfi"],
  "application/timestamped-data": ["tsd"],
  "application/toml": ["toml"],
  "application/trig": ["trig"],
  "application/ttml+xml": ["ttml"],
  "application/ubjson": ["ubj"],
  "application/urc-ressheet+xml": ["rsheet"],
  "application/urc-targetdesc+xml": ["td"],
  "application/voicexml+xml": ["vxml"],
  "application/wasm": ["wasm"],
  "application/widget": ["wgt"],
  "application/winhlp": ["hlp"],
  "application/wsdl+xml": ["wsdl"],
  "application/wspolicy+xml": ["wspolicy"],
  "application/xaml+xml": ["xaml"],
  "application/xcap-att+xml": ["xav"],
  "application/xcap-caps+xml": ["xca"],
  "application/xcap-diff+xml": ["xdf"],
  "application/xcap-el+xml": ["xel"],
  "application/xcap-ns+xml": ["xns"],
  "application/xenc+xml": ["xenc"],
  "application/xhtml+xml": ["xhtml", "xht"],
  "application/xliff+xml": ["xlf"],
  "application/xml": ["xml", "xsl", "xsd", "rng"],
  "application/xml-dtd": ["dtd"],
  "application/xop+xml": ["xop"],
  "application/xproc+xml": ["xpl"],
  "application/xslt+xml": ["*xsl", "xslt"],
  "application/xspf+xml": ["xspf"],
  "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"],
  "application/yang": ["yang"],
  "application/yin+xml": ["yin"],
  "application/zip": ["zip"],
  "audio/3gpp": ["*3gpp"],
  "audio/adpcm": ["adp"],
  "audio/amr": ["amr"],
  "audio/basic": ["au", "snd"],
  "audio/midi": ["mid", "midi", "kar", "rmi"],
  "audio/mobile-xmf": ["mxmf"],
  "audio/mp3": ["*mp3"],
  "audio/mp4": ["m4a", "mp4a"],
  "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
  "audio/ogg": ["oga", "ogg", "spx", "opus"],
  "audio/s3m": ["s3m"],
  "audio/silk": ["sil"],
  "audio/wav": ["wav"],
  "audio/wave": ["*wav"],
  "audio/webm": ["weba"],
  "audio/xm": ["xm"],
  "font/collection": ["ttc"],
  "font/otf": ["otf"],
  "font/ttf": ["ttf"],
  "font/woff": ["woff"],
  "font/woff2": ["woff2"],
  "image/aces": ["exr"],
  "image/apng": ["apng"],
  "image/avif": ["avif"],
  "image/bmp": ["bmp"],
  "image/cgm": ["cgm"],
  "image/dicom-rle": ["drle"],
  "image/emf": ["emf"],
  "image/fits": ["fits"],
  "image/g3fax": ["g3"],
  "image/gif": ["gif"],
  "image/heic": ["heic"],
  "image/heic-sequence": ["heics"],
  "image/heif": ["heif"],
  "image/heif-sequence": ["heifs"],
  "image/hej2k": ["hej2"],
  "image/hsj2": ["hsj2"],
  "image/ief": ["ief"],
  "image/jls": ["jls"],
  "image/jp2": ["jp2", "jpg2"],
  "image/jpeg": ["jpeg", "jpg", "jpe"],
  "image/jph": ["jph"],
  "image/jphc": ["jhc"],
  "image/jpm": ["jpm"],
  "image/jpx": ["jpx", "jpf"],
  "image/jxr": ["jxr"],
  "image/jxra": ["jxra"],
  "image/jxrs": ["jxrs"],
  "image/jxs": ["jxs"],
  "image/jxsc": ["jxsc"],
  "image/jxsi": ["jxsi"],
  "image/jxss": ["jxss"],
  "image/ktx": ["ktx"],
  "image/ktx2": ["ktx2"],
  "image/png": ["png"],
  "image/sgi": ["sgi"],
  "image/svg+xml": ["svg", "svgz"],
  "image/t38": ["t38"],
  "image/tiff": ["tif", "tiff"],
  "image/tiff-fx": ["tfx"],
  "image/webp": ["webp"],
  "image/wmf": ["wmf"],
  "message/disposition-notification": ["disposition-notification"],
  "message/global": ["u8msg"],
  "message/global-delivery-status": ["u8dsn"],
  "message/global-disposition-notification": ["u8mdn"],
  "message/global-headers": ["u8hdr"],
  "message/rfc822": ["eml", "mime"],
  "model/3mf": ["3mf"],
  "model/gltf+json": ["gltf"],
  "model/gltf-binary": ["glb"],
  "model/iges": ["igs", "iges"],
  "model/mesh": ["msh", "mesh", "silo"],
  "model/mtl": ["mtl"],
  "model/obj": ["obj"],
  "model/step+xml": ["stpx"],
  "model/step+zip": ["stpz"],
  "model/step-xml+zip": ["stpxz"],
  "model/stl": ["stl"],
  "model/vrml": ["wrl", "vrml"],
  "model/x3d+binary": ["*x3db", "x3dbz"],
  "model/x3d+fastinfoset": ["x3db"],
  "model/x3d+vrml": ["*x3dv", "x3dvz"],
  "model/x3d+xml": ["x3d", "x3dz"],
  "model/x3d-vrml": ["x3dv"],
  "text/cache-manifest": ["appcache", "manifest"],
  "text/calendar": ["ics", "ifb"],
  "text/coffeescript": ["coffee", "litcoffee"],
  "text/css": ["css"],
  "text/csv": ["csv"],
  "text/html": ["html", "htm", "shtml"],
  "text/jade": ["jade"],
  "text/jsx": ["jsx"],
  "text/less": ["less"],
  "text/markdown": ["markdown", "md"],
  "text/mathml": ["mml"],
  "text/mdx": ["mdx"],
  "text/n3": ["n3"],
  "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
  "text/richtext": ["rtx"],
  "text/rtf": ["*rtf"],
  "text/sgml": ["sgml", "sgm"],
  "text/shex": ["shex"],
  "text/slim": ["slim", "slm"],
  "text/spdx": ["spdx"],
  "text/stylus": ["stylus", "styl"],
  "text/tab-separated-values": ["tsv"],
  "text/troff": ["t", "tr", "roff", "man", "me", "ms"],
  "text/turtle": ["ttl"],
  "text/uri-list": ["uri", "uris", "urls"],
  "text/vcard": ["vcard"],
  "text/vtt": ["vtt"],
  "text/xml": ["*xml"],
  "text/yaml": ["yaml", "yml"],
  "video/3gpp": ["3gp", "3gpp"],
  "video/3gpp2": ["3g2"],
  "video/h261": ["h261"],
  "video/h263": ["h263"],
  "video/h264": ["h264"],
  "video/iso.segment": ["m4s"],
  "video/jpeg": ["jpgv"],
  "video/jpm": ["*jpm", "jpgm"],
  "video/mj2": ["mj2", "mjp2"],
  "video/mp2t": ["ts"],
  "video/mp4": ["mp4", "mp4v", "mpg4"],
  "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"],
  "video/ogg": ["ogv"],
  "video/quicktime": ["qt", "mov"],
  "video/webm": ["webm"]
};

/***/ }),

/***/ "./node_modules/mp4-box-encoding/boxes.js":
/*!************************************************!*\
  !*** ./node_modules/mp4-box-encoding/boxes.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
// This is an intentionally recursive require. I don't like it either.
var Box = __webpack_require__(/*! ./index */ "./node_modules/mp4-box-encoding/index.js");

var Descriptor = __webpack_require__(/*! ./descriptor */ "./node_modules/mp4-box-encoding/descriptor.js");

var uint64be = __webpack_require__(/*! uint64be */ "./node_modules/uint64be/index.js");

var TIME_OFFSET = 2082844800000;
/*
TODO:
test these
add new box versions
*/
// These have 'version' and 'flags' fields in the headers

exports.fullBoxes = {};
var fullBoxes = ['mvhd', 'tkhd', 'mdhd', 'vmhd', 'smhd', 'stsd', 'esds', 'stsz', 'stco', 'co64', 'stss', 'stts', 'ctts', 'stsc', 'dref', 'elst', 'hdlr', 'mehd', 'trex', 'mfhd', 'tfhd', 'tfdt', 'trun'];
fullBoxes.forEach(function (type) {
  exports.fullBoxes[type] = true;
});
exports.ftyp = {};

exports.ftyp.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer.alloc(exports.ftyp.encodingLength(box));
  var brands = box.compatibleBrands || [];
  buf.write(box.brand, 0, 4, 'ascii');
  buf.writeUInt32BE(box.brandVersion, 4);

  for (var i = 0; i < brands.length; i++) buf.write(brands[i], 8 + i * 4, 4, 'ascii');

  exports.ftyp.encode.bytes = 8 + brands.length * 4;
  return buf;
};

exports.ftyp.decode = function (buf, offset) {
  buf = buf.slice(offset);
  var brand = buf.toString('ascii', 0, 4);
  var version = buf.readUInt32BE(4);
  var compatibleBrands = [];

  for (var i = 8; i < buf.length; i += 4) compatibleBrands.push(buf.toString('ascii', i, i + 4));

  return {
    brand: brand,
    brandVersion: version,
    compatibleBrands: compatibleBrands
  };
};

exports.ftyp.encodingLength = function (box) {
  return 8 + (box.compatibleBrands || []).length * 4;
};

exports.mvhd = {};

exports.mvhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer.alloc(96);
  writeDate(box.ctime || new Date(), buf, 0);
  writeDate(box.mtime || new Date(), buf, 4);
  buf.writeUInt32BE(box.timeScale || 0, 8);
  buf.writeUInt32BE(box.duration || 0, 12);
  writeFixed32(box.preferredRate || 0, buf, 16);
  writeFixed16(box.preferredVolume || 0, buf, 20);
  writeReserved(buf, 22, 32);
  writeMatrix(box.matrix, buf, 32);
  buf.writeUInt32BE(box.previewTime || 0, 68);
  buf.writeUInt32BE(box.previewDuration || 0, 72);
  buf.writeUInt32BE(box.posterTime || 0, 76);
  buf.writeUInt32BE(box.selectionTime || 0, 80);
  buf.writeUInt32BE(box.selectionDuration || 0, 84);
  buf.writeUInt32BE(box.currentTime || 0, 88);
  buf.writeUInt32BE(box.nextTrackId || 0, 92);
  exports.mvhd.encode.bytes = 96;
  return buf;
};

exports.mvhd.decode = function (buf, offset) {
  buf = buf.slice(offset);
  return {
    ctime: readDate(buf, 0),
    mtime: readDate(buf, 4),
    timeScale: buf.readUInt32BE(8),
    duration: buf.readUInt32BE(12),
    preferredRate: readFixed32(buf, 16),
    preferredVolume: readFixed16(buf, 20),
    matrix: readMatrix(buf.slice(32, 68)),
    previewTime: buf.readUInt32BE(68),
    previewDuration: buf.readUInt32BE(72),
    posterTime: buf.readUInt32BE(76),
    selectionTime: buf.readUInt32BE(80),
    selectionDuration: buf.readUInt32BE(84),
    currentTime: buf.readUInt32BE(88),
    nextTrackId: buf.readUInt32BE(92)
  };
};

exports.mvhd.encodingLength = function (box) {
  return 96;
};

exports.tkhd = {};

exports.tkhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer.alloc(80);
  writeDate(box.ctime || new Date(), buf, 0);
  writeDate(box.mtime || new Date(), buf, 4);
  buf.writeUInt32BE(box.trackId || 0, 8);
  writeReserved(buf, 12, 16);
  buf.writeUInt32BE(box.duration || 0, 16);
  writeReserved(buf, 20, 28);
  buf.writeUInt16BE(box.layer || 0, 28);
  buf.writeUInt16BE(box.alternateGroup || 0, 30);
  buf.writeUInt16BE(box.volume || 0, 32);
  writeMatrix(box.matrix, buf, 36);
  buf.writeUInt32BE(box.trackWidth || 0, 72);
  buf.writeUInt32BE(box.trackHeight || 0, 76);
  exports.tkhd.encode.bytes = 80;
  return buf;
};

exports.tkhd.decode = function (buf, offset) {
  buf = buf.slice(offset);
  return {
    ctime: readDate(buf, 0),
    mtime: readDate(buf, 4),
    trackId: buf.readUInt32BE(8),
    duration: buf.readUInt32BE(16),
    layer: buf.readUInt16BE(28),
    alternateGroup: buf.readUInt16BE(30),
    volume: buf.readUInt16BE(32),
    matrix: readMatrix(buf.slice(36, 72)),
    trackWidth: buf.readUInt32BE(72),
    trackHeight: buf.readUInt32BE(76)
  };
};

exports.tkhd.encodingLength = function (box) {
  return 80;
};

exports.mdhd = {};

exports.mdhd.encode = function (box, buf, offset) {
  if (box.version === 1) {
    buf = buf ? buf.slice(offset) : Buffer.alloc(32);
    writeDate64(box.ctime || new Date(), buf, 0);
    writeDate64(box.mtime || new Date(), buf, 8);
    buf.writeUInt32BE(box.timeScale || 0, 16); // Node only supports integer <= 48bit. Waiting for BigInt!

    buf.writeUIntBE(box.duration || 0, 20, 6);
    buf.writeUInt16BE(box.language || 0, 28);
    buf.writeUInt16BE(box.quality || 0, 30);
    exports.mdhd.encode.bytes = 32;
    return buf;
  }

  buf = buf ? buf.slice(offset) : Buffer.alloc(20);
  writeDate(box.ctime || new Date(), buf, 0);
  writeDate(box.mtime || new Date(), buf, 4);
  buf.writeUInt32BE(box.timeScale || 0, 8);
  buf.writeUInt32BE(box.duration || 0, 12);
  buf.writeUInt16BE(box.language || 0, 16);
  buf.writeUInt16BE(box.quality || 0, 18);
  exports.mdhd.encode.bytes = 20;
  return buf;
};

exports.mdhd.decode = function (buf, offset, end) {
  buf = buf.slice(offset);
  var version1 = end - offset !== 20; // In version 1 creation time and modification time are unsigned long

  if (version1) {
    return {
      ctime: readDate64(buf, 0),
      mtime: readDate64(buf, 8),
      timeScale: buf.readUInt32BE(16),
      // Node only supports integer <= 48bit. Waiting for BigInt!
      duration: buf.readUIntBE(20, 6),
      language: buf.readUInt16BE(28),
      quality: buf.readUInt16BE(30)
    };
  }

  return {
    ctime: readDate(buf, 0),
    mtime: readDate(buf, 4),
    timeScale: buf.readUInt32BE(8),
    duration: buf.readUInt32BE(12),
    language: buf.readUInt16BE(16),
    quality: buf.readUInt16BE(18)
  };
};

exports.mdhd.encodingLength = function (box) {
  if (box.version === 1) return 32;
  return 20;
};

exports.vmhd = {};

exports.vmhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer.alloc(8);
  buf.writeUInt16BE(box.graphicsMode || 0, 0);
  var opcolor = box.opcolor || [0, 0, 0];
  buf.writeUInt16BE(opcolor[0], 2);
  buf.writeUInt16BE(opcolor[1], 4);
  buf.writeUInt16BE(opcolor[2], 6);
  exports.vmhd.encode.bytes = 8;
  return buf;
};

exports.vmhd.decode = function (buf, offset) {
  buf = buf.slice(offset);
  return {
    graphicsMode: buf.readUInt16BE(0),
    opcolor: [buf.readUInt16BE(2), buf.readUInt16BE(4), buf.readUInt16BE(6)]
  };
};

exports.vmhd.encodingLength = function (box) {
  return 8;
};

exports.smhd = {};

exports.smhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer.alloc(4);
  buf.writeUInt16BE(box.balance || 0, 0);
  writeReserved(buf, 2, 4);
  exports.smhd.encode.bytes = 4;
  return buf;
};

exports.smhd.decode = function (buf, offset) {
  buf = buf.slice(offset);
  return {
    balance: buf.readUInt16BE(0)
  };
};

exports.smhd.encodingLength = function (box) {
  return 4;
};

exports.stsd = {};

exports.stsd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer.alloc(exports.stsd.encodingLength(box));
  var entries = box.entries || [];
  buf.writeUInt32BE(entries.length, 0);
  var ptr = 4;

  for (var i = 0; i < entries.length; i++) {
    var entry = entries[i];
    Box.encode(entry, buf, ptr);
    ptr += Box.encode.bytes;
  }

  exports.stsd.encode.bytes = ptr;
  return buf;
};

exports.stsd.decode = function (buf, offset, end) {
  buf = buf.slice(offset);
  var num = buf.readUInt32BE(0);
  var entries = new Array(num);
  var ptr = 4;

  for (var i = 0; i < num; i++) {
    var entry = Box.decode(buf, ptr, end);
    entries[i] = entry;
    ptr += entry.length;
  }

  return {
    entries: entries
  };
};

exports.stsd.encodingLength = function (box) {
  var totalSize = 4;
  if (!box.entries) return totalSize;

  for (var i = 0; i < box.entries.length; i++) {
    totalSize += Box.encodingLength(box.entries[i]);
  }

  return totalSize;
};

exports.avc1 = exports.VisualSampleEntry = {};

exports.VisualSampleEntry.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer.alloc(exports.VisualSampleEntry.encodingLength(box));
  writeReserved(buf, 0, 6);
  buf.writeUInt16BE(box.dataReferenceIndex || 0, 6);
  writeReserved(buf, 8, 24);
  buf.writeUInt16BE(box.width || 0, 24);
  buf.writeUInt16BE(box.height || 0, 26);
  buf.writeUInt32BE(box.hResolution || 0x480000, 28);
  buf.writeUInt32BE(box.vResolution || 0x480000, 32);
  writeReserved(buf, 36, 40);
  buf.writeUInt16BE(box.frameCount || 1, 40);
  var compressorName = box.compressorName || '';
  var nameLen = Math.min(compressorName.length, 31);
  buf.writeUInt8(nameLen, 42);
  buf.write(compressorName, 43, nameLen, 'utf8');
  buf.writeUInt16BE(box.depth || 0x18, 74);
  buf.writeInt16BE(-1, 76);
  var ptr = 78;
  var children = box.children || [];
  children.forEach(function (child) {
    Box.encode(child, buf, ptr);
    ptr += Box.encode.bytes;
  });
  exports.VisualSampleEntry.encode.bytes = ptr;
};

exports.VisualSampleEntry.decode = function (buf, offset, end) {
  buf = buf.slice(offset);
  var length = end - offset;
  var nameLen = Math.min(buf.readUInt8(42), 31);
  var box = {
    dataReferenceIndex: buf.readUInt16BE(6),
    width: buf.readUInt16BE(24),
    height: buf.readUInt16BE(26),
    hResolution: buf.readUInt32BE(28),
    vResolution: buf.readUInt32BE(32),
    frameCount: buf.readUInt16BE(40),
    compressorName: buf.toString('utf8', 43, 43 + nameLen),
    depth: buf.readUInt16BE(74),
    children: []
  };
  var ptr = 78;

  while (length - ptr >= 8) {
    var child = Box.decode(buf, ptr, length);
    box.children.push(child);
    box[child.type] = child;
    ptr += child.length;
  }

  return box;
};

exports.VisualSampleEntry.encodingLength = function (box) {
  var len = 78;
  var children = box.children || [];
  children.forEach(function (child) {
    len += Box.encodingLength(child);
  });
  return len;
};

exports.avcC = {};

exports.avcC.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer.alloc(box.buffer.length);
  box.buffer.copy(buf);
  exports.avcC.encode.bytes = box.buffer.length;
};

exports.avcC.decode = function (buf, offset, end) {
  buf = buf.slice(offset, end);
  return {
    mimeCodec: buf.toString('hex', 1, 4),
    buffer: Buffer.from(buf)
  };
};

exports.avcC.encodingLength = function (box) {
  return box.buffer.length;
};

exports.mp4a = exports.AudioSampleEntry = {};

exports.AudioSampleEntry.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer.alloc(exports.AudioSampleEntry.encodingLength(box));
  writeReserved(buf, 0, 6);
  buf.writeUInt16BE(box.dataReferenceIndex || 0, 6);
  writeReserved(buf, 8, 16);
  buf.writeUInt16BE(box.channelCount || 2, 16);
  buf.writeUInt16BE(box.sampleSize || 16, 18);
  writeReserved(buf, 20, 24);
  buf.writeUInt32BE(box.sampleRate || 0, 24);
  var ptr = 28;
  var children = box.children || [];
  children.forEach(function (child) {
    Box.encode(child, buf, ptr);
    ptr += Box.encode.bytes;
  });
  exports.AudioSampleEntry.encode.bytes = ptr;
};

exports.AudioSampleEntry.decode = function (buf, offset, end) {
  buf = buf.slice(offset, end);
  var length = end - offset;
  var box = {
    dataReferenceIndex: buf.readUInt16BE(6),
    channelCount: buf.readUInt16BE(16),
    sampleSize: buf.readUInt16BE(18),
    sampleRate: buf.readUInt32BE(24),
    children: []
  };
  var ptr = 28;

  while (length - ptr >= 8) {
    var child = Box.decode(buf, ptr, length);
    box.children.push(child);
    box[child.type] = child;
    ptr += child.length;
  }

  return box;
};

exports.AudioSampleEntry.encodingLength = function (box) {
  var len = 28;
  var children = box.children || [];
  children.forEach(function (child) {
    len += Box.encodingLength(child);
  });
  return len;
};

exports.esds = {};

exports.esds.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer.alloc(box.buffer.length);
  box.buffer.copy(buf, 0);
  exports.esds.encode.bytes = box.buffer.length;
};

exports.esds.decode = function (buf, offset, end) {
  buf = buf.slice(offset, end);
  var desc = Descriptor.Descriptor.decode(buf, 0, buf.length);
  var esd = desc.tagName === 'ESDescriptor' ? desc : {};
  var dcd = esd.DecoderConfigDescriptor || {};
  var oti = dcd.oti || 0;
  var dsi = dcd.DecoderSpecificInfo;
  var audioConfig = dsi ? (dsi.buffer.readUInt8(0) & 0xf8) >> 3 : 0;
  var mimeCodec = null;

  if (oti) {
    mimeCodec = oti.toString(16);

    if (audioConfig) {
      mimeCodec += '.' + audioConfig;
    }
  }

  return {
    mimeCodec: mimeCodec,
    buffer: Buffer.from(buf.slice(0))
  };
};

exports.esds.encodingLength = function (box) {
  return box.buffer.length;
}; // TODO: integrate the two versions in a saner way


exports.stsz = {};

exports.stsz.encode = function (box, buf, offset) {
  var entries = box.entries || [];
  buf = buf ? buf.slice(offset) : Buffer.alloc(exports.stsz.encodingLength(box));
  buf.writeUInt32BE(0, 0);
  buf.writeUInt32BE(entries.length, 4);

  for (var i = 0; i < entries.length; i++) {
    buf.writeUInt32BE(entries[i], i * 4 + 8);
  }

  exports.stsz.encode.bytes = 8 + entries.length * 4;
  return buf;
};

exports.stsz.decode = function (buf, offset) {
  buf = buf.slice(offset);
  var size = buf.readUInt32BE(0);
  var num = buf.readUInt32BE(4);
  var entries = new Array(num);

  for (var i = 0; i < num; i++) {
    if (size === 0) {
      entries[i] = buf.readUInt32BE(i * 4 + 8);
    } else {
      entries[i] = size;
    }
  }

  return {
    entries: entries
  };
};

exports.stsz.encodingLength = function (box) {
  return 8 + box.entries.length * 4;
};

exports.stss = exports.stco = {};

exports.stco.encode = function (box, buf, offset) {
  var entries = box.entries || [];
  buf = buf ? buf.slice(offset) : Buffer.alloc(exports.stco.encodingLength(box));
  buf.writeUInt32BE(entries.length, 0);

  for (var i = 0; i < entries.length; i++) {
    buf.writeUInt32BE(entries[i], i * 4 + 4);
  }

  exports.stco.encode.bytes = 4 + entries.length * 4;
  return buf;
};

exports.stco.decode = function (buf, offset) {
  buf = buf.slice(offset);
  var num = buf.readUInt32BE(0);
  var entries = new Array(num);

  for (var i = 0; i < num; i++) {
    entries[i] = buf.readUInt32BE(i * 4 + 4);
  }

  return {
    entries: entries
  };
};

exports.stco.encodingLength = function (box) {
  return 4 + box.entries.length * 4;
};

exports.co64 = {};

exports.co64.encode = function (box, buf, offset) {
  var entries = box.entries || [];
  buf = buf ? buf.slice(offset) : Buffer.alloc(exports.co64.encodingLength(box));
  buf.writeUInt32BE(entries.length, 0);

  for (var i = 0; i < entries.length; i++) {
    uint64be.encode(entries[i], buf, i * 8 + 4);
  }

  exports.co64.encode.bytes = 4 + entries.length * 8;
  return buf;
};

exports.co64.decode = function (buf, offset) {
  buf = buf.slice(offset);
  var num = buf.readUInt32BE(0);
  var entries = new Array(num);

  for (var i = 0; i < num; i++) {
    entries[i] = uint64be.decode(buf, i * 8 + 4);
  }

  return {
    entries: entries
  };
};

exports.co64.encodingLength = function (box) {
  return 4 + box.entries.length * 8;
};

exports.stts = {};

exports.stts.encode = function (box, buf, offset) {
  var entries = box.entries || [];
  buf = buf ? buf.slice(offset) : Buffer.alloc(exports.stts.encodingLength(box));
  buf.writeUInt32BE(entries.length, 0);

  for (var i = 0; i < entries.length; i++) {
    var ptr = i * 8 + 4;
    buf.writeUInt32BE(entries[i].count || 0, ptr);
    buf.writeUInt32BE(entries[i].duration || 0, ptr + 4);
  }

  exports.stts.encode.bytes = 4 + box.entries.length * 8;
  return buf;
};

exports.stts.decode = function (buf, offset) {
  buf = buf.slice(offset);
  var num = buf.readUInt32BE(0);
  var entries = new Array(num);

  for (var i = 0; i < num; i++) {
    var ptr = i * 8 + 4;
    entries[i] = {
      count: buf.readUInt32BE(ptr),
      duration: buf.readUInt32BE(ptr + 4)
    };
  }

  return {
    entries: entries
  };
};

exports.stts.encodingLength = function (box) {
  return 4 + box.entries.length * 8;
};

exports.ctts = {};

exports.ctts.encode = function (box, buf, offset) {
  var entries = box.entries || [];
  buf = buf ? buf.slice(offset) : Buffer.alloc(exports.ctts.encodingLength(box));
  buf.writeUInt32BE(entries.length, 0);

  for (var i = 0; i < entries.length; i++) {
    var ptr = i * 8 + 4;
    buf.writeUInt32BE(entries[i].count || 0, ptr);
    buf.writeUInt32BE(entries[i].compositionOffset || 0, ptr + 4);
  }

  exports.ctts.encode.bytes = 4 + entries.length * 8;
  return buf;
};

exports.ctts.decode = function (buf, offset) {
  buf = buf.slice(offset);
  var num = buf.readUInt32BE(0);
  var entries = new Array(num);

  for (var i = 0; i < num; i++) {
    var ptr = i * 8 + 4;
    entries[i] = {
      count: buf.readUInt32BE(ptr),
      compositionOffset: buf.readInt32BE(ptr + 4)
    };
  }

  return {
    entries: entries
  };
};

exports.ctts.encodingLength = function (box) {
  return 4 + box.entries.length * 8;
};

exports.stsc = {};

exports.stsc.encode = function (box, buf, offset) {
  var entries = box.entries || [];
  buf = buf ? buf.slice(offset) : Buffer.alloc(exports.stsc.encodingLength(box));
  buf.writeUInt32BE(entries.length, 0);

  for (var i = 0; i < entries.length; i++) {
    var ptr = i * 12 + 4;
    buf.writeUInt32BE(entries[i].firstChunk || 0, ptr);
    buf.writeUInt32BE(entries[i].samplesPerChunk || 0, ptr + 4);
    buf.writeUInt32BE(entries[i].sampleDescriptionId || 0, ptr + 8);
  }

  exports.stsc.encode.bytes = 4 + entries.length * 12;
  return buf;
};

exports.stsc.decode = function (buf, offset) {
  buf = buf.slice(offset);
  var num = buf.readUInt32BE(0);
  var entries = new Array(num);

  for (var i = 0; i < num; i++) {
    var ptr = i * 12 + 4;
    entries[i] = {
      firstChunk: buf.readUInt32BE(ptr),
      samplesPerChunk: buf.readUInt32BE(ptr + 4),
      sampleDescriptionId: buf.readUInt32BE(ptr + 8)
    };
  }

  return {
    entries: entries
  };
};

exports.stsc.encodingLength = function (box) {
  return 4 + box.entries.length * 12;
};

exports.dref = {};

exports.dref.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer.alloc(exports.dref.encodingLength(box));
  var entries = box.entries || [];
  buf.writeUInt32BE(entries.length, 0);
  var ptr = 4;

  for (var i = 0; i < entries.length; i++) {
    var entry = entries[i];
    var size = (entry.buf ? entry.buf.length : 0) + 4 + 4;
    buf.writeUInt32BE(size, ptr);
    ptr += 4;
    buf.write(entry.type, ptr, 4, 'ascii');
    ptr += 4;

    if (entry.buf) {
      entry.buf.copy(buf, ptr);
      ptr += entry.buf.length;
    }
  }

  exports.dref.encode.bytes = ptr;
  return buf;
};

exports.dref.decode = function (buf, offset) {
  buf = buf.slice(offset);
  var num = buf.readUInt32BE(0);
  var entries = new Array(num);
  var ptr = 4;

  for (var i = 0; i < num; i++) {
    var size = buf.readUInt32BE(ptr);
    var type = buf.toString('ascii', ptr + 4, ptr + 8);
    var tmp = buf.slice(ptr + 8, ptr + size);
    ptr += size;
    entries[i] = {
      type: type,
      buf: tmp
    };
  }

  return {
    entries: entries
  };
};

exports.dref.encodingLength = function (box) {
  var totalSize = 4;
  if (!box.entries) return totalSize;

  for (var i = 0; i < box.entries.length; i++) {
    var buf = box.entries[i].buf;
    totalSize += (buf ? buf.length : 0) + 4 + 4;
  }

  return totalSize;
};

exports.elst = {};

exports.elst.encode = function (box, buf, offset) {
  var entries = box.entries || [];
  buf = buf ? buf.slice(offset) : Buffer.alloc(exports.elst.encodingLength(box));
  buf.writeUInt32BE(entries.length, 0);

  for (var i = 0; i < entries.length; i++) {
    var ptr = i * 12 + 4;
    buf.writeUInt32BE(entries[i].trackDuration || 0, ptr);
    buf.writeUInt32BE(entries[i].mediaTime || 0, ptr + 4);
    writeFixed32(entries[i].mediaRate || 0, buf, ptr + 8);
  }

  exports.elst.encode.bytes = 4 + entries.length * 12;
  return buf;
};

exports.elst.decode = function (buf, offset) {
  buf = buf.slice(offset);
  var num = buf.readUInt32BE(0);
  var entries = new Array(num);

  for (var i = 0; i < num; i++) {
    var ptr = i * 12 + 4;
    entries[i] = {
      trackDuration: buf.readUInt32BE(ptr),
      mediaTime: buf.readInt32BE(ptr + 4),
      mediaRate: readFixed32(buf, ptr + 8)
    };
  }

  return {
    entries: entries
  };
};

exports.elst.encodingLength = function (box) {
  return 4 + box.entries.length * 12;
};

exports.hdlr = {};

exports.hdlr.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer.alloc(exports.hdlr.encodingLength(box));
  var len = 21 + (box.name || '').length;
  buf.fill(0, 0, len);
  buf.write(box.handlerType || '', 4, 4, 'ascii');
  writeString(box.name || '', buf, 20);
  exports.hdlr.encode.bytes = len;
  return buf;
};

exports.hdlr.decode = function (buf, offset, end) {
  buf = buf.slice(offset);
  return {
    handlerType: buf.toString('ascii', 4, 8),
    name: readString(buf, 20, end)
  };
};

exports.hdlr.encodingLength = function (box) {
  return 21 + (box.name || '').length;
};

exports.mehd = {};

exports.mehd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer.alloc(4);
  buf.writeUInt32BE(box.fragmentDuration || 0, 0);
  exports.mehd.encode.bytes = 4;
  return buf;
};

exports.mehd.decode = function (buf, offset) {
  buf = buf.slice(offset);
  return {
    fragmentDuration: buf.readUInt32BE(0)
  };
};

exports.mehd.encodingLength = function (box) {
  return 4;
};

exports.trex = {};

exports.trex.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer.alloc(20);
  buf.writeUInt32BE(box.trackId || 0, 0);
  buf.writeUInt32BE(box.defaultSampleDescriptionIndex || 0, 4);
  buf.writeUInt32BE(box.defaultSampleDuration || 0, 8);
  buf.writeUInt32BE(box.defaultSampleSize || 0, 12);
  buf.writeUInt32BE(box.defaultSampleFlags || 0, 16);
  exports.trex.encode.bytes = 20;
  return buf;
};

exports.trex.decode = function (buf, offset) {
  buf = buf.slice(offset);
  return {
    trackId: buf.readUInt32BE(0),
    defaultSampleDescriptionIndex: buf.readUInt32BE(4),
    defaultSampleDuration: buf.readUInt32BE(8),
    defaultSampleSize: buf.readUInt32BE(12),
    defaultSampleFlags: buf.readUInt32BE(16)
  };
};

exports.trex.encodingLength = function (box) {
  return 20;
};

exports.mfhd = {};

exports.mfhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer.alloc(4);
  buf.writeUInt32BE(box.sequenceNumber || 0, 0);
  exports.mfhd.encode.bytes = 4;
  return buf;
};

exports.mfhd.decode = function (buf, offset) {
  return {
    sequenceNumber: buf.readUInt32BE(0)
  };
};

exports.mfhd.encodingLength = function (box) {
  return 4;
};

exports.tfhd = {};

exports.tfhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer.alloc(4);
  buf.writeUInt32BE(box.trackId, 0);
  exports.tfhd.encode.bytes = 4;
  return buf;
};

exports.tfhd.decode = function (buf, offset) {// TODO: this
};

exports.tfhd.encodingLength = function (box) {
  // TODO: this is wrong!
  return 4;
};

exports.tfdt = {};

exports.tfdt.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer.alloc(4);
  buf.writeUInt32BE(box.baseMediaDecodeTime || 0, 0);
  exports.tfdt.encode.bytes = 4;
  return buf;
};

exports.tfdt.decode = function (buf, offset) {// TODO: this
};

exports.tfdt.encodingLength = function (box) {
  return 4;
};

exports.trun = {};

exports.trun.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer.alloc(8 + box.entries.length * 16); // TODO: this is wrong

  buf.writeUInt32BE(box.entries.length, 0);
  buf.writeInt32BE(box.dataOffset, 4);
  var ptr = 8;

  for (var i = 0; i < box.entries.length; i++) {
    var entry = box.entries[i];
    buf.writeUInt32BE(entry.sampleDuration, ptr);
    ptr += 4;
    buf.writeUInt32BE(entry.sampleSize, ptr);
    ptr += 4;
    buf.writeUInt32BE(entry.sampleFlags, ptr);
    ptr += 4;

    if ((box.version || 0) === 0) {
      buf.writeUInt32BE(entry.sampleCompositionTimeOffset, ptr);
    } else {
      buf.writeInt32BE(entry.sampleCompositionTimeOffset, ptr);
    }

    ptr += 4;
  }

  exports.trun.encode.bytes = ptr;
};

exports.trun.decode = function (buf, offset) {// TODO: this
};

exports.trun.encodingLength = function (box) {
  // TODO: this is wrong
  return 8 + box.entries.length * 16;
};

exports.mdat = {};

exports.mdat.encode = function (box, buf, offset) {
  if (box.buffer) {
    box.buffer.copy(buf, offset);
    exports.mdat.encode.bytes = box.buffer.length;
  } else {
    exports.mdat.encode.bytes = exports.mdat.encodingLength(box);
  }
};

exports.mdat.decode = function (buf, start, end) {
  return {
    buffer: Buffer.from(buf.slice(start, end))
  };
};

exports.mdat.encodingLength = function (box) {
  return box.buffer ? box.buffer.length : box.contentLength;
};

function writeReserved(buf, offset, end) {
  for (var i = offset; i < end; i++) buf[i] = 0;
}

function writeDate(date, buf, offset) {
  buf.writeUInt32BE(Math.floor((date.getTime() + TIME_OFFSET) / 1000), offset);
}

function writeDate64(date, buf, offset) {
  // Node only supports integer <= 48bit. Waiting for BigInt!
  buf.writeUIntBE(Math.floor((date.getTime() + TIME_OFFSET) / 1000), offset, 6);
} // TODO: think something is wrong here


function writeFixed32(num, buf, offset) {
  buf.writeUInt16BE(Math.floor(num) % (256 * 256), offset);
  buf.writeUInt16BE(Math.floor(num * 256 * 256) % (256 * 256), offset + 2);
}

function writeFixed16(num, buf, offset) {
  buf[offset] = Math.floor(num) % 256;
  buf[offset + 1] = Math.floor(num * 256) % 256;
}

function writeMatrix(list, buf, offset) {
  if (!list) list = [0, 0, 0, 0, 0, 0, 0, 0, 0];

  for (var i = 0; i < list.length; i++) {
    writeFixed32(list[i], buf, offset + i * 4);
  }
}

function writeString(str, buf, offset) {
  var strBuffer = Buffer.from(str, 'utf8');
  strBuffer.copy(buf, offset);
  buf[offset + strBuffer.length] = 0;
}

function readMatrix(buf) {
  var list = new Array(buf.length / 4);

  for (var i = 0; i < list.length; i++) list[i] = readFixed32(buf, i * 4);

  return list;
}

function readDate64(buf, offset) {
  // Node only supports integer <= 48bit. Waiting for BigInt!
  return new Date(buf.readUIntBE(offset, 6) * 1000 - TIME_OFFSET);
}

function readDate(buf, offset) {
  return new Date(buf.readUInt32BE(offset) * 1000 - TIME_OFFSET);
}

function readFixed32(buf, offset) {
  return buf.readUInt16BE(offset) + buf.readUInt16BE(offset + 2) / (256 * 256);
}

function readFixed16(buf, offset) {
  return buf[offset] + buf[offset + 1] / 256;
}

function readString(buf, offset, length) {
  var i;

  for (i = 0; i < length; i++) {
    if (buf[offset + i] === 0) {
      break;
    }
  }

  return buf.toString('utf8', offset, offset + i);
}

/***/ }),

/***/ "./node_modules/mp4-box-encoding/descriptor.js":
/*!*****************************************************!*\
  !*** ./node_modules/mp4-box-encoding/descriptor.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
var tagToName = {
  0x03: 'ESDescriptor',
  0x04: 'DecoderConfigDescriptor',
  0x05: 'DecoderSpecificInfo',
  0x06: 'SLConfigDescriptor'
};
exports.Descriptor = {};

exports.Descriptor.decode = function (buf, start, end) {
  var tag = buf.readUInt8(start);
  var ptr = start + 1;
  var lenByte;
  var len = 0;

  do {
    lenByte = buf.readUInt8(ptr++);
    len = len << 7 | lenByte & 0x7f;
  } while (lenByte & 0x80);

  var obj;
  var tagName = tagToName[tag]; // May be undefined; that's ok

  if (exports[tagName]) {
    obj = exports[tagName].decode(buf, ptr, end);
  } else {
    obj = {
      buffer: Buffer.from(buf.slice(ptr, ptr + len))
    };
  }

  obj.tag = tag;
  obj.tagName = tagName;
  obj.length = ptr - start + len;
  obj.contentsLen = len;
  return obj;
};

exports.DescriptorArray = {};

exports.DescriptorArray.decode = function (buf, start, end) {
  var ptr = start;
  var obj = {};

  while (ptr + 2 <= end) {
    var descriptor = exports.Descriptor.decode(buf, ptr, end);
    ptr += descriptor.length;
    var tagName = tagToName[descriptor.tag] || 'Descriptor' + descriptor.tag;
    obj[tagName] = descriptor;
  }

  return obj;
};

exports.ESDescriptor = {};

exports.ESDescriptor.decode = function (buf, start, end) {
  var flags = buf.readUInt8(start + 2);
  var ptr = start + 3;

  if (flags & 0x80) {
    ptr += 2;
  }

  if (flags & 0x40) {
    var len = buf.readUInt8(ptr);
    ptr += len + 1;
  }

  if (flags & 0x20) {
    ptr += 2;
  }

  return exports.DescriptorArray.decode(buf, ptr, end);
};

exports.DecoderConfigDescriptor = {};

exports.DecoderConfigDescriptor.decode = function (buf, start, end) {
  var oti = buf.readUInt8(start);
  var obj = exports.DescriptorArray.decode(buf, start + 13, end);
  obj.oti = oti;
  return obj;
};

/***/ }),

/***/ "./node_modules/mp4-box-encoding/index.js":
/*!************************************************!*\
  !*** ./node_modules/mp4-box-encoding/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
// var assert = require('assert')
var uint64be = __webpack_require__(/*! uint64be */ "./node_modules/uint64be/index.js");

var boxes = __webpack_require__(/*! ./boxes */ "./node_modules/mp4-box-encoding/boxes.js");

var UINT32_MAX = 4294967295;
var Box = exports;
/*
 * Lists the proper order for boxes inside containers.
 * Five-character names ending in 's' indicate arrays instead of single elements.
 */

var containers = exports.containers = {
  'moov': ['mvhd', 'meta', 'traks', 'mvex'],
  'trak': ['tkhd', 'tref', 'trgr', 'edts', 'meta', 'mdia', 'udta'],
  'edts': ['elst'],
  'mdia': ['mdhd', 'hdlr', 'elng', 'minf'],
  'minf': ['vmhd', 'smhd', 'hmhd', 'sthd', 'nmhd', 'dinf', 'stbl'],
  'dinf': ['dref'],
  'stbl': ['stsd', 'stts', 'ctts', 'cslg', 'stsc', 'stsz', 'stz2', 'stco', 'co64', 'stss', 'stsh', 'padb', 'stdp', 'sdtp', 'sbgps', 'sgpds', 'subss', 'saizs', 'saios'],
  'mvex': ['mehd', 'trexs', 'leva'],
  'moof': ['mfhd', 'meta', 'trafs'],
  'traf': ['tfhd', 'tfdt', 'trun', 'sbgps', 'sgpds', 'subss', 'saizs', 'saios', 'meta']
};

Box.encode = function (obj, buffer, offset) {
  Box.encodingLength(obj); // sets every level appropriately

  offset = offset || 0;
  buffer = buffer || Buffer.alloc(obj.length);
  return Box._encode(obj, buffer, offset);
};

Box._encode = function (obj, buffer, offset) {
  var type = obj.type;
  var len = obj.length;

  if (len > UINT32_MAX) {
    len = 1;
  }

  buffer.writeUInt32BE(len, offset);
  buffer.write(obj.type, offset + 4, 4, 'ascii');
  var ptr = offset + 8;

  if (len === 1) {
    uint64be.encode(obj.length, buffer, ptr);
    ptr += 8;
  }

  if (boxes.fullBoxes[type]) {
    buffer.writeUInt32BE(obj.flags || 0, ptr);
    buffer.writeUInt8(obj.version || 0, ptr);
    ptr += 4;
  }

  if (containers[type]) {
    var contents = containers[type];
    contents.forEach(function (childType) {
      if (childType.length === 5) {
        var entry = obj[childType] || [];
        childType = childType.substr(0, 4);
        entry.forEach(function (child) {
          Box._encode(child, buffer, ptr);

          ptr += Box.encode.bytes;
        });
      } else if (obj[childType]) {
        Box._encode(obj[childType], buffer, ptr);

        ptr += Box.encode.bytes;
      }
    });

    if (obj.otherBoxes) {
      obj.otherBoxes.forEach(function (child) {
        Box._encode(child, buffer, ptr);

        ptr += Box.encode.bytes;
      });
    }
  } else if (boxes[type]) {
    var encode = boxes[type].encode;
    encode(obj, buffer, ptr);
    ptr += encode.bytes;
  } else if (obj.buffer) {
    var buf = obj.buffer;
    buf.copy(buffer, ptr);
    ptr += obj.buffer.length;
  } else {
    throw new Error('Either `type` must be set to a known type (not\'' + type + '\') or `buffer` must be set');
  }

  Box.encode.bytes = ptr - offset; // assert.equal(ptr - offset, obj.length, 'Error encoding \'' + type + '\': wrote ' + ptr - offset + ' bytes, expecting ' + obj.length)

  return buffer;
};
/*
 * Returns an object with `type` and `size` fields,
 * or if there isn't enough data, returns the total
 * number of bytes needed to read the headers
 */


Box.readHeaders = function (buffer, start, end) {
  start = start || 0;
  end = end || buffer.length;

  if (end - start < 8) {
    return 8;
  }

  var len = buffer.readUInt32BE(start);
  var type = buffer.toString('ascii', start + 4, start + 8);
  var ptr = start + 8;

  if (len === 1) {
    if (end - start < 16) {
      return 16;
    }

    len = uint64be.decode(buffer, ptr);
    ptr += 8;
  }

  var version;
  var flags;

  if (boxes.fullBoxes[type]) {
    version = buffer.readUInt8(ptr);
    flags = buffer.readUInt32BE(ptr) & 0xffffff;
    ptr += 4;
  }

  return {
    length: len,
    headersLen: ptr - start,
    contentLen: len - (ptr - start),
    type: type,
    version: version,
    flags: flags
  };
};

Box.decode = function (buffer, start, end) {
  start = start || 0;
  end = end || buffer.length;
  var headers = Box.readHeaders(buffer, start, end);

  if (!headers || headers.length > end - start) {
    throw new Error('Data too short');
  }

  return Box.decodeWithoutHeaders(headers, buffer, start + headers.headersLen, start + headers.length);
};

Box.decodeWithoutHeaders = function (headers, buffer, start, end) {
  start = start || 0;
  end = end || buffer.length;
  var type = headers.type;
  var obj = {};

  if (containers[type]) {
    obj.otherBoxes = [];
    var contents = containers[type];
    var ptr = start;

    while (end - ptr >= 8) {
      var child = Box.decode(buffer, ptr, end);
      ptr += child.length;

      if (contents.indexOf(child.type) >= 0) {
        obj[child.type] = child;
      } else if (contents.indexOf(child.type + 's') >= 0) {
        var childType = child.type + 's';
        var entry = obj[childType] = obj[childType] || [];
        entry.push(child);
      } else {
        obj.otherBoxes.push(child);
      }
    }
  } else if (boxes[type]) {
    var decode = boxes[type].decode;
    obj = decode(buffer, start, end);
  } else {
    obj.buffer = Buffer.from(buffer.slice(start, end));
  }

  obj.length = headers.length;
  obj.contentLen = headers.contentLen;
  obj.type = headers.type;
  obj.version = headers.version;
  obj.flags = headers.flags;
  return obj;
};

Box.encodingLength = function (obj) {
  var type = obj.type;
  var len = 8;

  if (boxes.fullBoxes[type]) {
    len += 4;
  }

  if (containers[type]) {
    var contents = containers[type];
    contents.forEach(function (childType) {
      if (childType.length === 5) {
        var entry = obj[childType] || [];
        childType = childType.substr(0, 4);
        entry.forEach(function (child) {
          child.type = childType;
          len += Box.encodingLength(child);
        });
      } else if (obj[childType]) {
        var child = obj[childType];
        child.type = childType;
        len += Box.encodingLength(child);
      }
    });

    if (obj.otherBoxes) {
      obj.otherBoxes.forEach(function (child) {
        len += Box.encodingLength(child);
      });
    }
  } else if (boxes[type]) {
    len += boxes[type].encodingLength(obj);
  } else if (obj.buffer) {
    len += obj.buffer.length;
  } else {
    throw new Error('Either `type` must be set to a known type (not\'' + type + '\') or `buffer` must be set');
  }

  if (len > UINT32_MAX) {
    len += 8;
  }

  obj.length = len;
  return len;
};

/***/ }),

/***/ "./node_modules/mp4-stream/decode.js":
/*!*******************************************!*\
  !*** ./node_modules/mp4-stream/decode.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var stream = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js");

var nextEvent = __webpack_require__(/*! next-event */ "./node_modules/next-event/index.js");

var Box = __webpack_require__(/*! mp4-box-encoding */ "./node_modules/mp4-box-encoding/index.js");

var EMPTY = Buffer.alloc(0);

let Decoder = /*#__PURE__*/function (_stream$Writable) {
  _inherits(Decoder, _stream$Writable);

  var _super = _createSuper(Decoder);

  function Decoder(opts) {
    var _this;

    _classCallCheck(this, Decoder);

    _this = _super.call(this, opts);
    _this.destroyed = false;
    _this._pending = 0;
    _this._missing = 0;
    _this._ignoreEmpty = false;
    _this._buf = null;
    _this._str = null;
    _this._cb = null;
    _this._ondrain = null;
    _this._writeBuffer = null;
    _this._writeCb = null;
    _this._ondrain = null;

    _this._kick();

    return _this;
  }

  _createClass(Decoder, [{
    key: "destroy",
    value: function destroy(err) {
      if (this.destroyed) return;
      this.destroyed = true;
      if (err) this.emit('error', err);
      this.emit('close');
    }
  }, {
    key: "_write",
    value: function _write(data, enc, next) {
      if (this.destroyed) return;
      var drained = !this._str || !this._str._writableState.needDrain;

      while (data.length && !this.destroyed) {
        if (!this._missing && !this._ignoreEmpty) {
          this._writeBuffer = data;
          this._writeCb = next;
          return;
        }

        var consumed = data.length < this._missing ? data.length : this._missing;
        if (this._buf) data.copy(this._buf, this._buf.length - this._missing);else if (this._str) drained = this._str.write(consumed === data.length ? data : data.slice(0, consumed));
        this._missing -= consumed;

        if (!this._missing) {
          var buf = this._buf;
          var cb = this._cb;
          var stream = this._str;
          this._buf = this._cb = this._str = this._ondrain = null;
          drained = true;
          this._ignoreEmpty = false;
          if (stream) stream.end();
          if (cb) cb(buf);
        }

        data = consumed === data.length ? EMPTY : data.slice(consumed);
      }

      if (this._pending && !this._missing) {
        this._writeBuffer = data;
        this._writeCb = next;
        return;
      }

      if (drained) next();else this._ondrain(next);
    }
  }, {
    key: "_buffer",
    value: function _buffer(size, cb) {
      this._missing = size;
      this._buf = Buffer.alloc(size);
      this._cb = cb;
    }
  }, {
    key: "_stream",
    value: function _stream(size, cb) {
      this._missing = size;
      this._str = new MediaData(this);
      this._ondrain = nextEvent(this._str, 'drain');
      this._pending++;

      this._str.on('end', () => {
        this._pending--;

        this._kick();
      });

      this._cb = cb;
      return this._str;
    }
  }, {
    key: "_readBox",
    value: function _readBox() {
      const bufferHeaders = (len, buf) => {
        this._buffer(len, additionalBuf => {
          if (buf) {
            buf = Buffer.concat([buf, additionalBuf]);
          } else {
            buf = additionalBuf;
          }

          var headers = Box.readHeaders(buf);

          if (typeof headers === 'number') {
            bufferHeaders(headers - buf.length, buf);
          } else {
            this._pending++;
            this._headers = headers;
            this.emit('box', headers);
          }
        });
      };

      bufferHeaders(8);
    }
  }, {
    key: "stream",
    value: function stream() {
      if (!this._headers) throw new Error('this function can only be called once after \'box\' is emitted');
      var headers = this._headers;
      this._headers = null;
      return this._stream(headers.contentLen, () => {
        this._pending--;

        this._kick();
      });
    }
  }, {
    key: "decode",
    value: function decode(cb) {
      if (!this._headers) throw new Error('this function can only be called once after \'box\' is emitted');
      var headers = this._headers;
      this._headers = null;

      this._buffer(headers.contentLen, buf => {
        var box = Box.decodeWithoutHeaders(headers, buf);
        cb(box);
        this._pending--;

        this._kick();
      });
    }
  }, {
    key: "ignore",
    value: function ignore() {
      if (!this._headers) throw new Error('this function can only be called once after \'box\' is emitted');
      var headers = this._headers;
      this._headers = null;
      this._missing = headers.contentLen;

      if (this._missing === 0) {
        this._ignoreEmpty = true;
      }

      this._cb = () => {
        this._pending--;

        this._kick();
      };
    }
  }, {
    key: "_kick",
    value: function _kick() {
      if (this._pending) return;
      if (!this._buf && !this._str) this._readBox();

      if (this._writeBuffer) {
        var next = this._writeCb;
        var buffer = this._writeBuffer;
        this._writeBuffer = null;
        this._writeCb = null;

        this._write(buffer, null, next);
      }
    }
  }]);

  return Decoder;
}(stream.Writable);

let MediaData = /*#__PURE__*/function (_stream$PassThrough) {
  _inherits(MediaData, _stream$PassThrough);

  var _super2 = _createSuper(MediaData);

  function MediaData(parent) {
    var _this2;

    _classCallCheck(this, MediaData);

    _this2 = _super2.call(this);
    _this2._parent = parent;
    _this2.destroyed = false;
    return _this2;
  }

  _createClass(MediaData, [{
    key: "destroy",
    value: function destroy(err) {
      if (this.destroyed) return;
      this.destroyed = true;

      this._parent.destroy(err);

      if (err) this.emit('error', err);
      this.emit('close');
    }
  }]);

  return MediaData;
}(stream.PassThrough);

module.exports = Decoder;

/***/ }),

/***/ "./node_modules/mp4-stream/encode.js":
/*!*******************************************!*\
  !*** ./node_modules/mp4-stream/encode.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var stream = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js");

var Box = __webpack_require__(/*! mp4-box-encoding */ "./node_modules/mp4-box-encoding/index.js");

var queueMicrotask = __webpack_require__(/*! queue-microtask */ "./node_modules/queue-microtask/index.js");

function noop() {}

let Encoder = /*#__PURE__*/function (_stream$Readable) {
  _inherits(Encoder, _stream$Readable);

  var _super = _createSuper(Encoder);

  function Encoder(opts) {
    var _this;

    _classCallCheck(this, Encoder);

    _this = _super.call(this, opts);
    _this.destroyed = false;
    _this._finalized = false;
    _this._reading = false;
    _this._stream = null;
    _this._drain = null;
    _this._want = false;

    _this._onreadable = () => {
      if (!_this._want) return;
      _this._want = false;

      _this._read();
    };

    _this._onend = () => {
      _this._stream = null;
    };

    return _this;
  }

  _createClass(Encoder, [{
    key: "mdat",
    value: function mdat(size, cb) {
      this.mediaData(size, cb);
    }
  }, {
    key: "mediaData",
    value: function mediaData(size, cb) {
      var stream = new MediaData(this);
      this.box({
        type: 'mdat',
        contentLength: size,
        encodeBufferLen: 8,
        stream: stream
      }, cb);
      return stream;
    }
  }, {
    key: "box",
    value: function box(_box, cb) {
      if (!cb) cb = noop;
      if (this.destroyed) return cb(new Error('Encoder is destroyed'));
      var buf;

      if (_box.encodeBufferLen) {
        buf = Buffer.alloc(_box.encodeBufferLen);
      }

      if (_box.stream) {
        _box.buffer = null;
        buf = Box.encode(_box, buf);
        this.push(buf);
        this._stream = _box.stream;

        this._stream.on('readable', this._onreadable);

        this._stream.on('end', this._onend);

        this._stream.on('end', cb);

        this._forward();
      } else {
        buf = Box.encode(_box, buf);
        var drained = this.push(buf);
        if (drained) return queueMicrotask(cb);
        this._drain = cb;
      }
    }
  }, {
    key: "destroy",
    value: function destroy(err) {
      if (this.destroyed) return;
      this.destroyed = true;
      if (this._stream && this._stream.destroy) this._stream.destroy();
      this._stream = null;

      if (this._drain) {
        var cb = this._drain;
        this._drain = null;
        cb(err);
      }

      if (err) this.emit('error', err);
      this.emit('close');
    }
  }, {
    key: "finalize",
    value: function finalize() {
      this._finalized = true;

      if (!this._stream && !this._drain) {
        this.push(null);
      }
    }
  }, {
    key: "_forward",
    value: function _forward() {
      if (!this._stream) return;

      while (!this.destroyed) {
        var buf = this._stream.read();

        if (!buf) {
          this._want = !!this._stream;
          return;
        }

        if (!this.push(buf)) return;
      }
    }
  }, {
    key: "_read",
    value: function _read() {
      if (this._reading || this.destroyed) return;
      this._reading = true;
      if (this._stream) this._forward();

      if (this._drain) {
        var drain = this._drain;
        this._drain = null;
        drain();
      }

      this._reading = false;

      if (this._finalized) {
        this.push(null);
      }
    }
  }]);

  return Encoder;
}(stream.Readable);

let MediaData = /*#__PURE__*/function (_stream$PassThrough) {
  _inherits(MediaData, _stream$PassThrough);

  var _super2 = _createSuper(MediaData);

  function MediaData(parent) {
    var _this2;

    _classCallCheck(this, MediaData);

    _this2 = _super2.call(this);
    _this2._parent = parent;
    _this2.destroyed = false;
    return _this2;
  }

  _createClass(MediaData, [{
    key: "destroy",
    value: function destroy(err) {
      if (this.destroyed) return;
      this.destroyed = true;

      this._parent.destroy(err);

      if (err) this.emit('error', err);
      this.emit('close');
    }
  }]);

  return MediaData;
}(stream.PassThrough);

module.exports = Encoder;

/***/ }),

/***/ "./node_modules/mp4-stream/index.js":
/*!******************************************!*\
  !*** ./node_modules/mp4-stream/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const Decoder = __webpack_require__(/*! ./decode */ "./node_modules/mp4-stream/decode.js");

const Encoder = __webpack_require__(/*! ./encode */ "./node_modules/mp4-stream/encode.js");

exports.decode = opts => new Decoder(opts);

exports.encode = opts => new Encoder(opts);

/***/ }),

/***/ "./node_modules/multistream/index.js":
/*!*******************************************!*\
  !*** ./node_modules/multistream/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/*! multistream. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
const stream = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js");

const once = __webpack_require__(/*! once */ "./node_modules/once/once.js");

function toStreams2Obj(s) {
  return toStreams2(s, {
    objectMode: true,
    highWaterMark: 16
  });
}

function toStreams2Buf(s) {
  return toStreams2(s);
}

function toStreams2(s, opts) {
  if (!s || typeof s === 'function' || s._readableState) return s;
  const wrap = new stream.Readable(opts).wrap(s);

  if (s.destroy) {
    wrap.destroy = s.destroy.bind(s);
  }

  return wrap;
}

let MultiStream = /*#__PURE__*/function (_stream$Readable) {
  _inherits(MultiStream, _stream$Readable);

  var _super = _createSuper(MultiStream);

  function MultiStream(streams, opts) {
    var _this;

    _classCallCheck(this, MultiStream);

    _this = _super.call(this, _objectSpread(_objectSpread({}, opts), {}, {
      autoDestroy: true
    }));
    _this._drained = false;
    _this._forwarding = false;
    _this._current = null;
    _this._toStreams2 = opts && opts.objectMode ? toStreams2Obj : toStreams2Buf;

    if (typeof streams === 'function') {
      _this._queue = streams;
    } else {
      _this._queue = streams.map(_this._toStreams2);

      _this._queue.forEach(stream => {
        if (typeof stream !== 'function') _this._attachErrorListener(stream);
      });
    }

    _this._next();

    return _this;
  }

  _createClass(MultiStream, [{
    key: "_read",
    value: function _read() {
      this._drained = true;

      this._forward();
    }
  }, {
    key: "_forward",
    value: function _forward() {
      if (this._forwarding || !this._drained || !this._current) return;
      this._forwarding = true;
      let chunk;

      while (this._drained && (chunk = this._current.read()) !== null) {
        this._drained = this.push(chunk);
      }

      this._forwarding = false;
    }
  }, {
    key: "_destroy",
    value: function _destroy(err, cb) {
      let streams = [];
      if (this._current) streams.push(this._current);
      if (typeof this._queue !== 'function') streams = streams.concat(this._queue);

      if (streams.length === 0) {
        cb(err);
      } else {
        let counter = streams.length;
        let er = err;
        streams.forEach(stream => {
          destroy(stream, err, err => {
            er = er || err;

            if (--counter === 0) {
              cb(er);
            }
          });
        });
      }
    }
  }, {
    key: "_next",
    value: function _next() {
      this._current = null;

      if (typeof this._queue === 'function') {
        this._queue((err, stream) => {
          if (err) return this.destroy(err);
          stream = this._toStreams2(stream);

          this._attachErrorListener(stream);

          this._gotNextStream(stream);
        });
      } else {
        let stream = this._queue.shift();

        if (typeof stream === 'function') {
          stream = this._toStreams2(stream());

          this._attachErrorListener(stream);
        }

        this._gotNextStream(stream);
      }
    }
  }, {
    key: "_gotNextStream",
    value: function _gotNextStream(stream) {
      if (!stream) {
        this.push(null);
        return;
      }

      this._current = stream;

      this._forward();

      const onReadable = () => {
        this._forward();
      };

      const onClose = () => {
        if (!stream._readableState.ended && !stream.destroyed) {
          const err = new Error('ERR_STREAM_PREMATURE_CLOSE');
          err.code = 'ERR_STREAM_PREMATURE_CLOSE';
          this.destroy(err);
        }
      };

      const onEnd = () => {
        this._current = null;
        stream.removeListener('readable', onReadable);
        stream.removeListener('end', onEnd);
        stream.removeListener('close', onClose);
        stream.destroy();

        this._next();
      };

      stream.on('readable', onReadable);
      stream.once('end', onEnd);
      stream.once('close', onClose);
    }
  }, {
    key: "_attachErrorListener",
    value: function _attachErrorListener(stream) {
      if (!stream) return;

      const onError = err => {
        stream.removeListener('error', onError);
        this.destroy(err);
      };

      stream.once('error', onError);
    }
  }]);

  return MultiStream;
}(stream.Readable);

MultiStream.obj = streams => new MultiStream(streams, {
  objectMode: true,
  highWaterMark: 16
});

module.exports = MultiStream; // Normalize stream destroy w/ callback.

function destroy(stream, err, cb) {
  if (!stream.destroy || stream.destroyed) {
    cb(err);
  } else {
    const callback = once(er => cb(er || err));
    stream.on('error', callback).on('close', () => callback()).destroy(err, callback);
  }
}

/***/ }),

/***/ "./node_modules/next-event/index.js":
/*!******************************************!*\
  !*** ./node_modules/next-event/index.js ***!
  \******************************************/
/***/ ((module) => {

module.exports = nextEvent;

function nextEvent(emitter, name) {
  var next = null;
  emitter.on(name, function (data) {
    if (!next) return;
    var fn = next;
    next = null;
    fn(data);
  });
  return function (once) {
    next = once;
  };
}

/***/ }),

/***/ "./node_modules/parse-torrent/index.js":
/*!*********************************************!*\
  !*** ./node_modules/parse-torrent/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
/*! parse-torrent. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */

/* global Blob */
const bencode = __webpack_require__(/*! bencode */ "./node_modules/bencode/lib/index.js");

const blobToBuffer = __webpack_require__(/*! blob-to-buffer */ "./node_modules/blob-to-buffer/index.js");

const fs = __webpack_require__(/*! fs */ "?8539"); // browser exclude


const get = __webpack_require__(/*! simple-get */ "./node_modules/simple-get/index.js");

const magnet = __webpack_require__(/*! magnet-uri */ "./node_modules/magnet-uri/index.js");

const path = __webpack_require__(/*! path */ "./src/shims/path.ts");

const sha1 = __webpack_require__(/*! simple-sha1 */ "./node_modules/simple-sha1/browser.js");

const queueMicrotask = __webpack_require__(/*! queue-microtask */ "./node_modules/queue-microtask/index.js");

module.exports = parseTorrent;
module.exports.remote = parseTorrentRemote;
module.exports.toMagnetURI = magnet.encode;
module.exports.toTorrentFile = encodeTorrentFile;
/**
 * Parse a torrent identifier (magnet uri, .torrent file, info hash)
 * @param  {string|Buffer|Object} torrentId
 * @return {Object}
 */

function parseTorrent(torrentId) {
  if (typeof torrentId === 'string' && /^(stream-)?magnet:/.test(torrentId)) {
    // if magnet uri (string)
    const torrentObj = magnet(torrentId); // infoHash won't be defined if a non-bittorrent magnet is passed

    if (!torrentObj.infoHash) {
      throw new Error('Invalid torrent identifier');
    }

    return torrentObj;
  } else if (typeof torrentId === 'string' && (/^[a-f0-9]{40}$/i.test(torrentId) || /^[a-z2-7]{32}$/i.test(torrentId))) {
    // if info hash (hex/base-32 string)
    return magnet("magnet:?xt=urn:btih:".concat(torrentId));
  } else if (Buffer.isBuffer(torrentId) && torrentId.length === 20) {
    // if info hash (buffer)
    return magnet("magnet:?xt=urn:btih:".concat(torrentId.toString('hex')));
  } else if (Buffer.isBuffer(torrentId)) {
    // if .torrent file (buffer)
    return decodeTorrentFile(torrentId); // might throw
  } else if (torrentId && torrentId.infoHash) {
    // if parsed torrent (from `parse-torrent` or `magnet-uri`)
    torrentId.infoHash = torrentId.infoHash.toLowerCase();
    if (!torrentId.announce) torrentId.announce = [];

    if (typeof torrentId.announce === 'string') {
      torrentId.announce = [torrentId.announce];
    }

    if (!torrentId.urlList) torrentId.urlList = [];
    return torrentId;
  } else {
    throw new Error('Invalid torrent identifier');
  }
}

function parseTorrentRemote(torrentId, opts, cb) {
  if (typeof opts === 'function') return parseTorrentRemote(torrentId, {}, opts);
  if (typeof cb !== 'function') throw new Error('second argument must be a Function');
  let parsedTorrent;

  try {
    parsedTorrent = parseTorrent(torrentId);
  } catch (err) {// If torrent fails to parse, it could be a Blob, http/https URL or
    // filesystem path, so don't consider it an error yet.
  }

  if (parsedTorrent && parsedTorrent.infoHash) {
    queueMicrotask(() => {
      cb(null, parsedTorrent);
    });
  } else if (isBlob(torrentId)) {
    blobToBuffer(torrentId, (err, torrentBuf) => {
      if (err) return cb(new Error("Error converting Blob: ".concat(err.message)));
      parseOrThrow(torrentBuf);
    });
  } else if (typeof get === 'function' && /^https?:/.test(torrentId)) {
    // http, or https url to torrent file
    opts = Object.assign({
      url: torrentId,
      timeout: 30 * 1000,
      headers: {
        'user-agent': 'WebTorrent (https://webtorrent.io)'
      }
    }, opts);
    get.concat(opts, (err, res, torrentBuf) => {
      if (err) return cb(new Error("Error downloading torrent: ".concat(err.message)));
      parseOrThrow(torrentBuf);
    });
  } else if (typeof fs.readFile === 'function' && typeof torrentId === 'string') {
    // assume it's a filesystem path
    fs.readFile(torrentId, (err, torrentBuf) => {
      if (err) return cb(new Error('Invalid torrent identifier'));
      parseOrThrow(torrentBuf);
    });
  } else {
    queueMicrotask(() => {
      cb(new Error('Invalid torrent identifier'));
    });
  }

  function parseOrThrow(torrentBuf) {
    try {
      parsedTorrent = parseTorrent(torrentBuf);
    } catch (err) {
      return cb(err);
    }

    if (parsedTorrent && parsedTorrent.infoHash) cb(null, parsedTorrent);else cb(new Error('Invalid torrent identifier'));
  }
}
/**
 * Parse a torrent. Throws an exception if the torrent is missing required fields.
 * @param  {Buffer|Object} torrent
 * @return {Object}        parsed torrent
 */


function decodeTorrentFile(torrent) {
  if (Buffer.isBuffer(torrent)) {
    torrent = bencode.decode(torrent);
  } // sanity check


  ensure(torrent.info, 'info');
  ensure(torrent.info['name.utf-8'] || torrent.info.name, 'info.name');
  ensure(torrent.info['piece length'], 'info[\'piece length\']');
  ensure(torrent.info.pieces, 'info.pieces');

  if (torrent.info.files) {
    torrent.info.files.forEach(file => {
      ensure(typeof file.length === 'number', 'info.files[0].length');
      ensure(file['path.utf-8'] || file.path, 'info.files[0].path');
    });
  } else {
    ensure(typeof torrent.info.length === 'number', 'info.length');
  }

  const result = {
    info: torrent.info,
    infoBuffer: bencode.encode(torrent.info),
    name: (torrent.info['name.utf-8'] || torrent.info.name).toString(),
    announce: []
  };
  result.infoHash = sha1.sync(result.infoBuffer);
  result.infoHashBuffer = Buffer.from(result.infoHash, 'hex');
  if (torrent.info.private !== undefined) result.private = !!torrent.info.private;
  if (torrent['creation date']) result.created = new Date(torrent['creation date'] * 1000);
  if (torrent['created by']) result.createdBy = torrent['created by'].toString();
  if (Buffer.isBuffer(torrent.comment)) result.comment = torrent.comment.toString(); // announce and announce-list will be missing if metadata fetched via ut_metadata

  if (Array.isArray(torrent['announce-list']) && torrent['announce-list'].length > 0) {
    torrent['announce-list'].forEach(urls => {
      urls.forEach(url => {
        result.announce.push(url.toString());
      });
    });
  } else if (torrent.announce) {
    result.announce.push(torrent.announce.toString());
  } // handle url-list (BEP19 / web seeding)


  if (Buffer.isBuffer(torrent['url-list'])) {
    // some clients set url-list to empty string
    torrent['url-list'] = torrent['url-list'].length > 0 ? [torrent['url-list']] : [];
  }

  result.urlList = (torrent['url-list'] || []).map(url => url.toString()); // remove duplicates by converting to Set and back

  result.announce = Array.from(new Set(result.announce));
  result.urlList = Array.from(new Set(result.urlList));
  const files = torrent.info.files || [torrent.info];
  result.files = files.map((file, i) => {
    const parts = [].concat(result.name, file['path.utf-8'] || file.path || []).map(p => p.toString());
    return {
      path: path.join.apply(null, [path.sep].concat(parts)).slice(1),
      name: parts[parts.length - 1],
      length: file.length,
      offset: files.slice(0, i).reduce(sumLength, 0)
    };
  });
  result.length = files.reduce(sumLength, 0);
  const lastFile = result.files[result.files.length - 1];
  result.pieceLength = torrent.info['piece length'];
  result.lastPieceLength = (lastFile.offset + lastFile.length) % result.pieceLength || result.pieceLength;
  result.pieces = splitPieces(torrent.info.pieces);
  return result;
}
/**
 * Convert a parsed torrent object back into a .torrent file buffer.
 * @param  {Object} parsed parsed torrent
 * @return {Buffer}
 */


function encodeTorrentFile(parsed) {
  const torrent = {
    info: parsed.info
  };
  torrent['announce-list'] = (parsed.announce || []).map(url => {
    if (!torrent.announce) torrent.announce = url;
    url = Buffer.from(url, 'utf8');
    return [url];
  });
  torrent['url-list'] = parsed.urlList || [];

  if (parsed.private !== undefined) {
    torrent.private = Number(parsed.private);
  }

  if (parsed.created) {
    torrent['creation date'] = parsed.created.getTime() / 1000 | 0;
  }

  if (parsed.createdBy) {
    torrent['created by'] = parsed.createdBy;
  }

  if (parsed.comment) {
    torrent.comment = parsed.comment;
  }

  return bencode.encode(torrent);
}
/**
 * Check if `obj` is a W3C `Blob` or `File` object
 * @param  {*} obj
 * @return {boolean}
 */


function isBlob(obj) {
  return typeof Blob !== 'undefined' && obj instanceof Blob;
}

function sumLength(sum, file) {
  return sum + file.length;
}

function splitPieces(buf) {
  const pieces = [];

  for (let i = 0; i < buf.length; i += 20) {
    pieces.push(buf.slice(i, i + 20).toString('hex'));
  }

  return pieces;
}

function ensure(bool, fieldName) {
  if (!bool) throw new Error("Torrent is missing required field: ".concat(fieldName));
} // Workaround Browserify v13 bug
// https://github.com/substack/node-browserify/issues/1483


;

(() => {
  Buffer.alloc(0);
})();

/***/ }),

/***/ "./node_modules/piece-length/index.js":
/*!********************************************!*\
  !*** ./node_modules/piece-length/index.js ***!
  \********************************************/
/***/ ((module) => {

module.exports = length;

function length(bytes) {
  return Math.max(16384, 1 << Math.log2(bytes < 1024 ? 1 : bytes / 1024) + 0.5 | 0);
}

/***/ }),

/***/ "./node_modules/pump/index.js":
/*!************************************!*\
  !*** ./node_modules/pump/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");
var once = __webpack_require__(/*! once */ "./node_modules/once/once.js");

var eos = __webpack_require__(/*! end-of-stream */ "./node_modules/end-of-stream/index.js");

var fs = __webpack_require__(/*! fs */ "?7874"); // we only need fs to get the ReadStream and WriteStream prototypes


var noop = function () {};

var ancient = /^v?\.0/.test(process.version);

var isFn = function (fn) {
  return typeof fn === 'function';
};

var isFS = function (stream) {
  if (!ancient) return false; // newer node version do not need to care about fs is a special way

  if (!fs) return false; // browser

  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close);
};

var isRequest = function (stream) {
  return stream.setHeader && isFn(stream.abort);
};

var destroyer = function (stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;
    if (isFS(stream)) return stream.close(noop); // use close for fs streams to avoid fd leaks

    if (isRequest(stream)) return stream.abort(); // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy();
    callback(err || new Error('stream was destroyed'));
  };
};

var call = function (fn) {
  fn();
};

var pipe = function (from, to) {
  return from.pipe(to);
};

var pump = function () {
  var streams = Array.prototype.slice.call(arguments);
  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) throw new Error('pump requires two streams per minimum');
  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
};

module.exports = pump;

/***/ }),

/***/ "./node_modules/querystring/decode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/decode.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
 // If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function (qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1000;

  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length; // maxKeys <= 0 means that we should not limit keys count

  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

/***/ }),

/***/ "./node_modules/querystring/encode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/encode.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var stringifyPrimitive = function (v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';

  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;

      if (Array.isArray(obj[k])) {
        return obj[k].map(function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).filter(Boolean).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

/***/ }),

/***/ "./node_modules/querystring/index.js":
/*!*******************************************!*\
  !*** ./node_modules/querystring/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring/encode.js");

/***/ }),

/***/ "./node_modules/queue-tick/queue-microtask.js":
/*!****************************************************!*\
  !*** ./node_modules/queue-tick/queue-microtask.js ***!
  \****************************************************/
/***/ ((module) => {

module.exports = typeof queueMicrotask === 'function' ? queueMicrotask : fn => Promise.resolve().then(fn);

/***/ }),

/***/ "./node_modules/random-iterate/index.js":
/*!**********************************************!*\
  !*** ./node_modules/random-iterate/index.js ***!
  \**********************************************/
/***/ ((module) => {

var iterate = function (list) {
  var offset = 0;
  return function () {
    if (offset === list.length) return null;
    var len = list.length - offset;
    var i = Math.random() * len | 0;
    var el = list[offset + i];
    var tmp = list[offset];
    list[offset] = el;
    list[offset + i] = tmp;
    offset++;
    return el;
  };
};

module.exports = iterate;

/***/ }),

/***/ "./node_modules/range-parser/index.js":
/*!********************************************!*\
  !*** ./node_modules/range-parser/index.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

module.exports = rangeParser;
/**
 * Parse "Range" header `str` relative to the given file `size`.
 *
 * @param {Number} size
 * @param {String} str
 * @param {Object} [options]
 * @return {Array}
 * @public
 */

function rangeParser(size, str, options) {
  if (typeof str !== 'string') {
    throw new TypeError('argument str must be a string');
  }

  var index = str.indexOf('=');

  if (index === -1) {
    return -2;
  } // split the range string


  var arr = str.slice(index + 1).split(',');
  var ranges = []; // add ranges type

  ranges.type = str.slice(0, index); // parse all ranges

  for (var i = 0; i < arr.length; i++) {
    var range = arr[i].split('-');
    var start = parseInt(range[0], 10);
    var end = parseInt(range[1], 10); // -nnn

    if (isNaN(start)) {
      start = size - end;
      end = size - 1; // nnn-
    } else if (isNaN(end)) {
      end = size - 1;
    } // limit last-byte-pos to current length


    if (end > size - 1) {
      end = size - 1;
    } // invalid or unsatisifiable


    if (isNaN(start) || isNaN(end) || start > end || start < 0) {
      continue;
    } // add range


    ranges.push({
      start: start,
      end: end
    });
  }

  if (ranges.length < 1) {
    // unsatisifiable
    return -1;
  }

  return options && options.combine ? combineRanges(ranges) : ranges;
}
/**
 * Combine overlapping & adjacent ranges.
 * @private
 */


function combineRanges(ranges) {
  var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);

  for (var j = 0, i = 1; i < ordered.length; i++) {
    var range = ordered[i];
    var current = ordered[j];

    if (range.start > current.end + 1) {
      // next range
      ordered[++j] = range;
    } else if (range.end > current.end) {
      // extend range
      current.end = range.end;
      current.index = Math.min(current.index, range.index);
    }
  } // trim ordered array


  ordered.length = j + 1; // generate combined range

  var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex); // copy ranges type

  combined.type = ranges.type;
  return combined;
}
/**
 * Map function to add index value to ranges.
 * @private
 */


function mapWithIndex(range, index) {
  return {
    start: range.start,
    end: range.end,
    index: index
  };
}
/**
 * Map function to remove index value from ranges.
 * @private
 */


function mapWithoutIndex(range) {
  return {
    start: range.start,
    end: range.end
  };
}
/**
 * Sort function to sort ranges by index.
 * @private
 */


function sortByRangeIndex(a, b) {
  return a.index - b.index;
}
/**
 * Sort function to sort ranges by start position.
 * @private
 */


function sortByRangeStart(a, b) {
  return a.start - b.start;
}

/***/ }),

/***/ "./node_modules/range-slice-stream/index.js":
/*!**************************************************!*\
  !*** ./node_modules/range-slice-stream/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/*
Instance of writable stream.

call .get(length) or .discard(length) to get a stream (relative to the last end)

emits 'stalled' once everything is written

*/
const {
  Writable,
  PassThrough
} = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js");

let RangeSliceStream = /*#__PURE__*/function (_Writable) {
  _inherits(RangeSliceStream, _Writable);

  var _super = _createSuper(RangeSliceStream);

  function RangeSliceStream(offset) {
    var _this;

    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, RangeSliceStream);

    _this = _super.call(this, opts);
    _this.destroyed = false;
    _this._queue = [];
    _this._position = offset || 0;
    _this._cb = null;
    _this._buffer = null;
    _this._out = null;
    return _this;
  }

  _createClass(RangeSliceStream, [{
    key: "_write",
    value: function _write(chunk, encoding, cb) {
      let drained = true;

      while (true) {
        if (this.destroyed) {
          return;
        } // Wait for more queue entries


        if (this._queue.length === 0) {
          this._buffer = chunk;
          this._cb = cb;
          return;
        }

        this._buffer = null;
        var currRange = this._queue[0]; // Relative to the start of chunk, what data do we need?

        const writeStart = Math.max(currRange.start - this._position, 0);
        const writeEnd = currRange.end - this._position; // Check if we need to throw it all away

        if (writeStart >= chunk.length) {
          this._position += chunk.length;
          return cb(null);
        } // Check if we need to use it all


        let toWrite;

        if (writeEnd > chunk.length) {
          this._position += chunk.length;

          if (writeStart === 0) {
            toWrite = chunk;
          } else {
            toWrite = chunk.slice(writeStart);
          }

          drained = currRange.stream.write(toWrite) && drained;
          break;
        }

        this._position += writeEnd;
        toWrite = writeStart === 0 && writeEnd === chunk.length ? chunk : chunk.slice(writeStart, writeEnd);
        drained = currRange.stream.write(toWrite) && drained;

        if (currRange.last) {
          currRange.stream.end();
        }

        chunk = chunk.slice(writeEnd);

        this._queue.shift();
      }

      if (drained) {
        cb(null);
      } else {
        currRange.stream.once('drain', cb.bind(null, null));
      }
    }
  }, {
    key: "slice",
    value: function slice(ranges) {
      if (this.destroyed) return null;
      if (!Array.isArray(ranges)) ranges = [ranges];
      const str = new PassThrough();
      ranges.forEach((range, i) => {
        this._queue.push({
          start: range.start,
          end: range.end,
          stream: str,
          last: i === ranges.length - 1
        });
      });

      if (this._buffer) {
        this._write(this._buffer, null, this._cb);
      }

      return str;
    }
  }, {
    key: "destroy",
    value: function destroy(err) {
      if (this.destroyed) return;
      this.destroyed = true;
      if (err) this.emit('error', err);
    }
  }]);

  return RangeSliceStream;
}(Writable);

module.exports = RangeSliceStream;

/***/ }),

/***/ "./node_modules/rc4/rc4.js":
/*!*********************************!*\
  !*** ./node_modules/rc4/rc4.js ***!
  \*********************************/
/***/ ((module) => {

"use strict";
 // Based on RC4 algorithm, as described in
// http://en.wikipedia.org/wiki/RC4

function isInteger(n) {
  return parseInt(n, 10) === n;
}

function createRC4(N) {
  function identityPermutation() {
    var s = new Array(N);

    for (var i = 0; i < N; i++) {
      s[i] = i;
    }

    return s;
  } // :: string | array integer -> array integer


  function seed(key) {
    if (key === undefined) {
      key = new Array(N);

      for (var k = 0; k < N; k++) {
        key[k] = Math.floor(Math.random() * N);
      }
    } else if (typeof key === "string") {
      // to string
      key = "" + key;
      key = key.split("").map(function (c) {
        return c.charCodeAt(0) % N;
      });
    } else if (Array.isArray(key)) {
      if (!key.every(function (v) {
        return typeof v === "number" && v === (v | 0);
      })) {
        throw new TypeError("invalid seed key specified: not array of integers");
      }
    } else {
      throw new TypeError("invalid seed key specified");
    }

    var keylen = key.length; // resed state

    var s = identityPermutation();
    var j = 0;

    for (var i = 0; i < N; i++) {
      j = (j + s[i] + key[i % keylen]) % N;
      var tmp = s[i];
      s[i] = s[j];
      s[j] = tmp;
    }

    return s;
  }
  /* eslint-disable no-shadow */


  function RC4(key) {
    this.s = seed(key);
    this.i = 0;
    this.j = 0;
  }
  /* eslint-enable no-shadow */


  RC4.prototype.randomNative = function () {
    this.i = (this.i + 1) % N;
    this.j = (this.j + this.s[this.i]) % N;
    var tmp = this.s[this.i];
    this.s[this.i] = this.s[this.j];
    this.s[this.j] = tmp;
    var k = this.s[(this.s[this.i] + this.s[this.j]) % N];
    return k;
  };

  RC4.prototype.randomUInt32 = function () {
    var a = this.randomByte();
    var b = this.randomByte();
    var c = this.randomByte();
    var d = this.randomByte();
    return ((a * 256 + b) * 256 + c) * 256 + d;
  };

  RC4.prototype.randomFloat = function () {
    return this.randomUInt32() / 0x100000000;
  };

  RC4.prototype.random = function () {
    var a;
    var b;

    if (arguments.length === 1) {
      a = 0;
      b = arguments[0];
    } else if (arguments.length === 2) {
      a = arguments[0];
      b = arguments[1];
    } else {
      throw new TypeError("random takes one or two integer arguments");
    }

    if (!isInteger(a) || !isInteger(b)) {
      throw new TypeError("random takes one or two integer arguments");
    }

    return a + this.randomUInt32() % (b - a + 1);
  };

  RC4.prototype.currentState = function () {
    return {
      i: this.i,
      j: this.j,
      s: this.s.slice() // copy

    };
  };

  RC4.prototype.setState = function (state) {
    var s = state.s;
    var i = state.i;
    var j = state.j;
    /* eslint-disable yoda */

    if (!(i === (i | 0) && 0 <= i && i < N)) {
      throw new Error("state.i should be integer [0, " + (N - 1) + "]");
    }

    if (!(j === (j | 0) && 0 <= j && j < N)) {
      throw new Error("state.j should be integer [0, " + (N - 1) + "]");
    }
    /* eslint-enable yoda */
    // check length


    if (!Array.isArray(s) || s.length !== N) {
      throw new Error("state should be array of length " + N);
    } // check that all params are there


    for (var k = 0; k < N; k++) {
      if (s.indexOf(k) === -1) {
        throw new Error("state should be permutation of 0.." + (N - 1) + ": " + k + " is missing");
      }
    }

    this.i = i;
    this.j = j;
    this.s = s.slice(); // assign copy
  };

  return RC4;
}

var RC4 = createRC4(256);
RC4.prototype.randomByte = RC4.prototype.randomNative;
var RC4small = createRC4(16);

RC4small.prototype.randomByte = function () {
  var a = this.randomNative();
  var b = this.randomNative();
  return a * 16 + b;
};

var ordA = "a".charCodeAt(0);
var ord0 = "0".charCodeAt(0);

function toHex(n) {
  return n < 10 ? String.fromCharCode(ord0 + n) : String.fromCharCode(ordA + n - 10);
}

function fromHex(c) {
  return parseInt(c, 16);
}

RC4small.prototype.currentStateString = function () {
  var state = this.currentState();
  var i = toHex(state.i);
  var j = toHex(state.j);
  var res = i + j + state.s.map(toHex).join("");
  return res;
};

RC4small.prototype.setStateString = function (stateString) {
  if (!stateString.match(/^[0-9a-f]{18}$/)) {
    throw new TypeError("RC4small stateString should be 18 hex character string");
  }

  var i = fromHex(stateString[0]);
  var j = fromHex(stateString[1]);
  var s = stateString.split("").slice(2).map(fromHex);
  this.setState({
    i: i,
    j: j,
    s: s
  });
};

RC4.RC4small = RC4small;
module.exports = RC4;

/***/ }),

/***/ "./node_modules/render-media/index.js":
/*!********************************************!*\
  !*** ./node_modules/render-media/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*! render-media. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.render = render;
exports.append = append;
exports.mime = __webpack_require__(/*! ./lib/mime.json */ "./node_modules/render-media/lib/mime.json");

const debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")('render-media');

const isAscii = __webpack_require__(/*! is-ascii */ "./node_modules/is-ascii/index.js");

const MediaElementWrapper = __webpack_require__(/*! mediasource */ "./node_modules/mediasource/index.js");

const path = __webpack_require__(/*! path */ "./src/shims/path.ts");

const streamToBlobURL = __webpack_require__(/*! stream-to-blob-url */ "./node_modules/stream-to-blob-url/index.js");

const VideoStream = __webpack_require__(/*! videostream */ "./node_modules/videostream/videostream.js"); // Note: Everything listed in VIDEOSTREAM_EXTS should also appear in either
// MEDIASOURCE_VIDEO_EXTS or MEDIASOURCE_AUDIO_EXTS.


const VIDEOSTREAM_EXTS = ['.m4a', '.m4b', '.m4p', '.m4v', '.mp4'];
const MEDIASOURCE_VIDEO_EXTS = ['.m4v', '.mkv', '.mp4', '.webm'];
const MEDIASOURCE_AUDIO_EXTS = ['.m4a', '.m4b', '.m4p', '.mp3'];
const MEDIASOURCE_EXTS = [].concat(MEDIASOURCE_VIDEO_EXTS, MEDIASOURCE_AUDIO_EXTS);
const VIDEO_EXTS = ['.mov', '.ogv'];
const AUDIO_EXTS = ['.aac', '.oga', '.ogg', '.wav', '.flac'];
const IMAGE_EXTS = ['.bmp', '.gif', '.jpeg', '.jpg', '.png', '.svg'];
const IFRAME_EXTS = ['.css', '.html', '.js', '.md', '.pdf', '.srt', '.txt']; // Maximum file length for which the Blob URL strategy will be attempted
// See: https://github.com/feross/render-media/issues/18

const MAX_BLOB_LENGTH = 200 * 1000 * 1000; // 200 MB

const MediaSource = typeof window !== 'undefined' && window.MediaSource;

function render(file, elem, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts;
    opts = {};
  }

  if (!opts) opts = {};
  if (!cb) cb = () => {};
  validateFile(file);
  parseOpts(opts);
  if (typeof elem === 'string') elem = document.querySelector(elem);
  renderMedia(file, tagName => {
    if (elem.nodeName !== tagName.toUpperCase()) {
      const extname = path.extname(file.name).toLowerCase();
      throw new Error("Cannot render \"".concat(extname, "\" inside a \"").concat(elem.nodeName.toLowerCase(), "\" element, expected \"").concat(tagName, "\""));
    }

    if (tagName === 'video' || tagName === 'audio') setMediaOpts(elem, opts);
    return elem;
  }, opts, cb);
}

function append(file, rootElem, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts;
    opts = {};
  }

  if (!opts) opts = {};
  if (!cb) cb = () => {};
  validateFile(file);
  parseOpts(opts);
  if (typeof rootElem === 'string') rootElem = document.querySelector(rootElem);

  if (rootElem && (rootElem.nodeName === 'VIDEO' || rootElem.nodeName === 'AUDIO')) {
    throw new Error('Invalid video/audio node argument. Argument must be root element that ' + 'video/audio tag will be appended to.');
  }

  renderMedia(file, getElem, opts, done);

  function getElem(tagName) {
    if (tagName === 'video' || tagName === 'audio') return createMedia(tagName);else return createElem(tagName);
  }

  function createMedia(tagName) {
    const elem = createElem(tagName);
    setMediaOpts(elem, opts);
    rootElem.appendChild(elem);
    return elem;
  }

  function createElem(tagName) {
    const elem = document.createElement(tagName);
    rootElem.appendChild(elem);
    return elem;
  }

  function done(err, elem) {
    if (err && elem) elem.remove();
    cb(err, elem);
  }
}

function renderMedia(file, getElem, opts, cb) {
  const extname = path.extname(file.name).toLowerCase();
  let currentTime = 0;
  let elem;

  if (MEDIASOURCE_EXTS.includes(extname)) {
    renderMediaSource();
  } else if (VIDEO_EXTS.includes(extname)) {
    renderMediaElement('video');
  } else if (AUDIO_EXTS.includes(extname)) {
    renderMediaElement('audio');
  } else if (IMAGE_EXTS.includes(extname)) {
    renderImage();
  } else if (IFRAME_EXTS.includes(extname)) {
    renderIframe();
  } else {
    tryRenderIframe();
  }

  function renderMediaSource() {
    const tagName = MEDIASOURCE_VIDEO_EXTS.includes(extname) ? 'video' : 'audio';

    if (MediaSource) {
      if (VIDEOSTREAM_EXTS.includes(extname)) {
        useVideostream();
      } else {
        useMediaSource();
      }
    } else {
      useBlobURL();
    }

    function useVideostream() {
      debug("Use `videostream` package for ".concat(file.name));
      prepareElem();
      elem.addEventListener('error', fallbackToMediaSource);
      elem.addEventListener('loadstart', onLoadStart);
      elem.addEventListener('loadedmetadata', onLoadedMetadata);
      new VideoStream(file, elem);
      /* eslint-disable-line no-new */
    }

    function useMediaSource() {
      debug("Use MediaSource API for ".concat(file.name));
      prepareElem();
      elem.addEventListener('error', fallbackToBlobURL);
      elem.addEventListener('loadstart', onLoadStart);
      elem.addEventListener('loadedmetadata', onLoadedMetadata);
      const wrapper = new MediaElementWrapper(elem);
      const writable = wrapper.createWriteStream(getCodec(file.name));
      file.createReadStream().pipe(writable);
      if (currentTime) elem.currentTime = currentTime;
    }

    function useBlobURL() {
      debug("Use Blob URL for ".concat(file.name));
      prepareElem();
      elem.addEventListener('error', fatalError);
      elem.addEventListener('loadstart', onLoadStart);
      elem.addEventListener('loadedmetadata', onLoadedMetadata);
      getBlobURL(file, (err, url) => {
        if (err) return fatalError(err);
        elem.src = url;
        if (currentTime) elem.currentTime = currentTime;
      });
    }

    function fallbackToMediaSource(err) {
      debug('videostream error: fallback to MediaSource API: %o', err.message || err);
      elem.removeEventListener('error', fallbackToMediaSource);
      elem.removeEventListener('loadedmetadata', onLoadedMetadata);
      useMediaSource();
    }

    function fallbackToBlobURL(err) {
      debug('MediaSource API error: fallback to Blob URL: %o', err.message || err);
      if (!checkBlobLength()) return;
      elem.removeEventListener('error', fallbackToBlobURL);
      elem.removeEventListener('loadedmetadata', onLoadedMetadata);
      useBlobURL();
    }

    function prepareElem() {
      if (!elem) {
        elem = getElem(tagName);
        elem.addEventListener('progress', () => {
          currentTime = elem.currentTime;
        });
      }
    }
  }

  function checkBlobLength() {
    if (typeof file.length === 'number' && file.length > opts.maxBlobLength) {
      debug('File length too large for Blob URL approach: %d (max: %d)', file.length, opts.maxBlobLength);
      fatalError(new Error("File length too large for Blob URL approach: ".concat(file.length, " (max: ").concat(opts.maxBlobLength, ")")));
      return false;
    }

    return true;
  }

  function renderMediaElement(type) {
    if (!checkBlobLength()) return;
    elem = getElem(type);
    getBlobURL(file, (err, url) => {
      if (err) return fatalError(err);
      elem.addEventListener('error', fatalError);
      elem.addEventListener('loadstart', onLoadStart);
      elem.addEventListener('loadedmetadata', onLoadedMetadata);
      elem.src = url;
    });
  }

  function onLoadStart() {
    elem.removeEventListener('loadstart', onLoadStart);

    if (opts.autoplay) {
      const playPromise = elem.play();
      if (typeof playPromise !== 'undefined') playPromise.catch(fatalError);
    }
  }

  function onLoadedMetadata() {
    elem.removeEventListener('loadedmetadata', onLoadedMetadata);
    cb(null, elem);
  }

  function renderImage() {
    elem = getElem('img');
    getBlobURL(file, (err, url) => {
      if (err) return fatalError(err);
      elem.src = url;
      elem.alt = file.name;
      cb(null, elem);
    });
  }

  function renderIframe() {
    getBlobURL(file, (err, url) => {
      if (err) return fatalError(err);

      if (extname !== '.pdf') {
        // Render iframe
        elem = getElem('iframe');
        elem.sandbox = 'allow-forms allow-scripts';
        elem.src = url;
      } else {
        // Render .pdf
        elem = getElem('object'); // Firefox-only: `typemustmatch` keeps the embedded file from running unless
        // its content type matches the specified `type` attribute

        elem.setAttribute('typemustmatch', true);
        elem.setAttribute('type', 'application/pdf');
        elem.setAttribute('data', url);
      }

      cb(null, elem);
    });
  }

  function tryRenderIframe() {
    debug('Unknown file extension "%s" - will attempt to render into iframe', extname);
    let str = '';
    file.createReadStream({
      start: 0,
      end: 1000
    }).setEncoding('utf8').on('data', chunk => {
      str += chunk;
    }).on('end', done).on('error', cb);

    function done() {
      if (isAscii(str)) {
        debug('File extension "%s" appears ascii, so will render.', extname);
        renderIframe();
      } else {
        debug('File extension "%s" appears non-ascii, will not render.', extname);
        cb(new Error("Unsupported file type \"".concat(extname, "\": Cannot append to DOM")));
      }
    }
  }

  function fatalError(err) {
    err.message = "Error rendering file \"".concat(file.name, "\": ").concat(err.message);
    debug(err.message);
    cb(err);
  }
}

function getBlobURL(file, cb) {
  const extname = path.extname(file.name).toLowerCase();
  streamToBlobURL(file.createReadStream(), exports.mime[extname]).then(blobUrl => cb(null, blobUrl), err => cb(err));
}

function validateFile(file) {
  if (file == null) {
    throw new Error('file cannot be null or undefined');
  }

  if (typeof file.name !== 'string') {
    throw new Error('missing or invalid file.name property');
  }

  if (typeof file.createReadStream !== 'function') {
    throw new Error('missing or invalid file.createReadStream property');
  }
}

function getCodec(name) {
  const extname = path.extname(name).toLowerCase();
  return {
    '.m4a': 'audio/mp4; codecs="mp4a.40.5"',
    '.m4b': 'audio/mp4; codecs="mp4a.40.5"',
    '.m4p': 'audio/mp4; codecs="mp4a.40.5"',
    '.m4v': 'video/mp4; codecs="avc1.640029, mp4a.40.5"',
    '.mkv': 'video/webm; codecs="avc1.640029, mp4a.40.5"',
    '.mp3': 'audio/mpeg',
    '.mp4': 'video/mp4; codecs="avc1.640029, mp4a.40.5"',
    '.webm': 'video/webm; codecs="vorbis, vp8"'
  }[extname];
}

function parseOpts(opts) {
  if (opts.autoplay == null) opts.autoplay = false;
  if (opts.muted == null) opts.muted = false;
  if (opts.controls == null) opts.controls = true;
  if (opts.maxBlobLength == null) opts.maxBlobLength = MAX_BLOB_LENGTH;
}

function setMediaOpts(elem, opts) {
  elem.autoplay = !!opts.autoplay;
  elem.muted = !!opts.muted;
  elem.controls = !!opts.controls;
}

/***/ }),

/***/ "./node_modules/run-parallel-limit/index.js":
/*!**************************************************!*\
  !*** ./node_modules/run-parallel-limit/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*! run-parallel-limit. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
module.exports = runParallelLimit;

const queueMicrotask = __webpack_require__(/*! queue-microtask */ "./node_modules/queue-microtask/index.js");

function runParallelLimit(tasks, limit, cb) {
  if (typeof limit !== 'number') throw new Error('second argument must be a Number');
  let results, len, pending, keys, isErrored;
  let isSync = true;
  let next;

  if (Array.isArray(tasks)) {
    results = [];
    pending = len = tasks.length;
  } else {
    keys = Object.keys(tasks);
    results = {};
    pending = len = keys.length;
  }

  function done(err) {
    function end() {
      if (cb) cb(err, results);
      cb = null;
    }

    if (isSync) queueMicrotask(end);else end();
  }

  function each(i, err, result) {
    results[i] = result;
    if (err) isErrored = true;

    if (--pending === 0 || err) {
      done(err);
    } else if (!isErrored && next < len) {
      let key;

      if (keys) {
        key = keys[next];
        next += 1;
        tasks[key](function (err, result) {
          each(key, err, result);
        });
      } else {
        key = next;
        next += 1;
        tasks[key](function (err, result) {
          each(key, err, result);
        });
      }
    }
  }

  next = limit;

  if (!pending) {
    // empty
    done(null);
  } else if (keys) {
    // object
    keys.some(function (key, i) {
      tasks[key](function (err, result) {
        each(key, err, result);
      });
      if (i === limit - 1) return true; // early return

      return false;
    });
  } else {
    // array
    tasks.some(function (task, i) {
      task(function (err, result) {
        each(i, err, result);
      });
      if (i === limit - 1) return true; // early return

      return false;
    });
  }

  isSync = false;
}

/***/ }),

/***/ "./node_modules/rusha/dist/rusha.js":
/*!******************************************!*\
  !*** ./node_modules/rusha/dist/rusha.js ***!
  \******************************************/
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
  if (true) module.exports = factory();else {}
})(typeof self !== 'undefined' ? self : this, function () {
  return (
    /******/
    function (modules) {
      // webpackBootstrap

      /******/
      // The module cache

      /******/
      var installedModules = {};
      /******/

      /******/
      // The require function

      /******/

      function __nested_webpack_require_634__(moduleId) {
        /******/

        /******/
        // Check if module is in cache

        /******/
        if (installedModules[moduleId]) {
          /******/
          return installedModules[moduleId].exports;
          /******/
        }
        /******/
        // Create a new module (and put it into the cache)

        /******/


        var module = installedModules[moduleId] = {
          /******/
          i: moduleId,

          /******/
          l: false,

          /******/
          exports: {}
          /******/

        };
        /******/

        /******/
        // Execute the module function

        /******/

        modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_634__);
        /******/

        /******/
        // Flag the module as loaded

        /******/

        module.l = true;
        /******/

        /******/
        // Return the exports of the module

        /******/

        return module.exports;
        /******/
      }
      /******/

      /******/

      /******/
      // expose the modules object (__webpack_modules__)

      /******/


      __nested_webpack_require_634__.m = modules;
      /******/

      /******/
      // expose the module cache

      /******/

      __nested_webpack_require_634__.c = installedModules;
      /******/

      /******/
      // define getter function for harmony exports

      /******/

      __nested_webpack_require_634__.d = function (exports, name, getter) {
        /******/
        if (!__nested_webpack_require_634__.o(exports, name)) {
          /******/
          Object.defineProperty(exports, name, {
            /******/
            configurable: false,

            /******/
            enumerable: true,

            /******/
            get: getter
            /******/

          });
          /******/
        }
        /******/

      };
      /******/

      /******/
      // getDefaultExport function for compatibility with non-harmony modules

      /******/


      __nested_webpack_require_634__.n = function (module) {
        /******/
        var getter = module && module.__esModule ?
        /******/
        function getDefault() {
          return module['default'];
        } :
        /******/
        function getModuleExports() {
          return module;
        };
        /******/

        __nested_webpack_require_634__.d(getter, 'a', getter);
        /******/


        return getter;
        /******/
      };
      /******/

      /******/
      // Object.prototype.hasOwnProperty.call

      /******/


      __nested_webpack_require_634__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/

      /******/
      // __webpack_public_path__

      /******/


      __nested_webpack_require_634__.p = "";
      /******/

      /******/
      // Load entry module and return exports

      /******/

      return __nested_webpack_require_634__(__nested_webpack_require_634__.s = 3);
      /******/
    }
    /************************************************************************/

    /******/
    ([
    /* 0 */

    /***/
    function (module, exports, __nested_webpack_require_3758__) {
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      /* eslint-env commonjs, browser */


      var RushaCore = __nested_webpack_require_3758__(5);

      var _require = __nested_webpack_require_3758__(1),
          toHex = _require.toHex,
          ceilHeapSize = _require.ceilHeapSize;

      var conv = __nested_webpack_require_3758__(6); // Calculate the length of buffer that the sha1 routine uses
      // including the padding.


      var padlen = function (len) {
        for (len += 9; len % 64 > 0; len += 1) {}

        return len;
      };

      var padZeroes = function (bin, len) {
        var h8 = new Uint8Array(bin.buffer);
        var om = len % 4,
            align = len - om;

        switch (om) {
          case 0:
            h8[align + 3] = 0;

          case 1:
            h8[align + 2] = 0;

          case 2:
            h8[align + 1] = 0;

          case 3:
            h8[align + 0] = 0;
        }

        for (var i = (len >> 2) + 1; i < bin.length; i++) {
          bin[i] = 0;
        }
      };

      var padData = function (bin, chunkLen, msgLen) {
        bin[chunkLen >> 2] |= 0x80 << 24 - (chunkLen % 4 << 3); // To support msgLen >= 2 GiB, use a float division when computing the
        // high 32-bits of the big-endian message length in bits.

        bin[((chunkLen >> 2) + 2 & ~0x0f) + 14] = msgLen / (1 << 29) | 0;
        bin[((chunkLen >> 2) + 2 & ~0x0f) + 15] = msgLen << 3;
      };

      var getRawDigest = function (heap, padMaxChunkLen) {
        var io = new Int32Array(heap, padMaxChunkLen + 320, 5);
        var out = new Int32Array(5);
        var arr = new DataView(out.buffer);
        arr.setInt32(0, io[0], false);
        arr.setInt32(4, io[1], false);
        arr.setInt32(8, io[2], false);
        arr.setInt32(12, io[3], false);
        arr.setInt32(16, io[4], false);
        return out;
      };

      var Rusha = function () {
        function Rusha(chunkSize) {
          _classCallCheck(this, Rusha);

          chunkSize = chunkSize || 64 * 1024;

          if (chunkSize % 64 > 0) {
            throw new Error('Chunk size must be a multiple of 128 bit');
          }

          this._offset = 0;
          this._maxChunkLen = chunkSize;
          this._padMaxChunkLen = padlen(chunkSize); // The size of the heap is the sum of:
          // 1. The padded input message size
          // 2. The extended space the algorithm needs (320 byte)
          // 3. The 160 bit state the algoritm uses

          this._heap = new ArrayBuffer(ceilHeapSize(this._padMaxChunkLen + 320 + 20));
          this._h32 = new Int32Array(this._heap);
          this._h8 = new Int8Array(this._heap);
          this._core = new RushaCore({
            Int32Array: Int32Array
          }, {}, this._heap);
        }

        Rusha.prototype._initState = function _initState(heap, padMsgLen) {
          this._offset = 0;
          var io = new Int32Array(heap, padMsgLen + 320, 5);
          io[0] = 1732584193;
          io[1] = -271733879;
          io[2] = -1732584194;
          io[3] = 271733878;
          io[4] = -1009589776;
        };

        Rusha.prototype._padChunk = function _padChunk(chunkLen, msgLen) {
          var padChunkLen = padlen(chunkLen);
          var view = new Int32Array(this._heap, 0, padChunkLen >> 2);
          padZeroes(view, chunkLen);
          padData(view, chunkLen, msgLen);
          return padChunkLen;
        };

        Rusha.prototype._write = function _write(data, chunkOffset, chunkLen, off) {
          conv(data, this._h8, this._h32, chunkOffset, chunkLen, off || 0);
        };

        Rusha.prototype._coreCall = function _coreCall(data, chunkOffset, chunkLen, msgLen, finalize) {
          var padChunkLen = chunkLen;

          this._write(data, chunkOffset, chunkLen);

          if (finalize) {
            padChunkLen = this._padChunk(chunkLen, msgLen);
          }

          this._core.hash(padChunkLen, this._padMaxChunkLen);
        };

        Rusha.prototype.rawDigest = function rawDigest(str) {
          var msgLen = str.byteLength || str.length || str.size || 0;

          this._initState(this._heap, this._padMaxChunkLen);

          var chunkOffset = 0,
              chunkLen = this._maxChunkLen;

          for (chunkOffset = 0; msgLen > chunkOffset + chunkLen; chunkOffset += chunkLen) {
            this._coreCall(str, chunkOffset, chunkLen, msgLen, false);
          }

          this._coreCall(str, chunkOffset, msgLen - chunkOffset, msgLen, true);

          return getRawDigest(this._heap, this._padMaxChunkLen);
        };

        Rusha.prototype.digest = function digest(str) {
          return toHex(this.rawDigest(str).buffer);
        };

        Rusha.prototype.digestFromString = function digestFromString(str) {
          return this.digest(str);
        };

        Rusha.prototype.digestFromBuffer = function digestFromBuffer(str) {
          return this.digest(str);
        };

        Rusha.prototype.digestFromArrayBuffer = function digestFromArrayBuffer(str) {
          return this.digest(str);
        };

        Rusha.prototype.resetState = function resetState() {
          this._initState(this._heap, this._padMaxChunkLen);

          return this;
        };

        Rusha.prototype.append = function append(chunk) {
          var chunkOffset = 0;
          var chunkLen = chunk.byteLength || chunk.length || chunk.size || 0;
          var turnOffset = this._offset % this._maxChunkLen;
          var inputLen = void 0;
          this._offset += chunkLen;

          while (chunkOffset < chunkLen) {
            inputLen = Math.min(chunkLen - chunkOffset, this._maxChunkLen - turnOffset);

            this._write(chunk, chunkOffset, inputLen, turnOffset);

            turnOffset += inputLen;
            chunkOffset += inputLen;

            if (turnOffset === this._maxChunkLen) {
              this._core.hash(this._maxChunkLen, this._padMaxChunkLen);

              turnOffset = 0;
            }
          }

          return this;
        };

        Rusha.prototype.getState = function getState() {
          var turnOffset = this._offset % this._maxChunkLen;
          var heap = void 0;

          if (!turnOffset) {
            var io = new Int32Array(this._heap, this._padMaxChunkLen + 320, 5);
            heap = io.buffer.slice(io.byteOffset, io.byteOffset + io.byteLength);
          } else {
            heap = this._heap.slice(0);
          }

          return {
            offset: this._offset,
            heap: heap
          };
        };

        Rusha.prototype.setState = function setState(state) {
          this._offset = state.offset;

          if (state.heap.byteLength === 20) {
            var io = new Int32Array(this._heap, this._padMaxChunkLen + 320, 5);
            io.set(new Int32Array(state.heap));
          } else {
            this._h32.set(new Int32Array(state.heap));
          }

          return this;
        };

        Rusha.prototype.rawEnd = function rawEnd() {
          var msgLen = this._offset;
          var chunkLen = msgLen % this._maxChunkLen;

          var padChunkLen = this._padChunk(chunkLen, msgLen);

          this._core.hash(padChunkLen, this._padMaxChunkLen);

          var result = getRawDigest(this._heap, this._padMaxChunkLen);

          this._initState(this._heap, this._padMaxChunkLen);

          return result;
        };

        Rusha.prototype.end = function end() {
          return toHex(this.rawEnd().buffer);
        };

        return Rusha;
      }();

      module.exports = Rusha;
      module.exports._core = RushaCore;
      /***/
    },
    /* 1 */

    /***/
    function (module, exports) {
      /* eslint-env commonjs, browser */
      //
      // toHex
      //
      var precomputedHex = new Array(256);

      for (var i = 0; i < 256; i++) {
        precomputedHex[i] = (i < 0x10 ? '0' : '') + i.toString(16);
      }

      module.exports.toHex = function (arrayBuffer) {
        var binarray = new Uint8Array(arrayBuffer);
        var res = new Array(arrayBuffer.byteLength);

        for (var _i = 0; _i < res.length; _i++) {
          res[_i] = precomputedHex[binarray[_i]];
        }

        return res.join('');
      }; //
      // ceilHeapSize
      //


      module.exports.ceilHeapSize = function (v) {
        // The asm.js spec says:
        // The heap object's byteLength must be either
        // 2^n for n in [12, 24) or 2^24 * n for n ≥ 1.
        // Also, byteLengths smaller than 2^16 are deprecated.
        var p = 0; // If v is smaller than 2^16, the smallest possible solution
        // is 2^16.

        if (v <= 65536) return 65536; // If v < 2^24, we round up to 2^n,
        // otherwise we round up to 2^24 * n.

        if (v < 16777216) {
          for (p = 1; p < v; p = p << 1) {}
        } else {
          for (p = 16777216; p < v; p += 16777216) {}
        }

        return p;
      }; //
      // isDedicatedWorkerScope
      //


      module.exports.isDedicatedWorkerScope = function (self) {
        var isRunningInWorker = 'WorkerGlobalScope' in self && self instanceof self.WorkerGlobalScope;
        var isRunningInSharedWorker = 'SharedWorkerGlobalScope' in self && self instanceof self.SharedWorkerGlobalScope;
        var isRunningInServiceWorker = 'ServiceWorkerGlobalScope' in self && self instanceof self.ServiceWorkerGlobalScope; // Detects whether we run inside a dedicated worker or not.
        //
        // We can't just check for `DedicatedWorkerGlobalScope`, since IE11
        // has a bug where it only supports `WorkerGlobalScope`.
        //
        // Therefore, we consider us as running inside a dedicated worker
        // when we are running inside a worker, but not in a shared or service worker.
        //
        // When new types of workers are introduced, we will need to adjust this code.

        return isRunningInWorker && !isRunningInSharedWorker && !isRunningInServiceWorker;
      };
      /***/

    },
    /* 2 */

    /***/
    function (module, exports, __nested_webpack_require_13886__) {
      /* eslint-env commonjs, worker */
      module.exports = function () {
        var Rusha = __nested_webpack_require_13886__(0);

        var hashData = function (hasher, data, cb) {
          try {
            return cb(null, hasher.digest(data));
          } catch (e) {
            return cb(e);
          }
        };

        var hashFile = function (hasher, readTotal, blockSize, file, cb) {
          var reader = new self.FileReader();

          reader.onloadend = function onloadend() {
            if (reader.error) {
              return cb(reader.error);
            }

            var buffer = reader.result;
            readTotal += reader.result.byteLength;

            try {
              hasher.append(buffer);
            } catch (e) {
              cb(e);
              return;
            }

            if (readTotal < file.size) {
              hashFile(hasher, readTotal, blockSize, file, cb);
            } else {
              cb(null, hasher.end());
            }
          };

          reader.readAsArrayBuffer(file.slice(readTotal, readTotal + blockSize));
        };

        var workerBehaviourEnabled = true;

        self.onmessage = function (event) {
          if (!workerBehaviourEnabled) {
            return;
          }

          var data = event.data.data,
              file = event.data.file,
              id = event.data.id;
          if (typeof id === 'undefined') return;
          if (!file && !data) return;
          var blockSize = event.data.blockSize || 4 * 1024 * 1024;
          var hasher = new Rusha(blockSize);
          hasher.resetState();

          var done = function (err, hash) {
            if (!err) {
              self.postMessage({
                id: id,
                hash: hash
              });
            } else {
              self.postMessage({
                id: id,
                error: err.name
              });
            }
          };

          if (data) hashData(hasher, data, done);
          if (file) hashFile(hasher, 0, blockSize, file, done);
        };

        return function () {
          workerBehaviourEnabled = false;
        };
      };
      /***/

    },
    /* 3 */

    /***/
    function (module, exports, __nested_webpack_require_16121__) {
      /* eslint-env commonjs, browser */
      var work = __nested_webpack_require_16121__(4);

      var Rusha = __nested_webpack_require_16121__(0);

      var createHash = __nested_webpack_require_16121__(7);

      var runWorker = __nested_webpack_require_16121__(2);

      var _require = __nested_webpack_require_16121__(1),
          isDedicatedWorkerScope = _require.isDedicatedWorkerScope;

      var isRunningInDedicatedWorker = typeof self !== 'undefined' && isDedicatedWorkerScope(self);
      Rusha.disableWorkerBehaviour = isRunningInDedicatedWorker ? runWorker() : function () {};

      Rusha.createWorker = function () {
        var worker = work(
        /*require.resolve*/
        2);
        var terminate = worker.terminate;

        worker.terminate = function () {
          URL.revokeObjectURL(worker.objectURL);
          terminate.call(worker);
        };

        return worker;
      };

      Rusha.createHash = createHash;
      module.exports = Rusha;
      /***/
    },
    /* 4 */

    /***/
    function (module, exports, __nested_webpack_require_17136__) {
      function webpackBootstrapFunc(modules) {
        /******/
        // The module cache

        /******/
        var installedModules = {};
        /******/
        // The require function

        /******/

        function __nested_webpack_require_17380__(moduleId) {
          /******/
          // Check if module is in cache

          /******/
          if (installedModules[moduleId])
            /******/
            return installedModules[moduleId].exports;
          /******/
          // Create a new module (and put it into the cache)

          /******/

          var module = installedModules[moduleId] = {
            /******/
            i: moduleId,

            /******/
            l: false,

            /******/
            exports: {}
            /******/

          };
          /******/
          // Execute the module function

          /******/

          modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_17380__);
          /******/
          // Flag the module as loaded

          /******/

          module.l = true;
          /******/
          // Return the exports of the module

          /******/

          return module.exports;
          /******/
        }
        /******/
        // expose the modules object (__webpack_modules__)

        /******/


        __nested_webpack_require_17380__.m = modules;
        /******/
        // expose the module cache

        /******/

        __nested_webpack_require_17380__.c = installedModules;
        /******/
        // identity function for calling harmony imports with the correct context

        /******/

        __nested_webpack_require_17380__.i = function (value) {
          return value;
        };
        /******/
        // define getter function for harmony exports

        /******/


        __nested_webpack_require_17380__.d = function (exports, name, getter) {
          /******/
          if (!__nested_webpack_require_17380__.o(exports, name)) {
            /******/
            Object.defineProperty(exports, name, {
              /******/
              configurable: false,

              /******/
              enumerable: true,

              /******/
              get: getter
              /******/

            });
            /******/
          }
          /******/

        };
        /******/
        // define __esModule on exports

        /******/


        __nested_webpack_require_17380__.r = function (exports) {
          /******/
          Object.defineProperty(exports, '__esModule', {
            value: true
          });
          /******/
        };
        /******/
        // getDefaultExport function for compatibility with non-harmony modules

        /******/


        __nested_webpack_require_17380__.n = function (module) {
          /******/
          var getter = module && module.__esModule ?
          /******/
          function getDefault() {
            return module['default'];
          } :
          /******/
          function getModuleExports() {
            return module;
          };
          /******/

          __nested_webpack_require_17380__.d(getter, 'a', getter);
          /******/


          return getter;
          /******/
        };
        /******/
        // Object.prototype.hasOwnProperty.call

        /******/


        __nested_webpack_require_17380__.o = function (object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        /******/
        // __webpack_public_path__

        /******/


        __nested_webpack_require_17380__.p = "/";
        /******/
        // on error function for async loading

        /******/

        __nested_webpack_require_17380__.oe = function (err) {
          console.error(err);
          throw err;
        };

        var f = __nested_webpack_require_17380__(__nested_webpack_require_17380__.s = ENTRY_MODULE);

        return f.default || f; // try to call default if defined to also support babel esmodule exports
      }

      var moduleNameReqExp = '[\\.|\\-|\\+|\\w|\/|@]+';
      var dependencyRegExp = '\\((\/\\*.*?\\*\/)?\s?.*?(' + moduleNameReqExp + ').*?\\)'; // additional chars when output.pathinfo is true
      // http://stackoverflow.com/a/2593661/130442

      function quoteRegExp(str) {
        return (str + '').replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&');
      }

      function getModuleDependencies(sources, module, queueName) {
        var retval = {};
        retval[queueName] = [];
        var fnString = module.toString();
        var wrapperSignature = fnString.match(/^function\s?\(\w+,\s*\w+,\s*(\w+)\)/);
        if (!wrapperSignature) return retval;
        var webpackRequireName = wrapperSignature[1]; // main bundle deps

        var re = new RegExp('(\\\\n|\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g');
        var match;

        while (match = re.exec(fnString)) {
          if (match[3] === 'dll-reference') continue;
          retval[queueName].push(match[3]);
        } // dll deps


        re = new RegExp('\\(' + quoteRegExp(webpackRequireName) + '\\("(dll-reference\\s(' + moduleNameReqExp + '))"\\)\\)' + dependencyRegExp, 'g');

        while (match = re.exec(fnString)) {
          if (!sources[match[2]]) {
            retval[queueName].push(match[1]);
            sources[match[2]] = __nested_webpack_require_17136__(match[1]).m;
          }

          retval[match[2]] = retval[match[2]] || [];
          retval[match[2]].push(match[4]);
        }

        return retval;
      }

      function hasValuesInQueues(queues) {
        var keys = Object.keys(queues);
        return keys.reduce(function (hasValues, key) {
          return hasValues || queues[key].length > 0;
        }, false);
      }

      function getRequiredModules(sources, moduleId) {
        var modulesQueue = {
          main: [moduleId]
        };
        var requiredModules = {
          main: []
        };
        var seenModules = {
          main: {}
        };

        while (hasValuesInQueues(modulesQueue)) {
          var queues = Object.keys(modulesQueue);

          for (var i = 0; i < queues.length; i++) {
            var queueName = queues[i];
            var queue = modulesQueue[queueName];
            var moduleToCheck = queue.pop();
            seenModules[queueName] = seenModules[queueName] || {};
            if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue;
            seenModules[queueName][moduleToCheck] = true;
            requiredModules[queueName] = requiredModules[queueName] || [];
            requiredModules[queueName].push(moduleToCheck);
            var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName);
            var newModulesKeys = Object.keys(newModules);

            for (var j = 0; j < newModulesKeys.length; j++) {
              modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || [];
              modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]]);
            }
          }
        }

        return requiredModules;
      }

      module.exports = function (moduleId, options) {
        options = options || {};
        var sources = {
          main: __nested_webpack_require_17136__.m
        };
        var requiredModules = options.all ? {
          main: Object.keys(sources)
        } : getRequiredModules(sources, moduleId);
        var src = '';
        Object.keys(requiredModules).filter(function (m) {
          return m !== 'main';
        }).forEach(function (module) {
          var entryModule = 0;

          while (requiredModules[module][entryModule]) {
            entryModule++;
          }

          requiredModules[module].push(entryModule);
          sources[module][entryModule] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })';
          src = src + 'var ' + module + ' = (' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(entryModule)) + ')({' + requiredModules[module].map(function (id) {
            return '' + JSON.stringify(id) + ': ' + sources[module][id].toString();
          }).join(',') + '});\n';
        });
        src = src + '(' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(moduleId)) + ')({' + requiredModules.main.map(function (id) {
          return '' + JSON.stringify(id) + ': ' + sources.main[id].toString();
        }).join(',') + '})(self);';
        var blob = new window.Blob([src], {
          type: 'text/javascript'
        });

        if (options.bare) {
          return blob;
        }

        var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
        var workerUrl = URL.createObjectURL(blob);
        var worker = new window.Worker(workerUrl);
        worker.objectURL = workerUrl;
        return worker;
      };
      /***/

    },
    /* 5 */

    /***/
    function (module, exports) {
      // The low-level RushCore module provides the heart of Rusha,
      // a high-speed sha1 implementation working on an Int32Array heap.
      // At first glance, the implementation seems complicated, however
      // with the SHA1 spec at hand, it is obvious this almost a textbook
      // implementation that has a few functions hand-inlined and a few loops
      // hand-unrolled.
      module.exports = function RushaCore(stdlib$840, foreign$841, heap$842) {
        'use asm';

        var H$843 = new stdlib$840.Int32Array(heap$842);

        function hash$844(k$845, x$846) {
          // k in bytes
          k$845 = k$845 | 0;
          x$846 = x$846 | 0;
          var i$847 = 0,
              j$848 = 0,
              y0$849 = 0,
              z0$850 = 0,
              y1$851 = 0,
              z1$852 = 0,
              y2$853 = 0,
              z2$854 = 0,
              y3$855 = 0,
              z3$856 = 0,
              y4$857 = 0,
              z4$858 = 0,
              t0$859 = 0,
              t1$860 = 0;
          y0$849 = H$843[x$846 + 320 >> 2] | 0;
          y1$851 = H$843[x$846 + 324 >> 2] | 0;
          y2$853 = H$843[x$846 + 328 >> 2] | 0;
          y3$855 = H$843[x$846 + 332 >> 2] | 0;
          y4$857 = H$843[x$846 + 336 >> 2] | 0;

          for (i$847 = 0; (i$847 | 0) < (k$845 | 0); i$847 = i$847 + 64 | 0) {
            z0$850 = y0$849;
            z1$852 = y1$851;
            z2$854 = y2$853;
            z3$856 = y3$855;
            z4$858 = y4$857;

            for (j$848 = 0; (j$848 | 0) < 64; j$848 = j$848 + 4 | 0) {
              t1$860 = H$843[i$847 + j$848 >> 2] | 0;
              t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 & y2$853 | ~y1$851 & y3$855) | 0) + ((t1$860 + y4$857 | 0) + 1518500249 | 0) | 0;
              y4$857 = y3$855;
              y3$855 = y2$853;
              y2$853 = y1$851 << 30 | y1$851 >>> 2;
              y1$851 = y0$849;
              y0$849 = t0$859;
              H$843[k$845 + j$848 >> 2] = t1$860;
            }

            for (j$848 = k$845 + 64 | 0; (j$848 | 0) < (k$845 + 80 | 0); j$848 = j$848 + 4 | 0) {
              t1$860 = (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) << 1 | (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) >>> 31;
              t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 & y2$853 | ~y1$851 & y3$855) | 0) + ((t1$860 + y4$857 | 0) + 1518500249 | 0) | 0;
              y4$857 = y3$855;
              y3$855 = y2$853;
              y2$853 = y1$851 << 30 | y1$851 >>> 2;
              y1$851 = y0$849;
              y0$849 = t0$859;
              H$843[j$848 >> 2] = t1$860;
            }

            for (j$848 = k$845 + 80 | 0; (j$848 | 0) < (k$845 + 160 | 0); j$848 = j$848 + 4 | 0) {
              t1$860 = (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) << 1 | (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) >>> 31;
              t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 ^ y2$853 ^ y3$855) | 0) + ((t1$860 + y4$857 | 0) + 1859775393 | 0) | 0;
              y4$857 = y3$855;
              y3$855 = y2$853;
              y2$853 = y1$851 << 30 | y1$851 >>> 2;
              y1$851 = y0$849;
              y0$849 = t0$859;
              H$843[j$848 >> 2] = t1$860;
            }

            for (j$848 = k$845 + 160 | 0; (j$848 | 0) < (k$845 + 240 | 0); j$848 = j$848 + 4 | 0) {
              t1$860 = (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) << 1 | (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) >>> 31;
              t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 & y2$853 | y1$851 & y3$855 | y2$853 & y3$855) | 0) + ((t1$860 + y4$857 | 0) - 1894007588 | 0) | 0;
              y4$857 = y3$855;
              y3$855 = y2$853;
              y2$853 = y1$851 << 30 | y1$851 >>> 2;
              y1$851 = y0$849;
              y0$849 = t0$859;
              H$843[j$848 >> 2] = t1$860;
            }

            for (j$848 = k$845 + 240 | 0; (j$848 | 0) < (k$845 + 320 | 0); j$848 = j$848 + 4 | 0) {
              t1$860 = (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) << 1 | (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) >>> 31;
              t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 ^ y2$853 ^ y3$855) | 0) + ((t1$860 + y4$857 | 0) - 899497514 | 0) | 0;
              y4$857 = y3$855;
              y3$855 = y2$853;
              y2$853 = y1$851 << 30 | y1$851 >>> 2;
              y1$851 = y0$849;
              y0$849 = t0$859;
              H$843[j$848 >> 2] = t1$860;
            }

            y0$849 = y0$849 + z0$850 | 0;
            y1$851 = y1$851 + z1$852 | 0;
            y2$853 = y2$853 + z2$854 | 0;
            y3$855 = y3$855 + z3$856 | 0;
            y4$857 = y4$857 + z4$858 | 0;
          }

          H$843[x$846 + 320 >> 2] = y0$849;
          H$843[x$846 + 324 >> 2] = y1$851;
          H$843[x$846 + 328 >> 2] = y2$853;
          H$843[x$846 + 332 >> 2] = y3$855;
          H$843[x$846 + 336 >> 2] = y4$857;
        }

        return {
          hash: hash$844
        };
      };
      /***/

    },
    /* 6 */

    /***/
    function (module, exports) {
      var _this = this;
      /* eslint-env commonjs, browser */


      var reader = void 0;

      if (typeof self !== 'undefined' && typeof self.FileReaderSync !== 'undefined') {
        reader = new self.FileReaderSync();
      } // Convert a binary string and write it to the heap.
      // A binary string is expected to only contain char codes < 256.


      var convStr = function (str, H8, H32, start, len, off) {
        var i = void 0,
            om = off % 4,
            lm = (len + om) % 4,
            j = len - lm;

        switch (om) {
          case 0:
            H8[off] = str.charCodeAt(start + 3);

          case 1:
            H8[off + 1 - (om << 1) | 0] = str.charCodeAt(start + 2);

          case 2:
            H8[off + 2 - (om << 1) | 0] = str.charCodeAt(start + 1);

          case 3:
            H8[off + 3 - (om << 1) | 0] = str.charCodeAt(start);
        }

        if (len < lm + (4 - om)) {
          return;
        }

        for (i = 4 - om; i < j; i = i + 4 | 0) {
          H32[off + i >> 2] = str.charCodeAt(start + i) << 24 | str.charCodeAt(start + i + 1) << 16 | str.charCodeAt(start + i + 2) << 8 | str.charCodeAt(start + i + 3);
        }

        switch (lm) {
          case 3:
            H8[off + j + 1 | 0] = str.charCodeAt(start + j + 2);

          case 2:
            H8[off + j + 2 | 0] = str.charCodeAt(start + j + 1);

          case 1:
            H8[off + j + 3 | 0] = str.charCodeAt(start + j);
        }
      }; // Convert a buffer or array and write it to the heap.
      // The buffer or array is expected to only contain elements < 256.


      var convBuf = function (buf, H8, H32, start, len, off) {
        var i = void 0,
            om = off % 4,
            lm = (len + om) % 4,
            j = len - lm;

        switch (om) {
          case 0:
            H8[off] = buf[start + 3];

          case 1:
            H8[off + 1 - (om << 1) | 0] = buf[start + 2];

          case 2:
            H8[off + 2 - (om << 1) | 0] = buf[start + 1];

          case 3:
            H8[off + 3 - (om << 1) | 0] = buf[start];
        }

        if (len < lm + (4 - om)) {
          return;
        }

        for (i = 4 - om; i < j; i = i + 4 | 0) {
          H32[off + i >> 2 | 0] = buf[start + i] << 24 | buf[start + i + 1] << 16 | buf[start + i + 2] << 8 | buf[start + i + 3];
        }

        switch (lm) {
          case 3:
            H8[off + j + 1 | 0] = buf[start + j + 2];

          case 2:
            H8[off + j + 2 | 0] = buf[start + j + 1];

          case 1:
            H8[off + j + 3 | 0] = buf[start + j];
        }
      };

      var convBlob = function (blob, H8, H32, start, len, off) {
        var i = void 0,
            om = off % 4,
            lm = (len + om) % 4,
            j = len - lm;
        var buf = new Uint8Array(reader.readAsArrayBuffer(blob.slice(start, start + len)));

        switch (om) {
          case 0:
            H8[off] = buf[3];

          case 1:
            H8[off + 1 - (om << 1) | 0] = buf[2];

          case 2:
            H8[off + 2 - (om << 1) | 0] = buf[1];

          case 3:
            H8[off + 3 - (om << 1) | 0] = buf[0];
        }

        if (len < lm + (4 - om)) {
          return;
        }

        for (i = 4 - om; i < j; i = i + 4 | 0) {
          H32[off + i >> 2 | 0] = buf[i] << 24 | buf[i + 1] << 16 | buf[i + 2] << 8 | buf[i + 3];
        }

        switch (lm) {
          case 3:
            H8[off + j + 1 | 0] = buf[j + 2];

          case 2:
            H8[off + j + 2 | 0] = buf[j + 1];

          case 1:
            H8[off + j + 3 | 0] = buf[j];
        }
      };

      module.exports = function (data, H8, H32, start, len, off) {
        if (typeof data === 'string') {
          return convStr(data, H8, H32, start, len, off);
        }

        if (data instanceof Array) {
          return convBuf(data, H8, H32, start, len, off);
        } // Safely doing a Buffer check using "this" to avoid Buffer polyfill to be included in the dist


        if (_this && _this.Buffer && _this.Buffer.isBuffer(data)) {
          return convBuf(data, H8, H32, start, len, off);
        }

        if (data instanceof ArrayBuffer) {
          return convBuf(new Uint8Array(data), H8, H32, start, len, off);
        }

        if (data.buffer instanceof ArrayBuffer) {
          return convBuf(new Uint8Array(data.buffer, data.byteOffset, data.byteLength), H8, H32, start, len, off);
        }

        if (data instanceof Blob) {
          return convBlob(data, H8, H32, start, len, off);
        }

        throw new Error('Unsupported data type.');
      };
      /***/

    },
    /* 7 */

    /***/
    function (module, exports, __nested_webpack_require_36113__) {
      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      /* eslint-env commonjs, browser */


      var Rusha = __nested_webpack_require_36113__(0);

      var _require = __nested_webpack_require_36113__(1),
          toHex = _require.toHex;

      var Hash = function () {
        function Hash() {
          _classCallCheck(this, Hash);

          this._rusha = new Rusha();

          this._rusha.resetState();
        }

        Hash.prototype.update = function update(data) {
          this._rusha.append(data);

          return this;
        };

        Hash.prototype.digest = function digest(encoding) {
          var digest = this._rusha.rawEnd().buffer;

          if (!encoding) {
            return digest;
          }

          if (encoding === 'hex') {
            return toHex(digest);
          }

          throw new Error('unsupported digest encoding');
        };

        _createClass(Hash, [{
          key: 'state',
          get: function () {
            return this._rusha.getState();
          },
          set: function (state) {
            this._rusha.setState(state);
          }
        }]);

        return Hash;
      }();

      module.exports = function () {
        return new Hash();
      };
      /***/

    }
    /******/
    ])
  );
});

/***/ }),

/***/ "./node_modules/simple-concat/index.js":
/*!*********************************************!*\
  !*** ./node_modules/simple-concat/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
/*! simple-concat. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
module.exports = function (stream, cb) {
  var chunks = [];
  stream.on('data', function (chunk) {
    chunks.push(chunk);
  });
  stream.once('end', function () {
    if (cb) cb(null, Buffer.concat(chunks));
    cb = null;
  });
  stream.once('error', function (err) {
    if (cb) cb(err);
    cb = null;
  });
};

/***/ }),

/***/ "./node_modules/simple-get/index.js":
/*!******************************************!*\
  !*** ./node_modules/simple-get/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
/*! simple-get. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
module.exports = simpleGet;

const concat = __webpack_require__(/*! simple-concat */ "./node_modules/simple-concat/index.js");

const decompressResponse = __webpack_require__(/*! decompress-response */ "?45bd"); // excluded from browser build


const http = __webpack_require__(/*! http */ "./src/shims/http.ts");

const https = __webpack_require__(/*! https */ "./src/shims/https.ts");

const once = __webpack_require__(/*! once */ "./node_modules/once/once.js");

const querystring = __webpack_require__(/*! querystring */ "./node_modules/querystring/index.js");

const url = __webpack_require__(/*! url */ "./node_modules/url/url.js");

const isStream = o => o !== null && typeof o === 'object' && typeof o.pipe === 'function';

function simpleGet(opts, cb) {
  opts = Object.assign({
    maxRedirects: 10
  }, typeof opts === 'string' ? {
    url: opts
  } : opts);
  cb = once(cb);

  if (opts.url) {
    const {
      hostname,
      port,
      protocol,
      auth,
      path
    } = url.parse(opts.url); // eslint-disable-line node/no-deprecated-api

    delete opts.url;
    if (!hostname && !port && !protocol && !auth) opts.path = path; // Relative redirect
    else Object.assign(opts, {
      hostname,
      port,
      protocol,
      auth,
      path
    }); // Absolute redirect
  }

  const headers = {
    'accept-encoding': 'gzip, deflate'
  };
  if (opts.headers) Object.keys(opts.headers).forEach(k => headers[k.toLowerCase()] = opts.headers[k]);
  opts.headers = headers;
  let body;

  if (opts.body) {
    body = opts.json && !isStream(opts.body) ? JSON.stringify(opts.body) : opts.body;
  } else if (opts.form) {
    body = typeof opts.form === 'string' ? opts.form : querystring.stringify(opts.form);
    opts.headers['content-type'] = 'application/x-www-form-urlencoded';
  }

  if (body) {
    if (!opts.method) opts.method = 'POST';
    if (!isStream(body)) opts.headers['content-length'] = Buffer.byteLength(body);
    if (opts.json && !opts.form) opts.headers['content-type'] = 'application/json';
  }

  delete opts.body;
  delete opts.form;
  if (opts.json) opts.headers.accept = 'application/json';
  if (opts.method) opts.method = opts.method.toUpperCase();
  const originalHost = opts.hostname; // hostname before potential redirect

  const protocol = opts.protocol === 'https:' ? https : http; // Support http/https urls

  const req = protocol.request(opts, res => {
    if (opts.followRedirects !== false && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
      opts.url = res.headers.location; // Follow 3xx redirects

      delete opts.headers.host; // Discard `host` header on redirect (see #32)

      res.resume(); // Discard response

      const redirectHost = url.parse(opts.url).hostname; // eslint-disable-line node/no-deprecated-api
      // If redirected host is different than original host, drop headers to prevent cookie leak (#73)

      if (redirectHost !== null && redirectHost !== originalHost) {
        delete opts.headers.cookie;
        delete opts.headers.authorization;
      }

      if (opts.method === 'POST' && [301, 302].includes(res.statusCode)) {
        opts.method = 'GET'; // On 301/302 redirect, change POST to GET (see #35)

        delete opts.headers['content-length'];
        delete opts.headers['content-type'];
      }

      if (opts.maxRedirects-- === 0) return cb(new Error('too many redirects'));else return simpleGet(opts, cb);
    }

    const tryUnzip = typeof decompressResponse === 'function' && opts.method !== 'HEAD';
    cb(null, tryUnzip ? decompressResponse(res) : res);
  });
  req.on('timeout', () => {
    req.abort();
    cb(new Error('Request timed out'));
  });
  req.on('error', cb);
  if (isStream(body)) body.on('error', cb).pipe(req);else req.end(body);
  return req;
}

simpleGet.concat = (opts, cb) => {
  return simpleGet(opts, (err, res) => {
    if (err) return cb(err);
    concat(res, (err, data) => {
      if (err) return cb(err);

      if (opts.json) {
        try {
          data = JSON.parse(data.toString());
        } catch (err) {
          return cb(err, res, data);
        }
      }

      cb(null, res, data);
    });
  });
};

['get', 'post', 'put', 'patch', 'head', 'delete'].forEach(method => {
  simpleGet[method] = (opts, cb) => {
    if (typeof opts === 'string') opts = {
      url: opts
    };
    return simpleGet(Object.assign({
      method: method.toUpperCase()
    }, opts), cb);
  };
});

/***/ }),

/***/ "./node_modules/simple-sha1/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/simple-sha1/browser.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global self */
const Rusha = __webpack_require__(/*! rusha */ "./node_modules/rusha/dist/rusha.js");

const rushaWorkerSha1 = __webpack_require__(/*! ./rusha-worker-sha1 */ "./node_modules/simple-sha1/rusha-worker-sha1.js");

const rusha = new Rusha();
const scope = typeof window !== 'undefined' ? window : self;
const crypto = scope.crypto || scope.msCrypto || {};
let subtle = crypto.subtle || crypto.webkitSubtle;

function sha1sync(buf) {
  return rusha.digest(buf);
} // Browsers throw if they lack support for an algorithm.
// Promise will be rejected on non-secure origins. (http://goo.gl/lq4gCo)


try {
  subtle.digest({
    name: 'sha-1'
  }, new Uint8Array()).catch(function () {
    subtle = false;
  });
} catch (err) {
  subtle = false;
}

function sha1(buf, cb) {
  if (!subtle) {
    if (typeof window !== 'undefined') {
      rushaWorkerSha1(buf, function onRushaWorkerSha1(err, hash) {
        if (err) {
          // On error, fallback to synchronous method which cannot fail
          cb(sha1sync(buf));
          return;
        }

        cb(hash);
      });
    } else {
      queueMicrotask(() => cb(sha1sync(buf)));
    }

    return;
  }

  if (typeof buf === 'string') {
    buf = uint8array(buf);
  }

  subtle.digest({
    name: 'sha-1'
  }, buf).then(function succeed(result) {
    cb(hex(new Uint8Array(result)));
  }, function fail() {
    // On error, fallback to synchronous method which cannot fail
    cb(sha1sync(buf));
  });
}

function uint8array(s) {
  const l = s.length;
  const array = new Uint8Array(l);

  for (let i = 0; i < l; i++) {
    array[i] = s.charCodeAt(i);
  }

  return array;
}

function hex(buf) {
  const l = buf.length;
  const chars = [];

  for (let i = 0; i < l; i++) {
    const bite = buf[i];
    chars.push((bite >>> 4).toString(16));
    chars.push((bite & 0x0f).toString(16));
  }

  return chars.join('');
}

module.exports = sha1;
module.exports.sync = sha1sync;

/***/ }),

/***/ "./node_modules/simple-sha1/rusha-worker-sha1.js":
/*!*******************************************************!*\
  !*** ./node_modules/simple-sha1/rusha-worker-sha1.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Rusha = __webpack_require__(/*! rusha */ "./node_modules/rusha/dist/rusha.js");

let worker;
let nextTaskId;
let cbs;

function init() {
  worker = Rusha.createWorker();
  nextTaskId = 1;
  cbs = {}; // taskId -> cb

  worker.onmessage = function onRushaMessage(e) {
    const taskId = e.data.id;
    const cb = cbs[taskId];
    delete cbs[taskId];

    if (e.data.error != null) {
      cb(new Error('Rusha worker error: ' + e.data.error));
    } else {
      cb(null, e.data.hash);
    }
  };
}

function sha1(buf, cb) {
  if (!worker) init();
  cbs[nextTaskId] = cb;
  worker.postMessage({
    id: nextTaskId,
    data: buf
  });
  nextTaskId += 1;
}

module.exports = sha1;

/***/ }),

/***/ "./node_modules/speed-limiter/index.js":
/*!*********************************************!*\
  !*** ./node_modules/speed-limiter/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Throttle = __webpack_require__(/*! ./lib/throttle */ "./node_modules/speed-limiter/lib/throttle.js");

const ThrottleGroup = __webpack_require__(/*! ./lib/throttle-group */ "./node_modules/speed-limiter/lib/throttle-group.js");

module.exports = {
  Throttle,
  ThrottleGroup
};

/***/ }),

/***/ "./node_modules/speed-limiter/lib/throttle-group.js":
/*!**********************************************************!*\
  !*** ./node_modules/speed-limiter/lib/throttle-group.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

const {
  TokenBucket
} = __webpack_require__(/*! limiter */ "./node_modules/limiter/index.js");

const Throttle = __webpack_require__(/*! ./throttle */ "./node_modules/speed-limiter/lib/throttle.js");

let ThrottleGroup = /*#__PURE__*/function () {
  function ThrottleGroup() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ThrottleGroup);

    if (typeof opts !== 'object') throw new Error('Options must be an object');
    this.throttles = [];
    this.setEnabled(opts.enabled);
    this.setRate(opts.rate, opts.chunksize);
  }

  _createClass(ThrottleGroup, [{
    key: "getEnabled",
    value: function getEnabled() {
      return this._enabled;
    }
  }, {
    key: "getRate",
    value: function getRate() {
      // Note: bucketSize === tokensPerInterval
      return this.bucket.tokensPerInterval;
    }
  }, {
    key: "getChunksize",
    value: function getChunksize() {
      return this.chunksize;
    }
  }, {
    key: "setEnabled",
    value: function setEnabled() {
      let val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (typeof val !== 'boolean') throw new Error('Enabled must be a boolean');
      this._enabled = val;

      for (const throttle of this.throttles) {
        throttle.setEnabled(val);
      }
    }
  }, {
    key: "setRate",
    value: function setRate(rate) {
      let chunksize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      // Note: rate = 0, means we should stop processing chunks
      if (!Number.isInteger(rate) || rate < 0) throw new Error('Rate must be an integer bigger than zero');
      rate = parseInt(rate);
      if (chunksize && (typeof chunksize !== 'number' || chunksize <= 0)) throw new Error('Chunksize must be bigger than zero');
      chunksize = chunksize || Math.max(parseInt(rate / 10), 1);
      chunksize = parseInt(chunksize);
      if (rate > 0 && chunksize > rate) throw new Error('Chunk size must be smaller than rate');
      if (!this.bucket) this.bucket = new TokenBucket(rate, rate, 'second', null);
      this.bucket.bucketSize = rate;
      this.bucket.tokensPerInterval = rate;
      this.chunksize = chunksize;
    }
  }, {
    key: "setChunksize",
    value: function setChunksize(chunksize) {
      if (!Number.isInteger(chunksize) || chunksize <= 0) throw new Error('Chunk size must be an integer bigger than zero');
      const rate = this.getRate();
      chunksize = parseInt(chunksize);
      if (rate > 0 && chunksize > rate) throw new Error('Chunk size must be smaller than rate');
      this.chunksize = chunksize;
    }
  }, {
    key: "throttle",
    value: function throttle() {
      let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (typeof opts !== 'object') throw new Error('Options must be an object');
      const newThrottle = new Throttle(_objectSpread(_objectSpread({}, opts), {}, {
        group: this
      }));
      return newThrottle;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      for (const throttle of this.throttles) {
        throttle.destroy();
      }

      this.throttles = [];
    }
  }, {
    key: "_addThrottle",
    value: function _addThrottle(throttle) {
      if (!(throttle instanceof Throttle)) throw new Error('Throttle must be an instance of Throttle');
      this.throttles.push(throttle);
    }
  }, {
    key: "_removeThrottle",
    value: function _removeThrottle(throttle) {
      const index = this.throttles.indexOf(throttle);
      if (index > -1) this.throttles.splice(index, 1);
    }
  }]);

  return ThrottleGroup;
}();

module.exports = ThrottleGroup;

/***/ }),

/***/ "./node_modules/speed-limiter/lib/throttle.js":
/*!****************************************************!*\
  !*** ./node_modules/speed-limiter/lib/throttle.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

const {
  EventEmitter
} = __webpack_require__(/*! events */ "./node_modules/events/events.js");

const {
  Transform
} = __webpack_require__(/*! streamx */ "./node_modules/streamx/index.js");

const {
  wait
} = __webpack_require__(/*! ./utils */ "./node_modules/speed-limiter/lib/utils.js");

let Throttle = /*#__PURE__*/function (_Transform) {
  _inherits(Throttle, _Transform);

  var _super = _createSuper(Throttle);

  function Throttle() {
    var _this;

    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Throttle);

    _this = _super.call(this);
    if (typeof opts !== 'object') throw new Error('Options must be an object');
    const params = Object.assign({}, opts);
    if (params.group && !(params.group instanceof ThrottleGroup)) throw new Error('Group must be an instanece of ThrottleGroup');else if (!params.group) params.group = new ThrottleGroup(params);

    _this._setEnabled(params.enabled || params.group.enabled);

    _this._group = params.group;
    _this._emitter = new EventEmitter();
    _this._destroyed = false;

    _this._group._addThrottle(_assertThisInitialized(_this));

    return _this;
  }

  _createClass(Throttle, [{
    key: "getEnabled",
    value: function getEnabled() {
      return this._enabled;
    }
  }, {
    key: "getGroup",
    value: function getGroup() {
      return this._group;
    }
  }, {
    key: "_setEnabled",
    value: function _setEnabled() {
      let val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (typeof val !== 'boolean') throw new Error('Enabled must be a boolean');
      this._enabled = val;
    }
  }, {
    key: "setEnabled",
    value: function setEnabled(val) {
      this._setEnabled(val);

      if (this._enabled) this._emitter.emit('enabled');else this._emitter.emit('disabled');
    }
  }, {
    key: "_transform",
    value: function _transform(chunk, done) {
      this._processChunk(chunk, done);
    }
    /* async _waitForPositiveRate () {
      // Stop pushing chunks if rate is zero
      while (this._group.getRate() === 0 && !this._destroyed && this._areBothEnabled()) {
        await wait(1 * 1000) // wait 1 second
      }
    } */

  }, {
    key: "_waitForTokens",
    value: async function _waitForTokens(amount) {
      // Wait for enabled, destroyed or tokens
      return new Promise((resolve, reject) => {
        let done = false;
        const self = this;

        function isDone(err) {
          self._emitter.removeListener('disabled', isDone);

          self._emitter.removeListener('destroyed', isDone);

          if (done) return;
          done = true;
          if (err) return reject(err);
          resolve();
        }

        this._emitter.once('disabled', isDone);

        this._emitter.once('destroyed', isDone); // TODO: next version remove lisener in "isDone"


        this._group.bucket.removeTokens(amount, isDone);
      });
    }
  }, {
    key: "_areBothEnabled",
    value: function _areBothEnabled() {
      return this._enabled && this._group.getEnabled();
    }
    /* async _throttleChunk (size) {
      // Stop pushing chunks if rate is zero
      await this._waitForPositiveRate()
      if (this._destroyed) return
      if (!this._areBothEnabled()) return
       // Get tokens from bucket
      await this._waitForTokens(size)
    } */

  }, {
    key: "_processChunk",
    value: async function _processChunk(chunk, done) {
      if (!this._areBothEnabled()) return done(null, chunk);
      let pos = 0;

      let chunksize = this._group.getChunksize();

      let slice = chunk.slice(pos, pos + chunksize);

      while (slice.length > 0) {
        // Check here again because we might be in the middle of a big chunk
        // with a lot of small slices
        if (this._areBothEnabled()) {
          try {
            // WAIT FOR POSITIVE RATE
            // Stop pushing chunks if rate is zero
            while (this._group.getRate() === 0 && !this._destroyed && this._areBothEnabled()) {
              await wait(1000); // wait 1 second

              if (this._destroyed) return;
            } // WAIT FOR TOKENS


            if (this._areBothEnabled() && !this._group.bucket.tryRemoveTokens(slice.length)) {
              await this._waitForTokens(slice.length);
              if (this._destroyed) return;
            }
          } catch (err) {
            return done(err);
          }
        }

        this.push(slice);
        pos += chunksize; // Calculate params for next slice

        chunksize = this._areBothEnabled() ? this._group.getChunksize() // Chunksize might have changed
        : chunk.length - pos; // Get the rest of the chunk

        slice = chunk.slice(pos, pos + chunksize);
      }

      return done();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _get2;

      this._group._removeThrottle(this);

      this._destroyed = true;

      this._emitter.emit('destroyed');

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      (_get2 = _get(_getPrototypeOf(Throttle.prototype), "destroy", this)).call.apply(_get2, [this].concat(args));
    }
  }]);

  return Throttle;
}(Transform);

module.exports = Throttle; // Fix circular dependency

const ThrottleGroup = __webpack_require__(/*! ./throttle-group */ "./node_modules/speed-limiter/lib/throttle-group.js");

/***/ }),

/***/ "./node_modules/speed-limiter/lib/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/speed-limiter/lib/utils.js ***!
  \*************************************************/
/***/ ((module) => {

function wait(time) {
  return new Promise(resolve => setTimeout(resolve, time));
}

module.exports = {
  wait
};

/***/ }),

/***/ "./node_modules/speedometer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/speedometer/index.js ***!
  \*******************************************/
/***/ ((module) => {

var tick = 1;
var maxTick = 65535;
var resolution = 4;
var timer;

var inc = function () {
  tick = tick + 1 & maxTick;
};

module.exports = function (seconds) {
  if (!timer) {
    timer = setInterval(inc, 1000 / resolution | 0);
    if (timer.unref) timer.unref();
  }

  var size = resolution * (seconds || 5);
  var buffer = [0];
  var pointer = 1;
  var last = tick - 1 & maxTick;
  return function (delta) {
    var dist = tick - last & maxTick;
    if (dist > size) dist = size;
    last = tick;

    while (dist--) {
      if (pointer === size) pointer = 0;
      buffer[pointer] = buffer[pointer === 0 ? size - 1 : pointer - 1];
      pointer++;
    }

    if (delta) buffer[pointer - 1] += delta;
    var top = buffer[pointer - 1];
    var btm = buffer.length < size ? 0 : buffer[pointer === size ? 0 : pointer];
    return buffer.length < resolution ? top : (top - btm) * resolution / buffer.length;
  };
};

/***/ }),

/***/ "./node_modules/stream-browserify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/stream-browserify/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Stream;

var EE = (__webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter);

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

inherits(Stream, EE);
Stream.Readable = __webpack_require__(/*! readable-stream/lib/_stream_readable.js */ "./node_modules/readable-stream/lib/_stream_readable.js");
Stream.Writable = __webpack_require__(/*! readable-stream/lib/_stream_writable.js */ "./node_modules/readable-stream/lib/_stream_writable.js");
Stream.Duplex = __webpack_require__(/*! readable-stream/lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js");
Stream.Transform = __webpack_require__(/*! readable-stream/lib/_stream_transform.js */ "./node_modules/readable-stream/lib/_stream_transform.js");
Stream.PassThrough = __webpack_require__(/*! readable-stream/lib/_stream_passthrough.js */ "./node_modules/readable-stream/lib/_stream_passthrough.js");
Stream.finished = __webpack_require__(/*! readable-stream/lib/internal/streams/end-of-stream.js */ "./node_modules/readable-stream/lib/internal/streams/end-of-stream.js");
Stream.pipeline = __webpack_require__(/*! readable-stream/lib/internal/streams/pipeline.js */ "./node_modules/readable-stream/lib/internal/streams/pipeline.js"); // Backwards-compat with node 0.4.x

Stream.Stream = Stream; // old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function (dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain); // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.

  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;

  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;
    dest.end();
  }

  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;
    if (typeof dest.destroy === 'function') dest.destroy();
  } // don't leave dangling pipes when there are errors.


  function onerror(er) {
    cleanup();

    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror); // remove all the event listeners that were added.

  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);
    source.removeListener('end', onend);
    source.removeListener('close', onclose);
    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);
    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);
    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);
  dest.on('close', cleanup);
  dest.emit('pipe', source); // Allow for unix-like usage: A.pipe(B).pipe(C)

  return dest;
};

/***/ }),

/***/ "./node_modules/stream-http/index.js":
/*!*******************************************!*\
  !*** ./node_modules/stream-http/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var ClientRequest = __webpack_require__(/*! ./lib/request */ "./node_modules/stream-http/lib/request.js");

var response = __webpack_require__(/*! ./lib/response */ "./node_modules/stream-http/lib/response.js");

var extend = __webpack_require__(/*! xtend */ "./node_modules/xtend/immutable.js");

var statusCodes = __webpack_require__(/*! builtin-status-codes */ "./node_modules/builtin-status-codes/browser.js");

var url = __webpack_require__(/*! url */ "./node_modules/url/url.js");

var http = exports;

http.request = function (opts, cb) {
  if (typeof opts === 'string') opts = url.parse(opts);else opts = extend(opts); // Normally, the page is loaded from http or https, so not specifying a protocol
  // will result in a (valid) protocol-relative url. However, this won't work if
  // the protocol is something else, like 'file:'

  var defaultProtocol = __webpack_require__.g.location.protocol.search(/^https?:$/) === -1 ? 'http:' : '';
  var protocol = opts.protocol || defaultProtocol;
  var host = opts.hostname || opts.host;
  var port = opts.port;
  var path = opts.path || '/'; // Necessary for IPv6 addresses

  if (host && host.indexOf(':') !== -1) host = '[' + host + ']'; // This may be a relative url. The browser should always be able to interpret it correctly.

  opts.url = (host ? protocol + '//' + host : '') + (port ? ':' + port : '') + path;
  opts.method = (opts.method || 'GET').toUpperCase();
  opts.headers = opts.headers || {}; // Also valid opts.auth, opts.mode

  var req = new ClientRequest(opts);
  if (cb) req.on('response', cb);
  return req;
};

http.get = function get(opts, cb) {
  var req = http.request(opts, cb);
  req.end();
  return req;
};

http.ClientRequest = ClientRequest;
http.IncomingMessage = response.IncomingMessage;

http.Agent = function () {};

http.Agent.defaultMaxSockets = 4;
http.globalAgent = new http.Agent();
http.STATUS_CODES = statusCodes;
http.METHODS = ['CHECKOUT', 'CONNECT', 'COPY', 'DELETE', 'GET', 'HEAD', 'LOCK', 'M-SEARCH', 'MERGE', 'MKACTIVITY', 'MKCOL', 'MOVE', 'NOTIFY', 'OPTIONS', 'PATCH', 'POST', 'PROPFIND', 'PROPPATCH', 'PURGE', 'PUT', 'REPORT', 'SEARCH', 'SUBSCRIBE', 'TRACE', 'UNLOCK', 'UNSUBSCRIBE'];

/***/ }),

/***/ "./node_modules/stream-http/lib/capability.js":
/*!****************************************************!*\
  !*** ./node_modules/stream-http/lib/capability.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.fetch = isFunction(__webpack_require__.g.fetch) && isFunction(__webpack_require__.g.ReadableStream);
exports.writableStream = isFunction(__webpack_require__.g.WritableStream);
exports.abortController = isFunction(__webpack_require__.g.AbortController); // The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.

var xhr;

function getXHR() {
  // Cache the xhr value
  if (xhr !== undefined) return xhr;

  if (__webpack_require__.g.XMLHttpRequest) {
    xhr = new __webpack_require__.g.XMLHttpRequest(); // If XDomainRequest is available (ie only, where xhr might not work
    // cross domain), use the page location. Otherwise use example.com
    // Note: this doesn't actually make an http request.

    try {
      xhr.open('GET', __webpack_require__.g.XDomainRequest ? '/' : 'https://example.com');
    } catch (e) {
      xhr = null;
    }
  } else {
    // Service workers don't have XHR
    xhr = null;
  }

  return xhr;
}

function checkTypeSupport(type) {
  var xhr = getXHR();
  if (!xhr) return false;

  try {
    xhr.responseType = type;
    return xhr.responseType === type;
  } catch (e) {}

  return false;
} // If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().


exports.arraybuffer = exports.fetch || checkTypeSupport('arraybuffer'); // These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.

exports.msstream = !exports.fetch && checkTypeSupport('ms-stream');
exports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport('moz-chunked-arraybuffer'); // If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().

exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false);

function isFunction(value) {
  return typeof value === 'function';
}

xhr = null; // Help gc

/***/ }),

/***/ "./node_modules/stream-http/lib/request.js":
/*!*************************************************!*\
  !*** ./node_modules/stream-http/lib/request.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");
var capability = __webpack_require__(/*! ./capability */ "./node_modules/stream-http/lib/capability.js");

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var response = __webpack_require__(/*! ./response */ "./node_modules/stream-http/lib/response.js");

var stream = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js");

var IncomingMessage = response.IncomingMessage;
var rStates = response.readyStates;

function decideMode(preferBinary, useFetch) {
  if (capability.fetch && useFetch) {
    return 'fetch';
  } else if (capability.mozchunkedarraybuffer) {
    return 'moz-chunked-arraybuffer';
  } else if (capability.msstream) {
    return 'ms-stream';
  } else if (capability.arraybuffer && preferBinary) {
    return 'arraybuffer';
  } else {
    return 'text';
  }
}

var ClientRequest = module.exports = function (opts) {
  var self = this;
  stream.Writable.call(self);
  self._opts = opts;
  self._body = [];
  self._headers = {};
  if (opts.auth) self.setHeader('Authorization', 'Basic ' + Buffer.from(opts.auth).toString('base64'));
  Object.keys(opts.headers).forEach(function (name) {
    self.setHeader(name, opts.headers[name]);
  });
  var preferBinary;
  var useFetch = true;

  if (opts.mode === 'disable-fetch' || 'requestTimeout' in opts && !capability.abortController) {
    // If the use of XHR should be preferred. Not typically needed.
    useFetch = false;
    preferBinary = true;
  } else if (opts.mode === 'prefer-streaming') {
    // If streaming is a high priority but binary compatibility and
    // the accuracy of the 'content-type' header aren't
    preferBinary = false;
  } else if (opts.mode === 'allow-wrong-content-type') {
    // If streaming is more important than preserving the 'content-type' header
    preferBinary = !capability.overrideMimeType;
  } else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
    // Use binary if text streaming may corrupt data or the content-type header, or for speed
    preferBinary = true;
  } else {
    throw new Error('Invalid value for opts.mode');
  }

  self._mode = decideMode(preferBinary, useFetch);
  self._fetchTimer = null;
  self._socketTimeout = null;
  self._socketTimer = null;
  self.on('finish', function () {
    self._onFinish();
  });
};

inherits(ClientRequest, stream.Writable);

ClientRequest.prototype.setHeader = function (name, value) {
  var self = this;
  var lowerName = name.toLowerCase(); // This check is not necessary, but it prevents warnings from browsers about setting unsafe
  // headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
  // http-browserify did it, so I will too.

  if (unsafeHeaders.indexOf(lowerName) !== -1) return;
  self._headers[lowerName] = {
    name: name,
    value: value
  };
};

ClientRequest.prototype.getHeader = function (name) {
  var header = this._headers[name.toLowerCase()];

  if (header) return header.value;
  return null;
};

ClientRequest.prototype.removeHeader = function (name) {
  var self = this;
  delete self._headers[name.toLowerCase()];
};

ClientRequest.prototype._onFinish = function () {
  var self = this;
  if (self._destroyed) return;
  var opts = self._opts;

  if ('timeout' in opts && opts.timeout !== 0) {
    self.setTimeout(opts.timeout);
  }

  var headersObj = self._headers;
  var body = null;

  if (opts.method !== 'GET' && opts.method !== 'HEAD') {
    body = new Blob(self._body, {
      type: (headersObj['content-type'] || {}).value || ''
    });
  } // create flattened list of headers


  var headersList = [];
  Object.keys(headersObj).forEach(function (keyName) {
    var name = headersObj[keyName].name;
    var value = headersObj[keyName].value;

    if (Array.isArray(value)) {
      value.forEach(function (v) {
        headersList.push([name, v]);
      });
    } else {
      headersList.push([name, value]);
    }
  });

  if (self._mode === 'fetch') {
    var signal = null;

    if (capability.abortController) {
      var controller = new AbortController();
      signal = controller.signal;
      self._fetchAbortController = controller;

      if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
        self._fetchTimer = __webpack_require__.g.setTimeout(function () {
          self.emit('requestTimeout');
          if (self._fetchAbortController) self._fetchAbortController.abort();
        }, opts.requestTimeout);
      }
    }

    __webpack_require__.g.fetch(self._opts.url, {
      method: self._opts.method,
      headers: headersList,
      body: body || undefined,
      mode: 'cors',
      credentials: opts.withCredentials ? 'include' : 'same-origin',
      signal: signal
    }).then(function (response) {
      self._fetchResponse = response;

      self._resetTimers(false);

      self._connect();
    }, function (reason) {
      self._resetTimers(true);

      if (!self._destroyed) self.emit('error', reason);
    });
  } else {
    var xhr = self._xhr = new __webpack_require__.g.XMLHttpRequest();

    try {
      xhr.open(self._opts.method, self._opts.url, true);
    } catch (err) {
      process.nextTick(function () {
        self.emit('error', err);
      });
      return;
    } // Can't set responseType on really old browsers


    if ('responseType' in xhr) xhr.responseType = self._mode;
    if ('withCredentials' in xhr) xhr.withCredentials = !!opts.withCredentials;
    if (self._mode === 'text' && 'overrideMimeType' in xhr) xhr.overrideMimeType('text/plain; charset=x-user-defined');

    if ('requestTimeout' in opts) {
      xhr.timeout = opts.requestTimeout;

      xhr.ontimeout = function () {
        self.emit('requestTimeout');
      };
    }

    headersList.forEach(function (header) {
      xhr.setRequestHeader(header[0], header[1]);
    });
    self._response = null;

    xhr.onreadystatechange = function () {
      switch (xhr.readyState) {
        case rStates.LOADING:
        case rStates.DONE:
          self._onXHRProgress();

          break;
      }
    }; // Necessary for streaming in Firefox, since xhr.response is ONLY defined
    // in onprogress, not in onreadystatechange with xhr.readyState = 3


    if (self._mode === 'moz-chunked-arraybuffer') {
      xhr.onprogress = function () {
        self._onXHRProgress();
      };
    }

    xhr.onerror = function () {
      if (self._destroyed) return;

      self._resetTimers(true);

      self.emit('error', new Error('XHR error'));
    };

    try {
      xhr.send(body);
    } catch (err) {
      process.nextTick(function () {
        self.emit('error', err);
      });
      return;
    }
  }
};
/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */


function statusValid(xhr) {
  try {
    var status = xhr.status;
    return status !== null && status !== 0;
  } catch (e) {
    return false;
  }
}

ClientRequest.prototype._onXHRProgress = function () {
  var self = this;

  self._resetTimers(false);

  if (!statusValid(self._xhr) || self._destroyed) return;
  if (!self._response) self._connect();

  self._response._onXHRProgress(self._resetTimers.bind(self));
};

ClientRequest.prototype._connect = function () {
  var self = this;
  if (self._destroyed) return;
  self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._resetTimers.bind(self));

  self._response.on('error', function (err) {
    self.emit('error', err);
  });

  self.emit('response', self._response);
};

ClientRequest.prototype._write = function (chunk, encoding, cb) {
  var self = this;

  self._body.push(chunk);

  cb();
};

ClientRequest.prototype._resetTimers = function (done) {
  var self = this;
  __webpack_require__.g.clearTimeout(self._socketTimer);
  self._socketTimer = null;

  if (done) {
    __webpack_require__.g.clearTimeout(self._fetchTimer);
    self._fetchTimer = null;
  } else if (self._socketTimeout) {
    self._socketTimer = __webpack_require__.g.setTimeout(function () {
      self.emit('timeout');
    }, self._socketTimeout);
  }
};

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function (err) {
  var self = this;
  self._destroyed = true;

  self._resetTimers(true);

  if (self._response) self._response._destroyed = true;
  if (self._xhr) self._xhr.abort();else if (self._fetchAbortController) self._fetchAbortController.abort();
  if (err) self.emit('error', err);
};

ClientRequest.prototype.end = function (data, encoding, cb) {
  var self = this;

  if (typeof data === 'function') {
    cb = data;
    data = undefined;
  }

  stream.Writable.prototype.end.call(self, data, encoding, cb);
};

ClientRequest.prototype.setTimeout = function (timeout, cb) {
  var self = this;
  if (cb) self.once('timeout', cb);
  self._socketTimeout = timeout;

  self._resetTimers(false);
};

ClientRequest.prototype.flushHeaders = function () {};

ClientRequest.prototype.setNoDelay = function () {};

ClientRequest.prototype.setSocketKeepAlive = function () {}; // Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method


var unsafeHeaders = ['accept-charset', 'accept-encoding', 'access-control-request-headers', 'access-control-request-method', 'connection', 'content-length', 'cookie', 'cookie2', 'date', 'dnt', 'expect', 'host', 'keep-alive', 'origin', 'referer', 'te', 'trailer', 'transfer-encoding', 'upgrade', 'via'];

/***/ }),

/***/ "./node_modules/stream-http/lib/response.js":
/*!**************************************************!*\
  !*** ./node_modules/stream-http/lib/response.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
var capability = __webpack_require__(/*! ./capability */ "./node_modules/stream-http/lib/capability.js");

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var stream = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js");

var rStates = exports.readyStates = {
  UNSENT: 0,
  OPENED: 1,
  HEADERS_RECEIVED: 2,
  LOADING: 3,
  DONE: 4
};

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, resetTimers) {
  var self = this;
  stream.Readable.call(self);
  self._mode = mode;
  self.headers = {};
  self.rawHeaders = [];
  self.trailers = {};
  self.rawTrailers = []; // Fake the 'close' event, but only once 'end' fires

  self.on('end', function () {
    // The nextTick is necessary to prevent the 'request' module from causing an infinite loop
    process.nextTick(function () {
      self.emit('close');
    });
  });

  if (mode === 'fetch') {
    self._fetchResponse = response;
    self.url = response.url;
    self.statusCode = response.status;
    self.statusMessage = response.statusText;
    response.headers.forEach(function (header, key) {
      self.headers[key.toLowerCase()] = header;
      self.rawHeaders.push(key, header);
    });

    if (capability.writableStream) {
      var writable = new WritableStream({
        write: function (chunk) {
          resetTimers(false);
          return new Promise(function (resolve, reject) {
            if (self._destroyed) {
              reject();
            } else if (self.push(Buffer.from(chunk))) {
              resolve();
            } else {
              self._resumeFetch = resolve;
            }
          });
        },
        close: function () {
          resetTimers(true);
          if (!self._destroyed) self.push(null);
        },
        abort: function (err) {
          resetTimers(true);
          if (!self._destroyed) self.emit('error', err);
        }
      });

      try {
        response.body.pipeTo(writable).catch(function (err) {
          resetTimers(true);
          if (!self._destroyed) self.emit('error', err);
        });
        return;
      } catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this

    } // fallback for when writableStream or pipeTo aren't available


    var reader = response.body.getReader();

    function read() {
      reader.read().then(function (result) {
        if (self._destroyed) return;
        resetTimers(result.done);

        if (result.done) {
          self.push(null);
          return;
        }

        self.push(Buffer.from(result.value));
        read();
      }).catch(function (err) {
        resetTimers(true);
        if (!self._destroyed) self.emit('error', err);
      });
    }

    read();
  } else {
    self._xhr = xhr;
    self._pos = 0;
    self.url = xhr.responseURL;
    self.statusCode = xhr.status;
    self.statusMessage = xhr.statusText;
    var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
    headers.forEach(function (header) {
      var matches = header.match(/^([^:]+):\s*(.*)/);

      if (matches) {
        var key = matches[1].toLowerCase();

        if (key === 'set-cookie') {
          if (self.headers[key] === undefined) {
            self.headers[key] = [];
          }

          self.headers[key].push(matches[2]);
        } else if (self.headers[key] !== undefined) {
          self.headers[key] += ', ' + matches[2];
        } else {
          self.headers[key] = matches[2];
        }

        self.rawHeaders.push(matches[1], matches[2]);
      }
    });
    self._charset = 'x-user-defined';

    if (!capability.overrideMimeType) {
      var mimeType = self.rawHeaders['mime-type'];

      if (mimeType) {
        var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);

        if (charsetMatch) {
          self._charset = charsetMatch[1].toLowerCase();
        }
      }

      if (!self._charset) self._charset = 'utf-8'; // best guess
    }
  }
};

inherits(IncomingMessage, stream.Readable);

IncomingMessage.prototype._read = function () {
  var self = this;
  var resolve = self._resumeFetch;

  if (resolve) {
    self._resumeFetch = null;
    resolve();
  }
};

IncomingMessage.prototype._onXHRProgress = function (resetTimers) {
  var self = this;
  var xhr = self._xhr;
  var response = null;

  switch (self._mode) {
    case 'text':
      response = xhr.responseText;

      if (response.length > self._pos) {
        var newData = response.substr(self._pos);

        if (self._charset === 'x-user-defined') {
          var buffer = Buffer.alloc(newData.length);

          for (var i = 0; i < newData.length; i++) buffer[i] = newData.charCodeAt(i) & 0xff;

          self.push(buffer);
        } else {
          self.push(newData, self._charset);
        }

        self._pos = response.length;
      }

      break;

    case 'arraybuffer':
      if (xhr.readyState !== rStates.DONE || !xhr.response) break;
      response = xhr.response;
      self.push(Buffer.from(new Uint8Array(response)));
      break;

    case 'moz-chunked-arraybuffer':
      // take whole
      response = xhr.response;
      if (xhr.readyState !== rStates.LOADING || !response) break;
      self.push(Buffer.from(new Uint8Array(response)));
      break;

    case 'ms-stream':
      response = xhr.response;
      if (xhr.readyState !== rStates.LOADING) break;
      var reader = new __webpack_require__.g.MSStreamReader();

      reader.onprogress = function () {
        if (reader.result.byteLength > self._pos) {
          self.push(Buffer.from(new Uint8Array(reader.result.slice(self._pos))));
          self._pos = reader.result.byteLength;
        }
      };

      reader.onload = function () {
        resetTimers(true);
        self.push(null);
      }; // reader.onerror = ??? // TODO: this


      reader.readAsArrayBuffer(response);
      break;
  } // The ms-stream case handles end separately in reader.onload()


  if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
    resetTimers(true);
    self.push(null);
  }
};

/***/ }),

/***/ "./node_modules/stream-to-blob-url/index.js":
/*!**************************************************!*\
  !*** ./node_modules/stream-to-blob-url/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*! stream-to-blob-url. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
module.exports = getBlobURL;

const getBlob = __webpack_require__(/*! stream-to-blob */ "./node_modules/stream-to-blob/index.js");

async function getBlobURL(stream, mimeType) {
  const blob = await getBlob(stream, mimeType);
  const url = URL.createObjectURL(blob);
  return url;
}

/***/ }),

/***/ "./node_modules/stream-to-blob/index.js":
/*!**********************************************!*\
  !*** ./node_modules/stream-to-blob/index.js ***!
  \**********************************************/
/***/ ((module) => {

/*! stream-to-blob. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

/* global Blob */
module.exports = streamToBlob;

function streamToBlob(stream, mimeType) {
  if (mimeType != null && typeof mimeType !== 'string') {
    throw new Error('Invalid mimetype, expected string.');
  }

  return new Promise((resolve, reject) => {
    const chunks = [];
    stream.on('data', chunk => chunks.push(chunk)).once('end', () => {
      const blob = mimeType != null ? new Blob(chunks, {
        type: mimeType
      }) : new Blob(chunks);
      resolve(blob);
    }).once('error', reject);
  });
}

/***/ }),

/***/ "./node_modules/stream-with-known-length-to-buffer/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/stream-with-known-length-to-buffer/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
/*! stream-with-known-length-to-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var once = __webpack_require__(/*! once */ "./node_modules/once/once.js");

module.exports = function getBuffer(stream, length, cb) {
  cb = once(cb);
  var buf = Buffer.alloc(length);
  var offset = 0;
  stream.on('data', function (chunk) {
    chunk.copy(buf, offset);
    offset += chunk.length;
  }).on('end', function () {
    cb(null, buf);
  }).on('error', cb);
};

/***/ }),

/***/ "./node_modules/streamx/index.js":
/*!***************************************!*\
  !*** ./node_modules/streamx/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

const {
  EventEmitter
} = __webpack_require__(/*! events */ "./node_modules/events/events.js");

const STREAM_DESTROYED = new Error('Stream was destroyed');
const PREMATURE_CLOSE = new Error('Premature close');

const queueTick = __webpack_require__(/*! queue-tick */ "./node_modules/queue-tick/queue-microtask.js");

const FIFO = __webpack_require__(/*! fast-fifo */ "./node_modules/fast-fifo/index.js");
/* eslint-disable no-multi-spaces */


const MAX = (1 << 25) - 1; // Shared state

const OPENING = 0b001;
const DESTROYING = 0b010;
const DESTROYED = 0b100;
const NOT_OPENING = MAX ^ OPENING; // Read state

const READ_ACTIVE = 0b0000000000001 << 3;
const READ_PRIMARY = 0b0000000000010 << 3;
const READ_SYNC = 0b0000000000100 << 3;
const READ_QUEUED = 0b0000000001000 << 3;
const READ_RESUMED = 0b0000000010000 << 3;
const READ_PIPE_DRAINED = 0b0000000100000 << 3;
const READ_ENDING = 0b0000001000000 << 3;
const READ_EMIT_DATA = 0b0000010000000 << 3;
const READ_EMIT_READABLE = 0b0000100000000 << 3;
const READ_EMITTED_READABLE = 0b0001000000000 << 3;
const READ_DONE = 0b0010000000000 << 3;
const READ_NEXT_TICK = 0b0100000000001 << 3; // also active

const READ_NEEDS_PUSH = 0b1000000000000 << 3;
const READ_NOT_ACTIVE = MAX ^ READ_ACTIVE;
const READ_NON_PRIMARY = MAX ^ READ_PRIMARY;
const READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH);
const READ_NOT_SYNC = MAX ^ READ_SYNC;
const READ_PUSHED = MAX ^ READ_NEEDS_PUSH;
const READ_PAUSED = MAX ^ READ_RESUMED;
const READ_NOT_QUEUED = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE);
const READ_NOT_ENDING = MAX ^ READ_ENDING;
const READ_PIPE_NOT_DRAINED = MAX ^ (READ_RESUMED | READ_PIPE_DRAINED);
const READ_NOT_NEXT_TICK = MAX ^ READ_NEXT_TICK; // Write state

const WRITE_ACTIVE = 0b000000001 << 16;
const WRITE_PRIMARY = 0b000000010 << 16;
const WRITE_SYNC = 0b000000100 << 16;
const WRITE_QUEUED = 0b000001000 << 16;
const WRITE_UNDRAINED = 0b000010000 << 16;
const WRITE_DONE = 0b000100000 << 16;
const WRITE_EMIT_DRAIN = 0b001000000 << 16;
const WRITE_NEXT_TICK = 0b010000001 << 16; // also active

const WRITE_FINISHING = 0b100000000 << 16;
const WRITE_NOT_ACTIVE = MAX ^ WRITE_ACTIVE;
const WRITE_NOT_SYNC = MAX ^ WRITE_SYNC;
const WRITE_NON_PRIMARY = MAX ^ WRITE_PRIMARY;
const WRITE_NOT_FINISHING = MAX ^ WRITE_FINISHING;
const WRITE_DRAINED = MAX ^ WRITE_UNDRAINED;
const WRITE_NOT_QUEUED = MAX ^ WRITE_QUEUED;
const WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK; // Combined shared state

const ACTIVE = READ_ACTIVE | WRITE_ACTIVE;
const NOT_ACTIVE = MAX ^ ACTIVE;
const DONE = READ_DONE | WRITE_DONE;
const DESTROY_STATUS = DESTROYING | DESTROYED;
const OPEN_STATUS = DESTROY_STATUS | OPENING;
const AUTO_DESTROY = DESTROY_STATUS | DONE;
const NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY;
const TICKING = (WRITE_NEXT_TICK | READ_NEXT_TICK) & NOT_ACTIVE;
const ACTIVE_OR_TICKING = ACTIVE | TICKING;
const IS_OPENING = OPEN_STATUS | TICKING; // Combined read state

const READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE;
const READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED;
const READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED;
const READ_ACTIVE_AND_SYNC = READ_ACTIVE | READ_SYNC;
const READ_ACTIVE_AND_SYNC_AND_NEEDS_PUSH = READ_ACTIVE | READ_SYNC | READ_NEEDS_PUSH;
const READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE;
const READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED;
const READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED;
const READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE;
const SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH;
const READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE; // Combined write state

const WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE;
const WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED;
const WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE;
const WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE;
const WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED;
const WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE;
const WRITE_ACTIVE_AND_SYNC = WRITE_ACTIVE | WRITE_SYNC;
const WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE;
const WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE;
const asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator');

let WritableState = /*#__PURE__*/function () {
  function WritableState(stream) {
    let {
      highWaterMark = 16384,
      map = null,
      mapWritable,
      byteLength,
      byteLengthWritable
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, WritableState);

    this.stream = stream;
    this.queue = new FIFO();
    this.highWaterMark = highWaterMark;
    this.buffered = 0;
    this.error = null;
    this.pipeline = null;
    this.byteLength = byteLengthWritable || byteLength || defaultByteLength;
    this.map = mapWritable || map;
    this.afterWrite = afterWrite.bind(this);
    this.afterUpdateNextTick = updateWriteNT.bind(this);
  }

  _createClass(WritableState, [{
    key: "ended",
    get: function () {
      return (this.stream._duplexState & WRITE_DONE) !== 0;
    }
  }, {
    key: "push",
    value: function push(data) {
      if (this.map !== null) data = this.map(data);
      this.buffered += this.byteLength(data);
      this.queue.push(data);

      if (this.buffered < this.highWaterMark) {
        this.stream._duplexState |= WRITE_QUEUED;
        return true;
      }

      this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED;
      return false;
    }
  }, {
    key: "shift",
    value: function shift() {
      const data = this.queue.shift();
      const stream = this.stream;
      this.buffered -= this.byteLength(data);
      if (this.buffered === 0) stream._duplexState &= WRITE_NOT_QUEUED;
      return data;
    }
  }, {
    key: "end",
    value: function end(data) {
      if (typeof data === 'function') this.stream.once('finish', data);else if (data !== undefined && data !== null) this.push(data);
      this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY;
    }
  }, {
    key: "autoBatch",
    value: function autoBatch(data, cb) {
      const buffer = [];
      const stream = this.stream;
      buffer.push(data);

      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {
        buffer.push(stream._writableState.shift());
      }

      if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null);

      stream._writev(buffer, cb);
    }
  }, {
    key: "update",
    value: function update() {
      const stream = this.stream;

      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {
        const data = this.shift();
        stream._duplexState |= WRITE_ACTIVE_AND_SYNC;

        stream._write(data, this.afterWrite);

        stream._duplexState &= WRITE_NOT_SYNC;
      }

      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();
    }
  }, {
    key: "updateNonPrimary",
    value: function updateNonPrimary() {
      const stream = this.stream;

      if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {
        stream._duplexState = (stream._duplexState | WRITE_ACTIVE) & WRITE_NOT_FINISHING;

        stream._final(afterFinal.bind(this));

        return;
      }

      if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
        if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
          stream._duplexState |= ACTIVE;

          stream._destroy(afterDestroy.bind(this));
        }

        return;
      }

      if ((stream._duplexState & IS_OPENING) === OPENING) {
        stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;

        stream._open(afterOpen.bind(this));
      }
    }
  }, {
    key: "updateNextTick",
    value: function updateNextTick() {
      if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return;
      this.stream._duplexState |= WRITE_NEXT_TICK;
      queueTick(this.afterUpdateNextTick);
    }
  }]);

  return WritableState;
}();

let ReadableState = /*#__PURE__*/function () {
  function ReadableState(stream) {
    let {
      highWaterMark = 16384,
      map = null,
      mapReadable,
      byteLength,
      byteLengthReadable
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, ReadableState);

    this.stream = stream;
    this.queue = new FIFO();
    this.highWaterMark = highWaterMark;
    this.buffered = 0;
    this.error = null;
    this.pipeline = null;
    this.byteLength = byteLengthReadable || byteLength || defaultByteLength;
    this.map = mapReadable || map;
    this.pipeTo = null;
    this.afterRead = afterRead.bind(this);
    this.afterUpdateNextTick = updateReadNT.bind(this);
  }

  _createClass(ReadableState, [{
    key: "ended",
    get: function () {
      return (this.stream._duplexState & READ_DONE) !== 0;
    }
  }, {
    key: "pipe",
    value: function pipe(pipeTo, cb) {
      if (this.pipeTo !== null) throw new Error('Can only pipe to one destination');
      if (typeof cb !== 'function') cb = null;
      this.stream._duplexState |= READ_PIPE_DRAINED;
      this.pipeTo = pipeTo;
      this.pipeline = new Pipeline(this.stream, pipeTo, cb);
      if (cb) this.stream.on('error', noop); // We already error handle this so supress crashes

      if (isStreamx(pipeTo)) {
        pipeTo._writableState.pipeline = this.pipeline;
        if (cb) pipeTo.on('error', noop); // We already error handle this so supress crashes

        pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)); // TODO: just call finished from pipeTo itself
      } else {
        const onerror = this.pipeline.done.bind(this.pipeline, pipeTo);
        const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null); // onclose has a weird bool arg

        pipeTo.on('error', onerror);
        pipeTo.on('close', onclose);
        pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline));
      }

      pipeTo.on('drain', afterDrain.bind(this));
      this.stream.emit('piping', pipeTo);
      pipeTo.emit('pipe', this.stream);
    }
  }, {
    key: "push",
    value: function push(data) {
      const stream = this.stream;

      if (data === null) {
        this.highWaterMark = 0;
        stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED;
        return false;
      }

      if (this.map !== null) data = this.map(data);
      this.buffered += this.byteLength(data);
      this.queue.push(data);
      stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED;
      return this.buffered < this.highWaterMark;
    }
  }, {
    key: "shift",
    value: function shift() {
      const data = this.queue.shift();
      this.buffered -= this.byteLength(data);
      if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED;
      return data;
    }
  }, {
    key: "unshift",
    value: function unshift(data) {
      let tail;
      const pending = [];

      while ((tail = this.queue.shift()) !== undefined) {
        pending.push(tail);
      }

      this.push(data);

      for (let i = 0; i < pending.length; i++) {
        this.queue.push(pending[i]);
      }
    }
  }, {
    key: "read",
    value: function read() {
      const stream = this.stream;

      if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {
        const data = this.shift();
        if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED;
        if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data);
        return data;
      }

      return null;
    }
  }, {
    key: "drain",
    value: function drain() {
      const stream = this.stream;

      while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {
        const data = this.shift();
        if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED;
        if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data);
      }
    }
  }, {
    key: "update",
    value: function update() {
      const stream = this.stream;
      this.drain();

      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === 0) {
        stream._duplexState |= READ_ACTIVE_AND_SYNC_AND_NEEDS_PUSH;

        stream._read(this.afterRead);

        stream._duplexState &= READ_NOT_SYNC;
        if ((stream._duplexState & READ_ACTIVE) === 0) this.drain();
      }

      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {
        stream._duplexState |= READ_EMITTED_READABLE;
        stream.emit('readable');
      }

      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();
    }
  }, {
    key: "updateNonPrimary",
    value: function updateNonPrimary() {
      const stream = this.stream;

      if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {
        stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING;
        stream.emit('end');
        if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING;
        if (this.pipeTo !== null) this.pipeTo.end();
      }

      if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
        if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
          stream._duplexState |= ACTIVE;

          stream._destroy(afterDestroy.bind(this));
        }

        return;
      }

      if ((stream._duplexState & IS_OPENING) === OPENING) {
        stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;

        stream._open(afterOpen.bind(this));
      }
    }
  }, {
    key: "updateNextTick",
    value: function updateNextTick() {
      if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return;
      this.stream._duplexState |= READ_NEXT_TICK;
      queueTick(this.afterUpdateNextTick);
    }
  }]);

  return ReadableState;
}();

let TransformState = /*#__PURE__*/_createClass(function TransformState(stream) {
  _classCallCheck(this, TransformState);

  this.data = null;
  this.afterTransform = afterTransform.bind(stream);
  this.afterFinal = null;
});

let Pipeline = /*#__PURE__*/function () {
  function Pipeline(src, dst, cb) {
    _classCallCheck(this, Pipeline);

    this.from = src;
    this.to = dst;
    this.afterPipe = cb;
    this.error = null;
    this.pipeToFinished = false;
  }

  _createClass(Pipeline, [{
    key: "finished",
    value: function finished() {
      this.pipeToFinished = true;
    }
  }, {
    key: "done",
    value: function done(stream, err) {
      if (err) this.error = err;

      if (stream === this.to) {
        this.to = null;

        if (this.from !== null) {
          if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {
            this.from.destroy(this.error || new Error('Writable stream closed prematurely'));
          }

          return;
        }
      }

      if (stream === this.from) {
        this.from = null;

        if (this.to !== null) {
          if ((stream._duplexState & READ_DONE) === 0) {
            this.to.destroy(this.error || new Error('Readable stream closed before ending'));
          }

          return;
        }
      }

      if (this.afterPipe !== null) this.afterPipe(this.error);
      this.to = this.from = this.afterPipe = null;
    }
  }]);

  return Pipeline;
}();

function afterDrain() {
  this.stream._duplexState |= READ_PIPE_DRAINED;
  if ((this.stream._duplexState & READ_ACTIVE_AND_SYNC) === 0) this.updateNextTick();else this.drain();
}

function afterFinal(err) {
  const stream = this.stream;
  if (err) stream.destroy(err);

  if ((stream._duplexState & DESTROY_STATUS) === 0) {
    stream._duplexState |= WRITE_DONE;
    stream.emit('finish');
  }

  if ((stream._duplexState & AUTO_DESTROY) === DONE) {
    stream._duplexState |= DESTROYING;
  }

  stream._duplexState &= WRITE_NOT_ACTIVE;
  this.update();
}

function afterDestroy(err) {
  const stream = this.stream;
  if (!err && this.error !== STREAM_DESTROYED) err = this.error;
  if (err) stream.emit('error', err);
  stream._duplexState |= DESTROYED;
  stream.emit('close');
  const rs = stream._readableState;
  const ws = stream._writableState;
  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err);
  if (ws !== null && ws.pipeline !== null) ws.pipeline.done(stream, err);
}

function afterWrite(err) {
  const stream = this.stream;
  if (err) stream.destroy(err);
  stream._duplexState &= WRITE_NOT_ACTIVE;

  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {
    stream._duplexState &= WRITE_DRAINED;

    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {
      stream.emit('drain');
    }
  }

  if ((stream._duplexState & WRITE_SYNC) === 0) this.update();
}

function afterRead(err) {
  if (err) this.stream.destroy(err);
  this.stream._duplexState &= READ_NOT_ACTIVE;
  if ((this.stream._duplexState & READ_SYNC) === 0) this.update();
}

function updateReadNT() {
  this.stream._duplexState &= READ_NOT_NEXT_TICK;
  this.update();
}

function updateWriteNT() {
  this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
  this.update();
}

function afterOpen(err) {
  const stream = this.stream;
  if (err) stream.destroy(err);

  if ((stream._duplexState & DESTROYING) === 0) {
    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY;
    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY;
    stream.emit('open');
  }

  stream._duplexState &= NOT_ACTIVE;

  if (stream._writableState !== null) {
    stream._writableState.update();
  }

  if (stream._readableState !== null) {
    stream._readableState.update();
  }
}

function afterTransform(err, data) {
  if (data !== undefined && data !== null) this.push(data);

  this._writableState.afterWrite(err);
}

let Stream = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Stream, _EventEmitter);

  var _super = _createSuper(Stream);

  function Stream(opts) {
    var _this;

    _classCallCheck(this, Stream);

    _this = _super.call(this);
    _this._duplexState = 0;
    _this._readableState = null;
    _this._writableState = null;

    if (opts) {
      if (opts.open) _this._open = opts.open;
      if (opts.destroy) _this._destroy = opts.destroy;
      if (opts.predestroy) _this._predestroy = opts.predestroy;

      if (opts.signal) {
        opts.signal.addEventListener('abort', abort.bind(_assertThisInitialized(_this)));
      }
    }

    return _this;
  }

  _createClass(Stream, [{
    key: "_open",
    value: function _open(cb) {
      cb(null);
    }
  }, {
    key: "_destroy",
    value: function _destroy(cb) {
      cb(null);
    }
  }, {
    key: "_predestroy",
    value: function _predestroy() {// does nothing
    }
  }, {
    key: "readable",
    get: function () {
      return this._readableState !== null ? true : undefined;
    }
  }, {
    key: "writable",
    get: function () {
      return this._writableState !== null ? true : undefined;
    }
  }, {
    key: "destroyed",
    get: function () {
      return (this._duplexState & DESTROYED) !== 0;
    }
  }, {
    key: "destroying",
    get: function () {
      return (this._duplexState & DESTROY_STATUS) !== 0;
    }
  }, {
    key: "destroy",
    value: function destroy(err) {
      if ((this._duplexState & DESTROY_STATUS) === 0) {
        if (!err) err = STREAM_DESTROYED;
        this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY;

        if (this._readableState !== null) {
          this._readableState.error = err;

          this._readableState.updateNextTick();
        }

        if (this._writableState !== null) {
          this._writableState.error = err;

          this._writableState.updateNextTick();
        }

        this._predestroy();
      }
    }
  }, {
    key: "on",
    value: function on(name, fn) {
      if (this._readableState !== null) {
        if (name === 'data') {
          this._duplexState |= READ_EMIT_DATA | READ_RESUMED;

          this._readableState.updateNextTick();
        }

        if (name === 'readable') {
          this._duplexState |= READ_EMIT_READABLE;

          this._readableState.updateNextTick();
        }
      }

      if (this._writableState !== null) {
        if (name === 'drain') {
          this._duplexState |= WRITE_EMIT_DRAIN;

          this._writableState.updateNextTick();
        }
      }

      return _get(_getPrototypeOf(Stream.prototype), "on", this).call(this, name, fn);
    }
  }]);

  return Stream;
}(EventEmitter);

let Readable = /*#__PURE__*/function (_Stream) {
  _inherits(Readable, _Stream);

  var _super2 = _createSuper(Readable);

  function Readable(opts) {
    var _this2;

    _classCallCheck(this, Readable);

    _this2 = _super2.call(this, opts);
    _this2._duplexState |= OPENING | WRITE_DONE;
    _this2._readableState = new ReadableState(_assertThisInitialized(_this2), opts);

    if (opts) {
      if (opts.read) _this2._read = opts.read;
      if (opts.eagerOpen) _this2.resume().pause();
    }

    return _this2;
  }

  _createClass(Readable, [{
    key: "_read",
    value: function _read(cb) {
      cb(null);
    }
  }, {
    key: "pipe",
    value: function pipe(dest, cb) {
      this._readableState.pipe(dest, cb);

      this._readableState.updateNextTick();

      return dest;
    }
  }, {
    key: "read",
    value: function read() {
      this._readableState.updateNextTick();

      return this._readableState.read();
    }
  }, {
    key: "push",
    value: function push(data) {
      this._readableState.updateNextTick();

      return this._readableState.push(data);
    }
  }, {
    key: "unshift",
    value: function unshift(data) {
      this._readableState.updateNextTick();

      return this._readableState.unshift(data);
    }
  }, {
    key: "resume",
    value: function resume() {
      this._duplexState |= READ_RESUMED;

      this._readableState.updateNextTick();

      return this;
    }
  }, {
    key: "pause",
    value: function pause() {
      this._duplexState &= READ_PAUSED;
      return this;
    }
  }, {
    key: asyncIterator,
    value: function () {
      const stream = this;
      let error = null;
      let promiseResolve = null;
      let promiseReject = null;
      this.on('error', err => {
        error = err;
      });
      this.on('readable', onreadable);
      this.on('close', onclose);
      return {
        [asyncIterator]() {
          return this;
        },

        next() {
          return new Promise(function (resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
            const data = stream.read();
            if (data !== null) ondata(data);else if ((stream._duplexState & DESTROYED) !== 0) ondata(null);
          });
        },

        return() {
          return destroy(null);
        },

        throw(err) {
          return destroy(err);
        }

      };

      function onreadable() {
        if (promiseResolve !== null) ondata(stream.read());
      }

      function onclose() {
        if (promiseResolve !== null) ondata(null);
      }

      function ondata(data) {
        if (promiseReject === null) return;
        if (error) promiseReject(error);else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED);else promiseResolve({
          value: data,
          done: data === null
        });
        promiseReject = promiseResolve = null;
      }

      function destroy(err) {
        stream.destroy(err);
        return new Promise((resolve, reject) => {
          if (stream._duplexState & DESTROYED) return resolve({
            value: undefined,
            done: true
          });
          stream.once('close', function () {
            if (err) reject(err);else resolve({
              value: undefined,
              done: true
            });
          });
        });
      }
    }
  }], [{
    key: "_fromAsyncIterator",
    value: function _fromAsyncIterator(ite, opts) {
      let destroy;
      const rs = new Readable(_objectSpread(_objectSpread({}, opts), {}, {
        read(cb) {
          ite.next().then(push).then(cb.bind(null, null)).catch(cb);
        },

        predestroy() {
          destroy = ite.return();
        },

        destroy(cb) {
          if (!destroy) return cb(null);
          destroy.then(cb.bind(null, null)).catch(cb);
        }

      }));
      return rs;

      function push(data) {
        if (data.done) rs.push(null);else rs.push(data.value);
      }
    }
  }, {
    key: "from",
    value: function from(data, opts) {
      if (isReadStreamx(data)) return data;
      if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts);
      if (!Array.isArray(data)) data = data === undefined ? [] : [data];
      let i = 0;
      return new Readable(_objectSpread(_objectSpread({}, opts), {}, {
        read(cb) {
          this.push(i === data.length ? null : data[i++]);
          cb(null);
        }

      }));
    }
  }, {
    key: "isBackpressured",
    value: function isBackpressured(rs) {
      return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark;
    }
  }, {
    key: "isPaused",
    value: function isPaused(rs) {
      return (rs._duplexState & READ_RESUMED) === 0;
    }
  }]);

  return Readable;
}(Stream);

let Writable = /*#__PURE__*/function (_Stream2) {
  _inherits(Writable, _Stream2);

  var _super3 = _createSuper(Writable);

  function Writable(opts) {
    var _this3;

    _classCallCheck(this, Writable);

    _this3 = _super3.call(this, opts);
    _this3._duplexState |= OPENING | READ_DONE;
    _this3._writableState = new WritableState(_assertThisInitialized(_this3), opts);

    if (opts) {
      if (opts.writev) _this3._writev = opts.writev;
      if (opts.write) _this3._write = opts.write;
      if (opts.final) _this3._final = opts.final;
    }

    return _this3;
  }

  _createClass(Writable, [{
    key: "_writev",
    value: function _writev(batch, cb) {
      cb(null);
    }
  }, {
    key: "_write",
    value: function _write(data, cb) {
      this._writableState.autoBatch(data, cb);
    }
  }, {
    key: "_final",
    value: function _final(cb) {
      cb(null);
    }
  }, {
    key: "write",
    value: function write(data) {
      this._writableState.updateNextTick();

      return this._writableState.push(data);
    }
  }, {
    key: "end",
    value: function end(data) {
      this._writableState.updateNextTick();

      this._writableState.end(data);

      return this;
    }
  }], [{
    key: "isBackpressured",
    value: function isBackpressured(ws) {
      return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0;
    }
  }]);

  return Writable;
}(Stream);

let Duplex = /*#__PURE__*/function (_Readable) {
  _inherits(Duplex, _Readable);

  var _super4 = _createSuper(Duplex);

  // and Writable
  function Duplex(opts) {
    var _this4;

    _classCallCheck(this, Duplex);

    _this4 = _super4.call(this, opts);
    _this4._duplexState = OPENING;
    _this4._writableState = new WritableState(_assertThisInitialized(_this4), opts);

    if (opts) {
      if (opts.writev) _this4._writev = opts.writev;
      if (opts.write) _this4._write = opts.write;
      if (opts.final) _this4._final = opts.final;
    }

    return _this4;
  }

  _createClass(Duplex, [{
    key: "_writev",
    value: function _writev(batch, cb) {
      cb(null);
    }
  }, {
    key: "_write",
    value: function _write(data, cb) {
      this._writableState.autoBatch(data, cb);
    }
  }, {
    key: "_final",
    value: function _final(cb) {
      cb(null);
    }
  }, {
    key: "write",
    value: function write(data) {
      this._writableState.updateNextTick();

      return this._writableState.push(data);
    }
  }, {
    key: "end",
    value: function end(data) {
      this._writableState.updateNextTick();

      this._writableState.end(data);

      return this;
    }
  }]);

  return Duplex;
}(Readable);

let Transform = /*#__PURE__*/function (_Duplex) {
  _inherits(Transform, _Duplex);

  var _super5 = _createSuper(Transform);

  function Transform(opts) {
    var _this5;

    _classCallCheck(this, Transform);

    _this5 = _super5.call(this, opts);
    _this5._transformState = new TransformState(_assertThisInitialized(_this5));

    if (opts) {
      if (opts.transform) _this5._transform = opts.transform;
      if (opts.flush) _this5._flush = opts.flush;
    }

    return _this5;
  }

  _createClass(Transform, [{
    key: "_write",
    value: function _write(data, cb) {
      if (this._readableState.buffered >= this._readableState.highWaterMark) {
        this._transformState.data = data;
      } else {
        this._transform(data, this._transformState.afterTransform);
      }
    }
  }, {
    key: "_read",
    value: function _read(cb) {
      if (this._transformState.data !== null) {
        const data = this._transformState.data;
        this._transformState.data = null;
        cb(null);

        this._transform(data, this._transformState.afterTransform);
      } else {
        cb(null);
      }
    }
  }, {
    key: "_transform",
    value: function _transform(data, cb) {
      cb(null, data);
    }
  }, {
    key: "_flush",
    value: function _flush(cb) {
      cb(null);
    }
  }, {
    key: "_final",
    value: function _final(cb) {
      this._transformState.afterFinal = cb;

      this._flush(transformAfterFlush.bind(this));
    }
  }]);

  return Transform;
}(Duplex);

let PassThrough = /*#__PURE__*/function (_Transform) {
  _inherits(PassThrough, _Transform);

  var _super6 = _createSuper(PassThrough);

  function PassThrough() {
    _classCallCheck(this, PassThrough);

    return _super6.apply(this, arguments);
  }

  return _createClass(PassThrough);
}(Transform);

function transformAfterFlush(err, data) {
  const cb = this._transformState.afterFinal;
  if (err) return cb(err);
  if (data !== null && data !== undefined) this.push(data);
  this.push(null);
  cb(null);
}

function pipelinePromise() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  return new Promise((resolve, reject) => {
    return pipeline.apply(void 0, streams.concat([err => {
      if (err) return reject(err);
      resolve();
    }]));
  });
}

function pipeline(stream) {
  for (var _len2 = arguments.length, streams = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    streams[_key2 - 1] = arguments[_key2];
  }

  const all = Array.isArray(stream) ? [].concat(_toConsumableArray(stream), streams) : [stream].concat(streams);
  const done = all.length && typeof all[all.length - 1] === 'function' ? all.pop() : null;
  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams');
  let src = all[0];
  let dest = null;
  let error = null;

  for (let i = 1; i < all.length; i++) {
    dest = all[i];

    if (isStreamx(src)) {
      src.pipe(dest, onerror);
    } else {
      errorHandle(src, true, i > 1, onerror);
      src.pipe(dest);
    }

    src = dest;
  }

  if (done) {
    let fin = false;
    dest.on('finish', () => {
      fin = true;
    });
    dest.on('error', err => {
      error = error || err;
    });
    dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)));
  }

  return dest;

  function errorHandle(s, rd, wr, onerror) {
    s.on('error', onerror);
    s.on('close', onclose);

    function onclose() {
      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE);
      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE);
    }
  }

  function onerror(err) {
    if (!err || error) return;
    error = err;

    for (const s of all) {
      s.destroy(err);
    }
  }
}

function isStream(stream) {
  return !!stream._readableState || !!stream._writableState;
}

function isStreamx(stream) {
  return typeof stream._duplexState === 'number' && isStream(stream);
}

function isReadStreamx(stream) {
  return isStreamx(stream) && stream.readable;
}

function isTypedArray(data) {
  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number';
}

function defaultByteLength(data) {
  return isTypedArray(data) ? data.byteLength : 1024;
}

function noop() {}

function abort() {
  this.destroy(new Error('Stream aborted.'));
}

module.exports = {
  pipeline,
  pipelinePromise,
  isStream,
  isStreamx,
  Stream,
  Writable,
  Readable,
  Duplex,
  Transform,
  // Export PassThrough for compatibility with Node.js core's stream module
  PassThrough
};

/***/ }),

/***/ "./node_modules/thirty-two/lib/thirty-two/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/thirty-two/lib/thirty-two/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*                                                                              
Copyright (c) 2011, Chris Umbel

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in      
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN 
THE SOFTWARE.
*/
var base32 = __webpack_require__(/*! ./thirty-two */ "./node_modules/thirty-two/lib/thirty-two/thirty-two.js");

exports.encode = base32.encode;
exports.decode = base32.decode;

/***/ }),

/***/ "./node_modules/thirty-two/lib/thirty-two/thirty-two.js":
/*!**************************************************************!*\
  !*** ./node_modules/thirty-two/lib/thirty-two/thirty-two.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
/*
Copyright (c) 2011, Chris Umbel

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/


var charTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
var byteTable = [0xff, 0xff, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff];

function quintetCount(buff) {
  var quintets = Math.floor(buff.length / 5);
  return buff.length % 5 === 0 ? quintets : quintets + 1;
}

exports.encode = function (plain) {
  if (!Buffer.isBuffer(plain)) {
    plain = new Buffer(plain);
  }

  var i = 0;
  var j = 0;
  var shiftIndex = 0;
  var digit = 0;
  var encoded = new Buffer(quintetCount(plain) * 8);
  /* byte by byte isn't as pretty as quintet by quintet but tests a bit
      faster. will have to revisit. */

  while (i < plain.length) {
    var current = plain[i];

    if (shiftIndex > 3) {
      digit = current & 0xff >> shiftIndex;
      shiftIndex = (shiftIndex + 5) % 8;
      digit = digit << shiftIndex | (i + 1 < plain.length ? plain[i + 1] : 0) >> 8 - shiftIndex;
      i++;
    } else {
      digit = current >> 8 - (shiftIndex + 5) & 0x1f;
      shiftIndex = (shiftIndex + 5) % 8;
      if (shiftIndex === 0) i++;
    }

    encoded[j] = charTable.charCodeAt(digit);
    j++;
  }

  for (i = j; i < encoded.length; i++) {
    encoded[i] = 0x3d; //'='.charCodeAt(0)
  }

  return encoded;
};

exports.decode = function (encoded) {
  var shiftIndex = 0;
  var plainDigit = 0;
  var plainChar;
  var plainPos = 0;

  if (!Buffer.isBuffer(encoded)) {
    encoded = new Buffer(encoded);
  }

  var decoded = new Buffer(Math.ceil(encoded.length * 5 / 8));
  /* byte by byte isn't as pretty as octet by octet but tests a bit
      faster. will have to revisit. */

  for (var i = 0; i < encoded.length; i++) {
    if (encoded[i] === 0x3d) {
      //'='
      break;
    }

    var encodedByte = encoded[i] - 0x30;

    if (encodedByte < byteTable.length) {
      plainDigit = byteTable[encodedByte];

      if (shiftIndex <= 3) {
        shiftIndex = (shiftIndex + 5) % 8;

        if (shiftIndex === 0) {
          plainChar |= plainDigit;
          decoded[plainPos] = plainChar;
          plainPos++;
          plainChar = 0;
        } else {
          plainChar |= 0xff & plainDigit << 8 - shiftIndex;
        }
      } else {
        shiftIndex = (shiftIndex + 5) % 8;
        plainChar |= 0xff & plainDigit >>> shiftIndex;
        decoded[plainPos] = plainChar;
        plainPos++;
        plainChar = 0xff & plainDigit << 8 - shiftIndex;
      }
    } else {
      throw new Error('Invalid input - it is not base32 encoded string');
    }
  }

  return decoded.slice(0, plainPos);
};

/***/ }),

/***/ "./node_modules/throughput/index.js":
/*!******************************************!*\
  !*** ./node_modules/throughput/index.js ***!
  \******************************************/
/***/ ((module) => {

const maxTick = 65535;
const resolution = 10;
const timeDiff = 1000 / resolution;

function getTick(start) {
  return (+Date.now() - start) / timeDiff & 65535;
}

module.exports = function (seconds) {
  const start = +Date.now();
  const size = resolution * (seconds || 5);
  const buffer = [0];
  let pointer = 1;
  let last = getTick(start) - 1 & maxTick;
  return function (delta) {
    const tick = getTick(start);
    let dist = tick - last & maxTick;
    if (dist > size) dist = size;
    last = tick;

    while (dist--) {
      if (pointer === size) pointer = 0;
      buffer[pointer] = buffer[pointer === 0 ? size - 1 : pointer - 1];
      pointer++;
    }

    if (delta) buffer[pointer - 1] += delta;
    const top = buffer[pointer - 1];
    const btm = buffer.length < size ? 0 : buffer[pointer === size ? 0 : pointer];
    return buffer.length < resolution ? top : (top - btm) * resolution / buffer.length;
  };
};

/***/ }),

/***/ "./node_modules/to-arraybuffer/index.js":
/*!**********************************************!*\
  !*** ./node_modules/to-arraybuffer/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer);

module.exports = function (buf) {
  // If the buffer is backed by a Uint8Array, a faster version will work
  if (buf instanceof Uint8Array) {
    // If the buffer isn't a subarray, return the underlying ArrayBuffer
    if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
      return buf.buffer;
    } else if (typeof buf.buffer.slice === 'function') {
      // Otherwise we need to get a proper copy
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
  }

  if (Buffer.isBuffer(buf)) {
    // This is the slow version that will work with any Buffer
    // implementation (even in old browsers)
    var arrayCopy = new Uint8Array(buf.length);
    var len = buf.length;

    for (var i = 0; i < len; i++) {
      arrayCopy[i] = buf[i];
    }

    return arrayCopy.buffer;
  } else {
    throw new Error('Argument must be a Buffer');
  }
};

/***/ }),

/***/ "./node_modules/torrent-discovery/index.js":
/*!*************************************************!*\
  !*** ./node_modules/torrent-discovery/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/*! torrent-discovery. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
const debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")('torrent-discovery');

const DHT = __webpack_require__(/*! bittorrent-dht/client */ "?42e5"); // empty object in browser


const EventEmitter = (__webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter);

const parallel = __webpack_require__(/*! run-parallel */ "./node_modules/run-parallel/index.js");

const Tracker = __webpack_require__(/*! bittorrent-tracker/client */ "./node_modules/bittorrent-tracker/client.js");

const LSD = __webpack_require__(/*! bittorrent-lsd */ "?72f0");

let Discovery = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Discovery, _EventEmitter);

  var _super = _createSuper(Discovery);

  function Discovery(opts) {
    var _this;

    _classCallCheck(this, Discovery);

    _this = _super.call(this);
    if (!opts.peerId) throw new Error('Option `peerId` is required');
    if (!opts.infoHash) throw new Error('Option `infoHash` is required');
    if (!process.browser && !opts.port) throw new Error('Option `port` is required');
    _this.peerId = typeof opts.peerId === 'string' ? opts.peerId : opts.peerId.toString('hex');
    _this.infoHash = typeof opts.infoHash === 'string' ? opts.infoHash.toLowerCase() : opts.infoHash.toString('hex');
    _this._port = opts.port; // torrent port

    _this._userAgent = opts.userAgent; // User-Agent header for http requests

    _this.destroyed = false;
    _this._announce = opts.announce || [];
    _this._intervalMs = opts.intervalMs || 15 * 60 * 1000;
    _this._trackerOpts = null;
    _this._dhtAnnouncing = false;
    _this._dhtTimeout = false;
    _this._internalDHT = false; // is the DHT created internally?

    _this._onWarning = err => {
      _this.emit('warning', err);
    };

    _this._onError = err => {
      _this.emit('error', err);
    };

    _this._onDHTPeer = (peer, infoHash) => {
      if (infoHash.toString('hex') !== _this.infoHash) return;

      _this.emit('peer', "".concat(peer.host, ":").concat(peer.port), 'dht');
    };

    _this._onTrackerPeer = peer => {
      _this.emit('peer', peer, 'tracker');
    };

    _this._onTrackerAnnounce = () => {
      _this.emit('trackerAnnounce');
    };

    _this._onLSDPeer = (peer, infoHash) => {
      _this.emit('peer', peer, 'lsd');
    };

    const createDHT = (port, opts) => {
      const dht = new DHT(opts);
      dht.on('warning', _this._onWarning);
      dht.on('error', _this._onError);
      dht.listen(port);
      _this._internalDHT = true;
      return dht;
    };

    if (opts.tracker === false) {
      _this.tracker = null;
    } else if (opts.tracker && typeof opts.tracker === 'object') {
      _this._trackerOpts = Object.assign({}, opts.tracker);
      _this.tracker = _this._createTracker();
    } else {
      _this.tracker = _this._createTracker();
    }

    if (opts.dht === false || typeof DHT !== 'function') {
      _this.dht = null;
    } else if (opts.dht && typeof opts.dht.addNode === 'function') {
      _this.dht = opts.dht;
    } else if (opts.dht && typeof opts.dht === 'object') {
      _this.dht = createDHT(opts.dhtPort, opts.dht);
    } else {
      _this.dht = createDHT(opts.dhtPort);
    }

    if (_this.dht) {
      _this.dht.on('peer', _this._onDHTPeer);

      _this._dhtAnnounce();
    }

    if (opts.lsd === false || typeof LSD !== 'function') {
      _this.lsd = null;
    } else {
      _this.lsd = _this._createLSD();
    }

    return _this;
  }

  _createClass(Discovery, [{
    key: "updatePort",
    value: function updatePort(port) {
      if (port === this._port) return;
      this._port = port;
      if (this.dht) this._dhtAnnounce();

      if (this.tracker) {
        this.tracker.stop();
        this.tracker.destroy(() => {
          this.tracker = this._createTracker();
        });
      }
    }
  }, {
    key: "complete",
    value: function complete(opts) {
      if (this.tracker) {
        this.tracker.complete(opts);
      }
    }
  }, {
    key: "destroy",
    value: function destroy(cb) {
      if (this.destroyed) return;
      this.destroyed = true;
      clearTimeout(this._dhtTimeout);
      const tasks = [];

      if (this.tracker) {
        this.tracker.stop();
        this.tracker.removeListener('warning', this._onWarning);
        this.tracker.removeListener('error', this._onError);
        this.tracker.removeListener('peer', this._onTrackerPeer);
        this.tracker.removeListener('update', this._onTrackerAnnounce);
        tasks.push(cb => {
          this.tracker.destroy(cb);
        });
      }

      if (this.dht) {
        this.dht.removeListener('peer', this._onDHTPeer);
      }

      if (this._internalDHT) {
        this.dht.removeListener('warning', this._onWarning);
        this.dht.removeListener('error', this._onError);
        tasks.push(cb => {
          this.dht.destroy(cb);
        });
      }

      if (this.lsd) {
        this.lsd.removeListener('warning', this._onWarning);
        this.lsd.removeListener('error', this._onError);
        this.lsd.removeListener('peer', this._onLSDPeer);
        tasks.push(cb => {
          this.lsd.destroy(cb);
        });
      }

      parallel(tasks, cb); // cleanup

      this.dht = null;
      this.tracker = null;
      this.lsd = null;
      this._announce = null;
    }
  }, {
    key: "_createTracker",
    value: function _createTracker() {
      const opts = Object.assign({}, this._trackerOpts, {
        infoHash: this.infoHash,
        announce: this._announce,
        peerId: this.peerId,
        port: this._port,
        userAgent: this._userAgent
      });
      const tracker = new Tracker(opts);
      tracker.on('warning', this._onWarning);
      tracker.on('error', this._onError);
      tracker.on('peer', this._onTrackerPeer);
      tracker.on('update', this._onTrackerAnnounce);
      tracker.setInterval(this._intervalMs);
      tracker.start();
      return tracker;
    }
  }, {
    key: "_dhtAnnounce",
    value: function _dhtAnnounce() {
      if (this._dhtAnnouncing) return;
      debug('dht announce');
      this._dhtAnnouncing = true;
      clearTimeout(this._dhtTimeout);
      this.dht.announce(this.infoHash, this._port, err => {
        this._dhtAnnouncing = false;
        debug('dht announce complete');
        if (err) this.emit('warning', err);
        this.emit('dhtAnnounce');

        if (!this.destroyed) {
          this._dhtTimeout = setTimeout(() => {
            this._dhtAnnounce();
          }, this._intervalMs + Math.floor(Math.random() * this._intervalMs / 5));
          if (this._dhtTimeout.unref) this._dhtTimeout.unref();
        }
      });
    }
  }, {
    key: "_createLSD",
    value: function _createLSD() {
      const opts = Object.assign({}, {
        infoHash: this.infoHash,
        peerId: this.peerId,
        port: this._port
      });
      const lsd = new LSD(opts);
      lsd.on('warning', this._onWarning);
      lsd.on('error', this._onError);
      lsd.on('peer', this._onLSDPeer);
      lsd.start();
      return lsd;
    }
  }]);

  return Discovery;
}(EventEmitter);

module.exports = Discovery;

/***/ }),

/***/ "./node_modules/torrent-piece/index.js":
/*!*********************************************!*\
  !*** ./node_modules/torrent-piece/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/*! torrent-piece. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
const BLOCK_LENGTH = 1 << 14;

let Piece = /*#__PURE__*/function () {
  function Piece(length) {
    _classCallCheck(this, Piece);

    this.length = length;
    this.missing = length;
    this.sources = null;
    this._chunks = Math.ceil(length / BLOCK_LENGTH);
    this._remainder = length % BLOCK_LENGTH || BLOCK_LENGTH;
    this._buffered = 0;
    this._buffer = null;
    this._cancellations = null;
    this._reservations = 0;
    this._flushed = false;
  }

  _createClass(Piece, [{
    key: "chunkLength",
    value: function chunkLength(i) {
      return i === this._chunks - 1 ? this._remainder : BLOCK_LENGTH;
    }
  }, {
    key: "chunkLengthRemaining",
    value: function chunkLengthRemaining(i) {
      return this.length - i * BLOCK_LENGTH;
    }
  }, {
    key: "chunkOffset",
    value: function chunkOffset(i) {
      return i * BLOCK_LENGTH;
    }
  }, {
    key: "reserve",
    value: function reserve() {
      if (!this.init()) return -1;
      if (this._cancellations.length) return this._cancellations.pop();
      if (this._reservations < this._chunks) return this._reservations++;
      return -1;
    }
  }, {
    key: "reserveRemaining",
    value: function reserveRemaining() {
      if (!this.init()) return -1;

      if (this._cancellations.length || this._reservations < this._chunks) {
        let min = this._reservations;

        while (this._cancellations.length) {
          min = Math.min(min, this._cancellations.pop());
        }

        this._reservations = this._chunks;
        return min;
      }

      return -1;
    }
  }, {
    key: "cancel",
    value: function cancel(i) {
      if (!this.init()) return;

      this._cancellations.push(i);
    }
  }, {
    key: "cancelRemaining",
    value: function cancelRemaining(i) {
      if (!this.init()) return;
      this._reservations = i;
    }
  }, {
    key: "get",
    value: function get(i) {
      if (!this.init()) return null;
      return this._buffer[i];
    }
  }, {
    key: "set",
    value: function set(i, data, source) {
      if (!this.init()) return false;
      const len = data.length;
      const blocks = Math.ceil(len / BLOCK_LENGTH);

      for (let j = 0; j < blocks; j++) {
        if (!this._buffer[i + j]) {
          const offset = j * BLOCK_LENGTH;
          const splitData = data.slice(offset, offset + BLOCK_LENGTH);
          this._buffered++;
          this._buffer[i + j] = splitData;
          this.missing -= splitData.length;

          if (!this.sources.includes(source)) {
            this.sources.push(source);
          }
        }
      }

      return this._buffered === this._chunks;
    }
  }, {
    key: "flush",
    value: function flush() {
      if (!this._buffer || this._chunks !== this._buffered) return null;
      const buffer = Buffer.concat(this._buffer, this.length);
      this._buffer = null;
      this._cancellations = null;
      this.sources = null;
      this._flushed = true;
      return buffer;
    }
  }, {
    key: "init",
    value: function init() {
      if (this._flushed) return false;
      if (this._buffer) return true;
      this._buffer = new Array(this._chunks);
      this._cancellations = [];
      this.sources = [];
      return true;
    }
  }]);

  return Piece;
}();

Object.defineProperty(Piece, 'BLOCK_LENGTH', {
  value: BLOCK_LENGTH
});
module.exports = Piece;

/***/ }),

/***/ "./node_modules/uint64be/index.js":
/*!****************************************!*\
  !*** ./node_modules/uint64be/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var bufferAlloc = __webpack_require__(/*! buffer-alloc */ "./node_modules/buffer-alloc/index.js");

var UINT_32_MAX = Math.pow(2, 32);

exports.encodingLength = function () {
  return 8;
};

exports.encode = function (num, buf, offset) {
  if (!buf) buf = bufferAlloc(8);
  if (!offset) offset = 0;
  var top = Math.floor(num / UINT_32_MAX);
  var rem = num - top * UINT_32_MAX;
  buf.writeUInt32BE(top, offset);
  buf.writeUInt32BE(rem, offset + 4);
  return buf;
};

exports.decode = function (buf, offset) {
  if (!offset) offset = 0;
  var top = buf.readUInt32BE(offset);
  var rem = buf.readUInt32BE(offset + 4);
  return top * UINT_32_MAX + rem;
};

exports.encode.bytes = 8;
exports.decode.bytes = 8;

/***/ }),

/***/ "./node_modules/unordered-array-remove/index.js":
/*!******************************************************!*\
  !*** ./node_modules/unordered-array-remove/index.js ***!
  \******************************************************/
/***/ ((module) => {

module.exports = remove;

function remove(arr, i) {
  if (i >= arr.length || i < 0) return;
  var last = arr.pop();

  if (i < arr.length) {
    var tmp = arr[i];
    arr[i] = last;
    return tmp;
  }

  return last;
}

/***/ }),

/***/ "./node_modules/url/node_modules/punycode/punycode.js":
/*!************************************************************!*\
  !*** ./node_modules/url/node_modules/punycode/punycode.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */
;

(function (root) {
  /** Detect free variables */
  var freeExports =  true && exports && !exports.nodeType && exports;
  var freeModule =  true && module && !module.nodeType && module;
  var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;

  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
    root = freeGlobal;
  }
  /**
   * The `punycode` object.
   * @name punycode
   * @type Object
   */


  var punycode,

  /** Highest positive signed 32-bit float value */
  maxInt = 2147483647,
      // aka. 0x7FFFFFFF or 2^31-1

  /** Bootstring parameters */
  base = 36,
      tMin = 1,
      tMax = 26,
      skew = 38,
      damp = 700,
      initialBias = 72,
      initialN = 128,
      // 0x80
  delimiter = '-',
      // '\x2D'

  /** Regular expressions */
  regexPunycode = /^xn--/,
      regexNonASCII = /[^\x20-\x7E]/,
      // unprintable ASCII chars + non-ASCII chars
  regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
      // RFC 3490 separators

  /** Error messages */
  errors = {
    'overflow': 'Overflow: input needs wider integers to process',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    'invalid-input': 'Invalid input'
  },

  /** Convenience shortcuts */
  baseMinusTMin = base - tMin,
      floor = Math.floor,
      stringFromCharCode = String.fromCharCode,

  /** Temporary variable */
  key;
  /*--------------------------------------------------------------------------*/

  /**
   * A generic error utility function.
   * @private
   * @param {String} type The error type.
   * @returns {Error} Throws a `RangeError` with the applicable error message.
   */

  function error(type) {
    throw RangeError(errors[type]);
  }
  /**
   * A generic `Array#map` utility function.
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function that gets called for every array
   * item.
   * @returns {Array} A new array of values returned by the callback function.
   */


  function map(array, fn) {
    var length = array.length;
    var result = [];

    while (length--) {
      result[length] = fn(array[length]);
    }

    return result;
  }
  /**
   * A simple `Array#map`-like wrapper to work with domain name strings or email
   * addresses.
   * @private
   * @param {String} domain The domain name or email address.
   * @param {Function} callback The function that gets called for every
   * character.
   * @returns {Array} A new string of characters returned by the callback
   * function.
   */


  function mapDomain(string, fn) {
    var parts = string.split('@');
    var result = '';

    if (parts.length > 1) {
      // In email addresses, only the domain name should be punycoded. Leave
      // the local part (i.e. everything up to `@`) intact.
      result = parts[0] + '@';
      string = parts[1];
    } // Avoid `split(regex)` for IE8 compatibility. See #17.


    string = string.replace(regexSeparators, '\x2E');
    var labels = string.split('.');
    var encoded = map(labels, fn).join('.');
    return result + encoded;
  }
  /**
   * Creates an array containing the numeric code points of each Unicode
   * character in the string. While JavaScript uses UCS-2 internally,
   * this function will convert a pair of surrogate halves (each of which
   * UCS-2 exposes as separate characters) into a single code point,
   * matching UTF-16.
   * @see `punycode.ucs2.encode`
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode.ucs2
   * @name decode
   * @param {String} string The Unicode input string (UCS-2).
   * @returns {Array} The new array of code points.
   */


  function ucs2decode(string) {
    var output = [],
        counter = 0,
        length = string.length,
        value,
        extra;

    while (counter < length) {
      value = string.charCodeAt(counter++);

      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        // high surrogate, and there is a next character
        extra = string.charCodeAt(counter++);

        if ((extra & 0xFC00) == 0xDC00) {
          // low surrogate
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
        } else {
          // unmatched surrogate; only append this code unit, in case the next
          // code unit is the high surrogate of a surrogate pair
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }

    return output;
  }
  /**
   * Creates a string based on an array of numeric code points.
   * @see `punycode.ucs2.decode`
   * @memberOf punycode.ucs2
   * @name encode
   * @param {Array} codePoints The array of numeric code points.
   * @returns {String} The new Unicode string (UCS-2).
   */


  function ucs2encode(array) {
    return map(array, function (value) {
      var output = '';

      if (value > 0xFFFF) {
        value -= 0x10000;
        output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
        value = 0xDC00 | value & 0x3FF;
      }

      output += stringFromCharCode(value);
      return output;
    }).join('');
  }
  /**
   * Converts a basic code point into a digit/integer.
   * @see `digitToBasic()`
   * @private
   * @param {Number} codePoint The basic numeric code point value.
   * @returns {Number} The numeric value of a basic code point (for use in
   * representing integers) in the range `0` to `base - 1`, or `base` if
   * the code point does not represent a value.
   */


  function basicToDigit(codePoint) {
    if (codePoint - 48 < 10) {
      return codePoint - 22;
    }

    if (codePoint - 65 < 26) {
      return codePoint - 65;
    }

    if (codePoint - 97 < 26) {
      return codePoint - 97;
    }

    return base;
  }
  /**
   * Converts a digit/integer into a basic code point.
   * @see `basicToDigit()`
   * @private
   * @param {Number} digit The numeric value of a basic code point.
   * @returns {Number} The basic code point whose value (when used for
   * representing integers) is `digit`, which needs to be in the range
   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
   * used; else, the lowercase form is used. The behavior is undefined
   * if `flag` is non-zero and `digit` has no uppercase form.
   */


  function digitToBasic(digit, flag) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  }
  /**
   * Bias adaptation function as per section 3.4 of RFC 3492.
   * http://tools.ietf.org/html/rfc3492#section-3.4
   * @private
   */


  function adapt(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);

    for (; delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }

    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  }
  /**
   * Converts a Punycode string of ASCII-only symbols to a string of Unicode
   * symbols.
   * @memberOf punycode
   * @param {String} input The Punycode string of ASCII-only symbols.
   * @returns {String} The resulting string of Unicode symbols.
   */


  function decode(input) {
    // Don't use UCS-2
    var output = [],
        inputLength = input.length,
        out,
        i = 0,
        n = initialN,
        bias = initialBias,
        basic,
        j,
        index,
        oldi,
        w,
        k,
        digit,
        t,

    /** Cached calculation results */
    baseMinusT; // Handle the basic code points: let `basic` be the number of input code
    // points before the last delimiter, or `0` if there is none, then copy
    // the first basic code points to the output.

    basic = input.lastIndexOf(delimiter);

    if (basic < 0) {
      basic = 0;
    }

    for (j = 0; j < basic; ++j) {
      // if it's not a basic code point
      if (input.charCodeAt(j) >= 0x80) {
        error('not-basic');
      }

      output.push(input.charCodeAt(j));
    } // Main decoding loop: start just after the last delimiter if any basic code
    // points were copied; start at the beginning otherwise.


    for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
      // `index` is the index of the next character to be consumed.
      // Decode a generalized variable-length integer into `delta`,
      // which gets added to `i`. The overflow checking is easier
      // if we increase `i` as we go, then subtract off its starting
      // value at the end to obtain `delta`.
      for (oldi = i, w = 1, k = base;; k += base) {
        if (index >= inputLength) {
          error('invalid-input');
        }

        digit = basicToDigit(input.charCodeAt(index++));

        if (digit >= base || digit > floor((maxInt - i) / w)) {
          error('overflow');
        }

        i += digit * w;
        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

        if (digit < t) {
          break;
        }

        baseMinusT = base - t;

        if (w > floor(maxInt / baseMinusT)) {
          error('overflow');
        }

        w *= baseMinusT;
      }

      out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,
      // incrementing `n` each time, so we'll fix that now:

      if (floor(i / out) > maxInt - n) {
        error('overflow');
      }

      n += floor(i / out);
      i %= out; // Insert `n` at position `i` of the output

      output.splice(i++, 0, n);
    }

    return ucs2encode(output);
  }
  /**
   * Converts a string of Unicode symbols (e.g. a domain name label) to a
   * Punycode string of ASCII-only symbols.
   * @memberOf punycode
   * @param {String} input The string of Unicode symbols.
   * @returns {String} The resulting Punycode string of ASCII-only symbols.
   */


  function encode(input) {
    var n,
        delta,
        handledCPCount,
        basicLength,
        bias,
        j,
        m,
        q,
        k,
        t,
        currentValue,
        output = [],

    /** `inputLength` will hold the number of code points in `input`. */
    inputLength,

    /** Cached calculation results */
    handledCPCountPlusOne,
        baseMinusT,
        qMinusT; // Convert the input in UCS-2 to Unicode

    input = ucs2decode(input); // Cache the length

    inputLength = input.length; // Initialize the state

    n = initialN;
    delta = 0;
    bias = initialBias; // Handle the basic code points

    for (j = 0; j < inputLength; ++j) {
      currentValue = input[j];

      if (currentValue < 0x80) {
        output.push(stringFromCharCode(currentValue));
      }
    }

    handledCPCount = basicLength = output.length; // `handledCPCount` is the number of code points that have been handled;
    // `basicLength` is the number of basic code points.
    // Finish the basic string - if it is not empty - with a delimiter

    if (basicLength) {
      output.push(delimiter);
    } // Main encoding loop:


    while (handledCPCount < inputLength) {
      // All non-basic code points < n have been handled already. Find the next
      // larger one:
      for (m = maxInt, j = 0; j < inputLength; ++j) {
        currentValue = input[j];

        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
      // but guard against overflow


      handledCPCountPlusOne = handledCPCount + 1;

      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error('overflow');
      }

      delta += (m - n) * handledCPCountPlusOne;
      n = m;

      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];

        if (currentValue < n && ++delta > maxInt) {
          error('overflow');
        }

        if (currentValue == n) {
          // Represent delta as a generalized variable-length integer
          for (q = delta, k = base;; k += base) {
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

            if (q < t) {
              break;
            }

            qMinusT = q - t;
            baseMinusT = base - t;
            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
            q = floor(qMinusT / baseMinusT);
          }

          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }

      ++delta;
      ++n;
    }

    return output.join('');
  }
  /**
   * Converts a Punycode string representing a domain name or an email address
   * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
   * it doesn't matter if you call it on a string that has already been
   * converted to Unicode.
   * @memberOf punycode
   * @param {String} input The Punycoded domain name or email address to
   * convert to Unicode.
   * @returns {String} The Unicode representation of the given Punycode
   * string.
   */


  function toUnicode(input) {
    return mapDomain(input, function (string) {
      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
  }
  /**
   * Converts a Unicode string representing a domain name or an email address to
   * Punycode. Only the non-ASCII parts of the domain name will be converted,
   * i.e. it doesn't matter if you call it with a domain that's already in
   * ASCII.
   * @memberOf punycode
   * @param {String} input The domain name or email address to convert, as a
   * Unicode string.
   * @returns {String} The Punycode representation of the given domain name or
   * email address.
   */


  function toASCII(input) {
    return mapDomain(input, function (string) {
      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
    });
  }
  /*--------------------------------------------------------------------------*/

  /** Define the public API */


  punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    'version': '1.3.2',

    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    'ucs2': {
      'decode': ucs2decode,
      'encode': ucs2encode
    },
    'decode': decode,
    'encode': encode,
    'toASCII': toASCII,
    'toUnicode': toUnicode
  };
  /** Expose `punycode` */
  // Some AMD build optimizers, like r.js, check for specific condition patterns
  // like the following:

  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return punycode;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this);

/***/ }),

/***/ "./node_modules/url/node_modules/querystring/decode.js":
/*!*************************************************************!*\
  !*** ./node_modules/url/node_modules/querystring/decode.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
 // If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function (qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1000;

  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length; // maxKeys <= 0 means that we should not limit keys count

  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

/***/ }),

/***/ "./node_modules/url/node_modules/querystring/encode.js":
/*!*************************************************************!*\
  !*** ./node_modules/url/node_modules/querystring/encode.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var stringifyPrimitive = function (v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';

  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;

      if (Array.isArray(obj[k])) {
        return obj[k].map(function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

/***/ }),

/***/ "./node_modules/url/node_modules/querystring/index.js":
/*!************************************************************!*\
  !*** ./node_modules/url/node_modules/querystring/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/url/node_modules/querystring/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/url/node_modules/querystring/encode.js");

/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var punycode = __webpack_require__(/*! punycode */ "./node_modules/url/node_modules/punycode/punycode.js");

var util = __webpack_require__(/*! ./util */ "./node_modules/url/util.js");

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;
exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
} // Reference: RFC 3986, RFC 1808, RFC 2396
// define these here so at least they only have to be
// compiled once on the first module load.


var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,
    // Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
    // RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
    // RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
unsafeProtocol = {
  'javascript': true,
  'javascript:': true
},
    // protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},
    // protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
},
    querystring = __webpack_require__(/*! querystring */ "./node_modules/url/node_modules/querystring/index.js");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;
  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  } // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916


  var queryIndex = url.indexOf('?'),
      splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);
  var rest = url; // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"

  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);

    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];

      if (simplePath[2]) {
        this.search = simplePath[2];

        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }

      return this;
    }
  }

  var proto = protocolPattern.exec(rest);

  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  } // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.


  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';

    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c
    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.
    // find the first instance of any hostEndingChars
    var hostEnd = -1;

    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
    } // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.


    var auth, atSign;

    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    } // Now we have a portion which is definitely the auth.
    // Pull that off.


    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    } // the host is the remaining to the left of the first non-host char


    hostEnd = -1;

    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
    } // if we still have not hit it, then the entire thing is a host.


    if (hostEnd === -1) hostEnd = rest.length;
    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd); // pull out port.

    this.parseHost(); // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.

    this.hostname = this.hostname || ''; // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.

    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'; // validate a little.

    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);

      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;

        if (!part.match(hostnamePartPattern)) {
          var newpart = '';

          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          } // we test again with ASCII char only


          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);

            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }

            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }

            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host; // strip [ and ] from the hostname
    // the host field still retains them, though

    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);

      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  } // now rest is set to the post-host stuff.
  // chop off any delim chars.


  if (!unsafeProtocol[lowerProto]) {
    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1) continue;
      var esc = encodeURIComponent(ae);

      if (esc === ae) {
        esc = escape(ae);
      }

      rest = rest.split(ae).join(esc);
    }
  } // chop off from the tail first.


  var hash = rest.indexOf('#');

  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }

  var qm = rest.indexOf('?');

  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);

    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }

    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }

  if (rest) this.pathname = rest;

  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '/';
  } //to support http.request


  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  } // finally, reconstruct the href based on what has been validated.


  this.href = this.format();
  return this;
}; // format a parsed object into a url string


function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function () {
  var auth = this.auth || '';

  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');

    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || query && '?' + query || '';
  if (protocol && protocol.substr(-1) !== ':') protocol += ':'; // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.

  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;
  pathname = pathname.replace(/[?#]/g, function (match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');
  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);

  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  } // hash is always overridden, no matter what.
  // even href="" will remove it.


  result.hash = relative.hash; // if the relative url is empty, then there's nothing left to do here.

  if (relative.href === '') {
    result.href = result.format();
    return result;
  } // hrefs like //foo/bar always cut to the protocol.


  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);

    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol') result[rkey] = relative[rkey];
    } //urlParse appends trailing / to urls like http://www.example.com


    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);

      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }

      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;

    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');

      while (relPath.length && !(relative.host = relPath.shift()));

      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }

    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port; // to support http.request

    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }

    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
      isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
      mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol]; // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.

  if (psychotic) {
    result.hostname = '';
    result.port = null;

    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);
    }

    result.host = '';

    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;

      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);
      }

      relative.host = null;
    }

    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = relative.host || relative.host === '' ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath; // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift(); //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')

      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;

      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }

    result.search = relative.search;
    result.query = relative.query; //to support http.request

    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }

    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null; //to support http.request

    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }

    result.href = result.format();
    return result;
  } // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.


  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === ''; // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0

  var up = 0;

  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];

    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  } // if the path is allowed to go above the root, restore leading ..s


  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/'; // put the host back

  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : ''; //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')

    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;

    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || result.host && srcPath.length;

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  } //to support request.http


  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
  }

  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);

  if (port) {
    port = port[0];

    if (port !== ':') {
      this.port = port.substr(1);
    }

    host = host.substr(0, host.length - port.length);
  }

  if (host) this.hostname = host;
};

/***/ }),

/***/ "./node_modules/url/util.js":
/*!**********************************!*\
  !*** ./node_modules/url/util.js ***!
  \**********************************/
/***/ ((module) => {

"use strict";


module.exports = {
  isString: function (arg) {
    return typeof arg === 'string';
  },
  isObject: function (arg) {
    return typeof arg === 'object' && arg !== null;
  },
  isNull: function (arg) {
    return arg === null;
  },
  isNullOrUndefined: function (arg) {
    return arg == null;
  }
};

/***/ }),

/***/ "./node_modules/ut_metadata/index.js":
/*!*******************************************!*\
  !*** ./node_modules/ut_metadata/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/*! ut_metadata. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
const {
  EventEmitter
} = __webpack_require__(/*! events */ "./node_modules/events/events.js");

const bencode = __webpack_require__(/*! bencode */ "./node_modules/bencode/lib/index.js");

const BitField = (__webpack_require__(/*! bitfield */ "./node_modules/bitfield/lib/index.js")["default"]);

const debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")('ut_metadata');

const sha1 = __webpack_require__(/*! simple-sha1 */ "./node_modules/simple-sha1/browser.js");

const MAX_METADATA_SIZE = 1E7; // 10 MB

const BITFIELD_GROW = 1E3;
const PIECE_LENGTH = 1 << 14; // 16 KiB

module.exports = metadata => {
  let utMetadata = /*#__PURE__*/function (_EventEmitter) {
    _inherits(utMetadata, _EventEmitter);

    var _super = _createSuper(utMetadata);

    function utMetadata(wire) {
      var _this;

      _classCallCheck(this, utMetadata);

      _this = _super.call(this);
      _this._wire = wire;
      _this._fetching = false;
      _this._metadataComplete = false;
      _this._metadataSize = null; // how many reject messages to tolerate before quitting

      _this._remainingRejects = null; // The largest torrent file that I know of is ~1-2MB, which is ~100
      // pieces. Therefore, cap the bitfield to 10x that (1000 pieces) so a
      // malicious peer can't make it grow to fill all memory.

      _this._bitfield = new BitField(0, {
        grow: BITFIELD_GROW
      });

      if (Buffer.isBuffer(metadata)) {
        _this.setMetadata(metadata);
      }

      return _this;
    }

    _createClass(utMetadata, [{
      key: "onHandshake",
      value: function onHandshake(infoHash, peerId, extensions) {
        this._infoHash = infoHash;
      }
    }, {
      key: "onExtendedHandshake",
      value: function onExtendedHandshake(handshake) {
        if (!handshake.m || !handshake.m.ut_metadata) {
          return this.emit('warning', new Error('Peer does not support ut_metadata'));
        }

        if (!handshake.metadata_size) {
          return this.emit('warning', new Error('Peer does not have metadata'));
        }

        if (typeof handshake.metadata_size !== 'number' || MAX_METADATA_SIZE < handshake.metadata_size || handshake.metadata_size <= 0) {
          return this.emit('warning', new Error('Peer gave invalid metadata size'));
        }

        this._metadataSize = handshake.metadata_size;
        this._numPieces = Math.ceil(this._metadataSize / PIECE_LENGTH);
        this._remainingRejects = this._numPieces * 2;

        this._requestPieces();
      }
    }, {
      key: "onMessage",
      value: function onMessage(buf) {
        let dict;
        let trailer;

        try {
          const str = buf.toString();
          const trailerIndex = str.indexOf('ee') + 2;
          dict = bencode.decode(str.substring(0, trailerIndex));
          trailer = buf.slice(trailerIndex);
        } catch (err) {
          // drop invalid messages
          return;
        }

        switch (dict.msg_type) {
          case 0:
            // ut_metadata request (from peer)
            // example: { 'msg_type': 0, 'piece': 0 }
            this._onRequest(dict.piece);

            break;

          case 1:
            // ut_metadata data (in response to our request)
            // example: { 'msg_type': 1, 'piece': 0, 'total_size': 3425 }
            this._onData(dict.piece, trailer, dict.total_size);

            break;

          case 2:
            // ut_metadata reject (peer doesn't have piece we requested)
            // { 'msg_type': 2, 'piece': 0 }
            this._onReject(dict.piece);

            break;
        }
      }
      /**
       * Ask the peer to send metadata.
       * @public
       */

    }, {
      key: "fetch",
      value: function fetch() {
        if (this._metadataComplete) {
          return;
        }

        this._fetching = true;

        if (this._metadataSize) {
          this._requestPieces();
        }
      }
      /**
       * Stop asking the peer to send metadata.
       * @public
       */

    }, {
      key: "cancel",
      value: function cancel() {
        this._fetching = false;
      }
    }, {
      key: "setMetadata",
      value: function setMetadata(metadata) {
        if (this._metadataComplete) return true;
        debug('set metadata'); // if full torrent dictionary was passed in, pull out just `info` key

        try {
          const info = bencode.decode(metadata).info;

          if (info) {
            metadata = bencode.encode(info);
          }
        } catch (err) {} // check hash


        if (this._infoHash && this._infoHash !== sha1.sync(metadata)) {
          return false;
        }

        this.cancel();
        this.metadata = metadata;
        this._metadataComplete = true;
        this._metadataSize = this.metadata.length;
        this._wire.extendedHandshake.metadata_size = this._metadataSize;
        this.emit('metadata', bencode.encode({
          info: bencode.decode(this.metadata)
        }));
        return true;
      }
    }, {
      key: "_send",
      value: function _send(dict, trailer) {
        let buf = bencode.encode(dict);

        if (Buffer.isBuffer(trailer)) {
          buf = Buffer.concat([buf, trailer]);
        }

        this._wire.extended('ut_metadata', buf);
      }
    }, {
      key: "_request",
      value: function _request(piece) {
        this._send({
          msg_type: 0,
          piece
        });
      }
    }, {
      key: "_data",
      value: function _data(piece, buf, totalSize) {
        const msg = {
          msg_type: 1,
          piece
        };

        if (typeof totalSize === 'number') {
          msg.total_size = totalSize;
        }

        this._send(msg, buf);
      }
    }, {
      key: "_reject",
      value: function _reject(piece) {
        this._send({
          msg_type: 2,
          piece
        });
      }
    }, {
      key: "_onRequest",
      value: function _onRequest(piece) {
        if (!this._metadataComplete) {
          this._reject(piece);

          return;
        }

        const start = piece * PIECE_LENGTH;
        let end = start + PIECE_LENGTH;

        if (end > this._metadataSize) {
          end = this._metadataSize;
        }

        const buf = this.metadata.slice(start, end);

        this._data(piece, buf, this._metadataSize);
      }
    }, {
      key: "_onData",
      value: function _onData(piece, buf, totalSize) {
        if (buf.length > PIECE_LENGTH || !this._fetching) {
          return;
        }

        buf.copy(this.metadata, piece * PIECE_LENGTH);

        this._bitfield.set(piece);

        this._checkDone();
      }
    }, {
      key: "_onReject",
      value: function _onReject(piece) {
        if (this._remainingRejects > 0 && this._fetching) {
          // If we haven't been rejected too much,
          // then try to request the piece again
          this._request(piece);

          this._remainingRejects -= 1;
        } else {
          this.emit('warning', new Error('Peer sent "reject" too much'));
        }
      }
    }, {
      key: "_requestPieces",
      value: function _requestPieces() {
        if (!this._fetching) return;
        this.metadata = Buffer.alloc(this._metadataSize);

        for (let piece = 0; piece < this._numPieces; piece++) {
          this._request(piece);
        }
      }
    }, {
      key: "_checkDone",
      value: function _checkDone() {
        let done = true;

        for (let piece = 0; piece < this._numPieces; piece++) {
          if (!this._bitfield.get(piece)) {
            done = false;
            break;
          }
        }

        if (!done) return; // attempt to set metadata -- may fail sha1 check

        const success = this.setMetadata(this.metadata);

        if (!success) {
          this._failedMetadata();
        }
      }
    }, {
      key: "_failedMetadata",
      value: function _failedMetadata() {
        // reset bitfield & try again
        this._bitfield = new BitField(0, {
          grow: BITFIELD_GROW
        });
        this._remainingRejects -= this._numPieces;

        if (this._remainingRejects > 0) {
          this._requestPieces();
        } else {
          this.emit('warning', new Error('Peer sent invalid metadata'));
        }
      }
    }]);

    return utMetadata;
  }(EventEmitter); // Name of the bittorrent-protocol extension


  utMetadata.prototype.name = 'ut_metadata';
  return utMetadata;
};

/***/ }),

/***/ "./node_modules/videostream/mp4-remuxer.js":
/*!*************************************************!*\
  !*** ./node_modules/videostream/mp4-remuxer.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

const bs = __webpack_require__(/*! binary-search */ "./node_modules/binary-search/index.js");

const EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");

const mp4 = __webpack_require__(/*! mp4-stream */ "./node_modules/mp4-stream/index.js");

const Box = __webpack_require__(/*! mp4-box-encoding */ "./node_modules/mp4-box-encoding/index.js");

const RangeSliceStream = __webpack_require__(/*! range-slice-stream */ "./node_modules/range-slice-stream/index.js"); // if we want to ignore more than this many bytes, request a new stream.
// if we want to ignore fewer, just skip them.


const FIND_MOOV_SEEK_SIZE = 4096;

let MP4Remuxer = /*#__PURE__*/function (_EventEmitter) {
  _inherits(MP4Remuxer, _EventEmitter);

  var _super = _createSuper(MP4Remuxer);

  function MP4Remuxer(file) {
    var _this;

    _classCallCheck(this, MP4Remuxer);

    _this = _super.call(this);
    _this._tracks = [];
    _this._file = file;
    _this._decoder = null;

    _this._findMoov(0);

    return _this;
  }

  _createClass(MP4Remuxer, [{
    key: "_findMoov",
    value: function _findMoov(offset) {
      if (this._decoder) {
        this._decoder.destroy();
      }

      let toSkip = 0;
      this._decoder = mp4.decode();

      const fileStream = this._file.createReadStream({
        start: offset
      });

      fileStream.pipe(this._decoder);

      const boxHandler = headers => {
        if (headers.type === 'moov') {
          this._decoder.removeListener('box', boxHandler);

          this._decoder.decode(moov => {
            fileStream.destroy();

            try {
              this._processMoov(moov);
            } catch (err) {
              err.message = "Cannot parse mp4 file: ".concat(err.message);
              this.emit('error', err);
            }
          });
        } else if (headers.length < FIND_MOOV_SEEK_SIZE) {
          toSkip += headers.length;

          this._decoder.ignore();
        } else {
          this._decoder.removeListener('box', boxHandler);

          toSkip += headers.length;
          fileStream.destroy();

          this._decoder.destroy();

          this._findMoov(offset + toSkip);
        }
      };

      this._decoder.on('box', boxHandler);
    }
  }, {
    key: "_processMoov",
    value: function _processMoov(moov) {
      const traks = moov.traks;
      this._tracks = [];
      this._hasVideo = false;
      this._hasAudio = false;

      for (let i = 0; i < traks.length; i++) {
        const trak = traks[i];
        const stbl = trak.mdia.minf.stbl;
        const stsdEntry = stbl.stsd.entries[0];
        const handlerType = trak.mdia.hdlr.handlerType;
        let codec;
        let mime;

        if (handlerType === 'vide' && stsdEntry.type === 'avc1') {
          if (this._hasVideo) {
            continue;
          }

          this._hasVideo = true;
          codec = 'avc1';

          if (stsdEntry.avcC) {
            codec += ".".concat(stsdEntry.avcC.mimeCodec);
          }

          mime = "video/mp4; codecs=\"".concat(codec, "\"");
        } else if (handlerType === 'soun' && stsdEntry.type === 'mp4a') {
          if (this._hasAudio) {
            continue;
          }

          this._hasAudio = true;
          codec = 'mp4a';

          if (stsdEntry.esds && stsdEntry.esds.mimeCodec) {
            codec += ".".concat(stsdEntry.esds.mimeCodec);
          }

          mime = "audio/mp4; codecs=\"".concat(codec, "\"");
        } else {
          continue;
        }

        const samples = [];
        let sample = 0; // Chunk/position data

        let sampleInChunk = 0;
        let chunk = 0;
        let offsetInChunk = 0;
        let sampleToChunkIndex = 0; // Time data

        let dts = 0;
        const decodingTimeEntry = new RunLengthIndex(stbl.stts.entries);
        let presentationOffsetEntry = null;

        if (stbl.ctts) {
          presentationOffsetEntry = new RunLengthIndex(stbl.ctts.entries);
        } // Sync table index


        let syncSampleIndex = 0;

        while (true) {
          var currChunkEntry = stbl.stsc.entries[sampleToChunkIndex]; // Compute size

          const size = stbl.stsz.entries[sample]; // Compute time data

          const duration = decodingTimeEntry.value.duration;
          const presentationOffset = presentationOffsetEntry ? presentationOffsetEntry.value.compositionOffset : 0; // Compute sync

          let sync = true;

          if (stbl.stss) {
            sync = stbl.stss.entries[syncSampleIndex] === sample + 1;
          } // Create new sample entry


          const chunkOffsetTable = stbl.stco || stbl.co64;
          samples.push({
            size,
            duration,
            dts,
            presentationOffset,
            sync,
            offset: offsetInChunk + chunkOffsetTable.entries[chunk]
          }); // Go to next sample

          sample++;

          if (sample >= stbl.stsz.entries.length) {
            break;
          } // Move position/chunk


          sampleInChunk++;
          offsetInChunk += size;

          if (sampleInChunk >= currChunkEntry.samplesPerChunk) {
            // Move to new chunk
            sampleInChunk = 0;
            offsetInChunk = 0;
            chunk++; // Move sample to chunk box index

            const nextChunkEntry = stbl.stsc.entries[sampleToChunkIndex + 1];

            if (nextChunkEntry && chunk + 1 >= nextChunkEntry.firstChunk) {
              sampleToChunkIndex++;
            }
          } // Move time forward


          dts += duration;
          decodingTimeEntry.inc();
          presentationOffsetEntry && presentationOffsetEntry.inc(); // Move sync table index

          if (sync) {
            syncSampleIndex++;
          }
        }

        trak.mdia.mdhd.duration = 0;
        trak.tkhd.duration = 0;
        const defaultSampleDescriptionIndex = currChunkEntry.sampleDescriptionId;
        const trackMoov = {
          type: 'moov',
          mvhd: moov.mvhd,
          traks: [{
            tkhd: trak.tkhd,
            mdia: {
              mdhd: trak.mdia.mdhd,
              hdlr: trak.mdia.hdlr,
              elng: trak.mdia.elng,
              minf: {
                vmhd: trak.mdia.minf.vmhd,
                smhd: trak.mdia.minf.smhd,
                dinf: trak.mdia.minf.dinf,
                stbl: {
                  stsd: stbl.stsd,
                  stts: empty(),
                  ctts: empty(),
                  stsc: empty(),
                  stsz: empty(),
                  stco: empty(),
                  stss: empty()
                }
              }
            }
          }],
          mvex: {
            mehd: {
              fragmentDuration: moov.mvhd.duration
            },
            trexs: [{
              trackId: trak.tkhd.trackId,
              defaultSampleDescriptionIndex,
              defaultSampleDuration: 0,
              defaultSampleSize: 0,
              defaultSampleFlags: 0
            }]
          }
        };

        this._tracks.push({
          fragmentSequence: 1,
          trackId: trak.tkhd.trackId,
          timeScale: trak.mdia.mdhd.timeScale,
          samples,
          currSample: null,
          currTime: null,
          moov: trackMoov,
          mime
        });
      }

      if (this._tracks.length === 0) {
        this.emit('error', new Error('no playable tracks'));
        return;
      } // Must be set last since this is used above


      moov.mvhd.duration = 0;
      this._ftyp = {
        type: 'ftyp',
        brand: 'iso5',
        brandVersion: 0,
        compatibleBrands: ['iso5']
      };
      const ftypBuf = Box.encode(this._ftyp);

      const data = this._tracks.map(track => {
        const moovBuf = Box.encode(track.moov);
        return {
          mime: track.mime,
          init: Buffer.concat([ftypBuf, moovBuf])
        };
      });

      this.emit('ready', data);
    }
  }, {
    key: "seek",
    value: function seek(time) {
      if (!this._tracks) {
        throw new Error('Not ready yet; wait for \'ready\' event');
      }

      if (this._fileStream) {
        this._fileStream.destroy();

        this._fileStream = null;
      }

      let startOffset = -1;

      this._tracks.map((track, i) => {
        // find the keyframe before the time
        // stream from there
        if (track.outStream) {
          track.outStream.destroy();
        }

        if (track.inStream) {
          track.inStream.destroy();
          track.inStream = null;
        }

        const outStream = track.outStream = mp4.encode();

        const fragment = this._generateFragment(i, time);

        if (!fragment) {
          return outStream.finalize();
        }

        if (startOffset === -1 || fragment.ranges[0].start < startOffset) {
          startOffset = fragment.ranges[0].start;
        }

        const writeFragment = frag => {
          if (outStream.destroyed) return;
          outStream.box(frag.moof, err => {
            if (err) return this.emit('error', err);
            if (outStream.destroyed) return;
            const slicedStream = track.inStream.slice(frag.ranges);
            slicedStream.pipe(outStream.mediaData(frag.length, err => {
              if (err) return this.emit('error', err);
              if (outStream.destroyed) return;

              const nextFrag = this._generateFragment(i);

              if (!nextFrag) {
                return outStream.finalize();
              }

              writeFragment(nextFrag);
            }));
          });
        };

        writeFragment(fragment);
      });

      if (startOffset >= 0) {
        const fileStream = this._fileStream = this._file.createReadStream({
          start: startOffset
        });

        this._tracks.forEach(track => {
          track.inStream = new RangeSliceStream(startOffset, {
            // Allow up to a 10MB offset between audio and video,
            // which should be fine for any reasonable interleaving
            // interval and bitrate
            highWaterMark: 10000000
          });
          fileStream.pipe(track.inStream);
        });
      }

      return this._tracks.map(track => {
        return track.outStream;
      });
    }
  }, {
    key: "_findSampleBefore",
    value: function _findSampleBefore(trackInd, time) {
      const track = this._tracks[trackInd];
      const scaledTime = Math.floor(track.timeScale * time);
      let sample = bs(track.samples, scaledTime, (sample, t) => {
        const pts = sample.dts + sample.presentationOffset; // - track.editShift

        return pts - t;
      });

      if (sample === -1) {
        sample = 0;
      } else if (sample < 0) {
        sample = -sample - 2;
      } // sample is now the last sample with dts <= time
      // Find the preceeding sync sample


      while (!track.samples[sample].sync) {
        sample--;
      }

      return sample;
    }
  }, {
    key: "_generateFragment",
    value: function _generateFragment(track, time) {
      /*
          1. Find correct sample
          2. Process backward until sync sample found
          3. Process forward until next sync sample after MIN_FRAGMENT_DURATION found
          */
      const currTrack = this._tracks[track];
      let firstSample;

      if (time !== undefined) {
        firstSample = this._findSampleBefore(track, time);
      } else {
        firstSample = currTrack.currSample;
      }

      if (firstSample >= currTrack.samples.length) {
        return null;
      }

      const startDts = currTrack.samples[firstSample].dts;
      let totalLen = 0;
      const ranges = [];

      for (var currSample = firstSample; currSample < currTrack.samples.length; currSample++) {
        const sample = currTrack.samples[currSample];

        if (sample.sync && sample.dts - startDts >= currTrack.timeScale * MIN_FRAGMENT_DURATION) {
          break; // This is a reasonable place to end the fragment
        }

        totalLen += sample.size;
        const currRange = ranges.length - 1;

        if (currRange < 0 || ranges[currRange].end !== sample.offset) {
          // Push a new range
          ranges.push({
            start: sample.offset,
            end: sample.offset + sample.size
          });
        } else {
          ranges[currRange].end += sample.size;
        }
      }

      currTrack.currSample = currSample;
      return {
        moof: this._generateMoof(track, firstSample, currSample),
        ranges,
        length: totalLen
      };
    }
  }, {
    key: "_generateMoof",
    value: function _generateMoof(track, firstSample, lastSample) {
      const currTrack = this._tracks[track];
      const entries = [];
      let trunVersion = 0;

      for (let j = firstSample; j < lastSample; j++) {
        const currSample = currTrack.samples[j];

        if (currSample.presentationOffset < 0) {
          trunVersion = 1;
        }

        entries.push({
          sampleDuration: currSample.duration,
          sampleSize: currSample.size,
          sampleFlags: currSample.sync ? 0x2000000 : 0x1010000,
          sampleCompositionTimeOffset: currSample.presentationOffset
        });
      }

      const moof = {
        type: 'moof',
        mfhd: {
          sequenceNumber: currTrack.fragmentSequence++
        },
        trafs: [{
          tfhd: {
            flags: 0x20000,
            // default-base-is-moof
            trackId: currTrack.trackId
          },
          tfdt: {
            baseMediaDecodeTime: currTrack.samples[firstSample].dts
          },
          trun: {
            flags: 0xf01,
            dataOffset: 8,
            // The moof size has to be added to this later as well
            entries,
            version: trunVersion
          }
        }]
      }; // Update the offset

      moof.trafs[0].trun.dataOffset += Box.encodingLength(moof);
      return moof;
    }
  }]);

  return MP4Remuxer;
}(EventEmitter);

let RunLengthIndex = /*#__PURE__*/function () {
  function RunLengthIndex(entries, countName) {
    _classCallCheck(this, RunLengthIndex);

    this._entries = entries;
    this._countName = countName || 'count';
    this._index = 0;
    this._offset = 0;
    this.value = this._entries[0];
  }

  _createClass(RunLengthIndex, [{
    key: "inc",
    value: function inc() {
      this._offset++;

      if (this._offset >= this._entries[this._index][this._countName]) {
        this._index++;
        this._offset = 0;
      }

      this.value = this._entries[this._index];
    }
  }]);

  return RunLengthIndex;
}();

function empty() {
  return {
    version: 0,
    flags: 0,
    entries: []
  };
}

const MIN_FRAGMENT_DURATION = 1; // second

module.exports = MP4Remuxer;

/***/ }),

/***/ "./node_modules/videostream/videostream.js":
/*!*************************************************!*\
  !*** ./node_modules/videostream/videostream.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const MediaElementWrapper = __webpack_require__(/*! mediasource */ "./node_modules/mediasource/index.js");

const pump = __webpack_require__(/*! pump */ "./node_modules/pump/index.js");

const MP4Remuxer = __webpack_require__(/*! ./mp4-remuxer */ "./node_modules/videostream/mp4-remuxer.js");

function VideoStream(file, mediaElem) {
  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (!(this instanceof VideoStream)) {
    console.warn("Don't invoke VideoStream without the 'new' keyword.");
    return new VideoStream(file, mediaElem, opts);
  }

  this.detailedError = null;
  this._elem = mediaElem;
  this._elemWrapper = new MediaElementWrapper(mediaElem);
  this._waitingFired = false;
  this._trackMeta = null;
  this._file = file;
  this._tracks = null;

  if (this._elem.preload !== 'none') {
    this._createMuxer();
  }

  this._onError = () => {
    this.detailedError = this._elemWrapper.detailedError;
    this.destroy(); // don't pass err though so the user doesn't need to listen for errors
  };

  this._onWaiting = () => {
    this._waitingFired = true;

    if (!this._muxer) {
      this._createMuxer();
    } else if (this._tracks) {
      this._pump();
    }
  };

  if (mediaElem.autoplay) {
    mediaElem.preload = 'auto';
  }

  mediaElem.addEventListener('waiting', this._onWaiting);
  mediaElem.addEventListener('error', this._onError);
}

VideoStream.prototype = {
  _createMuxer() {
    this._muxer = new MP4Remuxer(this._file);

    this._muxer.on('ready', data => {
      this._tracks = data.map(trackData => {
        const mediaSource = this._elemWrapper.createWriteStream(trackData.mime);

        mediaSource.on('error', err => {
          this._elemWrapper.error(err);
        });
        const track = {
          muxed: null,
          mediaSource,
          initFlushed: false,
          onInitFlushed: null
        };
        mediaSource.write(trackData.init, err => {
          track.initFlushed = true;

          if (track.onInitFlushed) {
            track.onInitFlushed(err);
          }
        });
        return track;
      });

      if (this._waitingFired || this._elem.preload === 'auto') {
        this._pump();
      }
    });

    this._muxer.on('error', err => {
      this._elemWrapper.error(err);
    });
  },

  _pump() {
    const muxed = this._muxer.seek(this._elem.currentTime, !this._tracks);

    this._tracks.forEach((track, i) => {
      const pumpTrack = () => {
        if (track.muxed) {
          track.muxed.destroy();
          track.mediaSource = this._elemWrapper.createWriteStream(track.mediaSource);
          track.mediaSource.on('error', err => {
            this._elemWrapper.error(err);
          });
        }

        track.muxed = muxed[i];
        pump(track.muxed, track.mediaSource);
      };

      if (!track.initFlushed) {
        track.onInitFlushed = err => {
          if (err) {
            this._elemWrapper.error(err);

            return;
          }

          pumpTrack();
        };
      } else {
        pumpTrack();
      }
    });
  },

  destroy() {
    if (this.destroyed) {
      return;
    }

    this.destroyed = true;

    this._elem.removeEventListener('waiting', this._onWaiting);

    this._elem.removeEventListener('error', this._onError);

    if (this._tracks) {
      this._tracks.forEach(track => {
        if (track.muxed) {
          track.muxed.destroy();
        }
      });
    }

    this._elem.src = '';
  }

};
module.exports = VideoStream;

/***/ }),

/***/ "./node_modules/webtorrent/index.js":
/*!******************************************!*\
  !*** ./node_modules/webtorrent/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/*! webtorrent. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */

/* global FileList, ServiceWorker */

/* eslint-env browser */
const EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");

const path = __webpack_require__(/*! path */ "./src/shims/path.ts");

const concat = __webpack_require__(/*! simple-concat */ "./node_modules/simple-concat/index.js");

const createTorrent = __webpack_require__(/*! create-torrent */ "./node_modules/create-torrent/index.js");

const debugFactory = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");

const DHT = __webpack_require__(/*! bittorrent-dht/client */ "?4b99"); // browser exclude


const loadIPSet = __webpack_require__(/*! load-ip-set */ "?ae1e"); // browser exclude


const parallel = __webpack_require__(/*! run-parallel */ "./node_modules/run-parallel/index.js");

const parseTorrent = __webpack_require__(/*! parse-torrent */ "./node_modules/parse-torrent/index.js");

const Peer = __webpack_require__(/*! simple-peer */ "./node_modules/simple-peer/index.js");

const queueMicrotask = __webpack_require__(/*! queue-microtask */ "./node_modules/queue-microtask/index.js");

const randombytes = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js");

const sha1 = __webpack_require__(/*! simple-sha1 */ "./node_modules/simple-sha1/browser.js");

const throughput = __webpack_require__(/*! throughput */ "./node_modules/throughput/index.js");

const {
  ThrottleGroup
} = __webpack_require__(/*! speed-limiter */ "./node_modules/speed-limiter/index.js");

const ConnPool = __webpack_require__(/*! ./lib/conn-pool.js */ "?e6f0"); // browser exclude


const Torrent = __webpack_require__(/*! ./lib/torrent.js */ "./node_modules/webtorrent/lib/torrent.js");

const {
  version: VERSION
} = __webpack_require__(/*! ./package.json */ "./node_modules/webtorrent/package.json");

const debug = debugFactory('webtorrent');
/**
 * Version number in Azureus-style. Generated from major and minor semver version.
 * For example:
 *   '0.16.1' -> '0016'
 *   '1.2.5' -> '0102'
 */

const VERSION_STR = VERSION.replace(/\d*./g, v => "0".concat(v % 100).slice(-2)).slice(0, 4);
/**
 * Version prefix string (used in peer ID). WebTorrent uses the Azureus-style
 * encoding: '-', two characters for client id ('WW'), four ascii digits for version
 * number, '-', followed by random numbers.
 * For example:
 *   '-WW0102-'...
 */

const VERSION_PREFIX = "-WW".concat(VERSION_STR, "-");
/**
 * WebTorrent Client
 * @param {Object=} opts
 */

let WebTorrent = /*#__PURE__*/function (_EventEmitter) {
  _inherits(WebTorrent, _EventEmitter);

  var _super = _createSuper(WebTorrent);

  function WebTorrent() {
    var _this;

    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, WebTorrent);

    _this = _super.call(this);

    if (typeof opts.peerId === 'string') {
      _this.peerId = opts.peerId;
    } else if (Buffer.isBuffer(opts.peerId)) {
      _this.peerId = opts.peerId.toString('hex');
    } else {
      _this.peerId = Buffer.from(VERSION_PREFIX + randombytes(9).toString('base64')).toString('hex');
    }

    _this.peerIdBuffer = Buffer.from(_this.peerId, 'hex');

    if (typeof opts.nodeId === 'string') {
      _this.nodeId = opts.nodeId;
    } else if (Buffer.isBuffer(opts.nodeId)) {
      _this.nodeId = opts.nodeId.toString('hex');
    } else {
      _this.nodeId = randombytes(20).toString('hex');
    }

    _this.nodeIdBuffer = Buffer.from(_this.nodeId, 'hex');
    _this._debugId = _this.peerId.toString('hex').substring(0, 7);
    _this.destroyed = false;
    _this.listening = false;
    _this.torrentPort = opts.torrentPort || 0;
    _this.dhtPort = opts.dhtPort || 0;
    _this.tracker = opts.tracker !== undefined ? opts.tracker : {};
    _this.lsd = opts.lsd !== false;
    _this.torrents = [];
    _this.maxConns = Number(opts.maxConns) || 55;
    _this.utp = WebTorrent.UTP_SUPPORT && opts.utp !== false;
    _this._downloadLimit = Math.max(typeof opts.downloadLimit === 'number' ? opts.downloadLimit : -1, -1);
    _this._uploadLimit = Math.max(typeof opts.uploadLimit === 'number' ? opts.uploadLimit : -1, -1);
    _this.serviceWorker = null;
    _this.workerKeepAliveInterval = null;
    _this.workerPortCount = 0;

    if (opts.secure === true) {
      (__webpack_require__(/*! ./lib/peer */ "./node_modules/webtorrent/lib/peer.js").enableSecure)();
    }

    _this._debug('new webtorrent (peerId %s, nodeId %s, port %s)', _this.peerId, _this.nodeId, _this.torrentPort);

    _this.throttleGroups = {
      down: new ThrottleGroup({
        rate: Math.max(_this._downloadLimit, 0),
        enabled: _this._downloadLimit >= 0
      }),
      up: new ThrottleGroup({
        rate: Math.max(_this._uploadLimit, 0),
        enabled: _this._uploadLimit >= 0
      })
    };

    if (_this.tracker) {
      if (typeof _this.tracker !== 'object') _this.tracker = {};
      if (globalThis.WRTC && !_this.tracker.wrtc) _this.tracker.wrtc = globalThis.WRTC;
    }

    if (typeof ConnPool === 'function') {
      _this._connPool = new ConnPool(_assertThisInitialized(_this));
    } else {
      queueMicrotask(() => {
        _this._onListening();
      });
    } // stats


    _this._downloadSpeed = throughput();
    _this._uploadSpeed = throughput();

    if (opts.dht !== false && typeof DHT === 'function'
    /* browser exclude */
    ) {
      // use a single DHT instance for all torrents, so the routing table can be reused
      _this.dht = new DHT(Object.assign({}, {
        nodeId: _this.nodeId
      }, opts.dht));

      _this.dht.once('error', err => {
        _this._destroy(err);
      });

      _this.dht.once('listening', () => {
        const address = _this.dht.address();

        if (address) _this.dhtPort = address.port;
      }); // Ignore warning when there are > 10 torrents in the client


      _this.dht.setMaxListeners(0);

      _this.dht.listen(_this.dhtPort);
    } else {
      _this.dht = false;
    } // Enable or disable BEP19 (Web Seeds). Enabled by default:


    _this.enableWebSeeds = opts.webSeeds !== false;

    const ready = () => {
      if (_this.destroyed) return;
      _this.ready = true;

      _this.emit('ready');
    };

    if (typeof loadIPSet === 'function' && opts.blocklist != null) {
      loadIPSet(opts.blocklist, {
        headers: {
          'user-agent': "WebTorrent/".concat(VERSION, " (https://webtorrent.io)")
        }
      }, (err, ipSet) => {
        if (err) return console.error("Failed to load blocklist: ".concat(err.message));
        _this.blocked = ipSet;
        ready();
      });
    } else {
      queueMicrotask(ready);
    }

    return _this;
  }
  /**
   * Accepts an existing service worker registration [navigator.serviceWorker.controller]
   * which must be activated, "creates" a file server for streamed file rendering to use.
   *
   * @param  {ServiceWorker} controller
   * @param {function=} cb
   * @return {null}
   */


  _createClass(WebTorrent, [{
    key: "loadWorker",
    value: function loadWorker(controller) {
      let cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
      if (!(controller instanceof ServiceWorker)) throw new Error('Invalid worker registration');
      if (controller.state !== 'activated') throw new Error('Worker isn\'t activated');
      const keepAliveTime = 20000;
      this.serviceWorker = controller;
      navigator.serviceWorker.addEventListener('message', event => {
        const {
          data
        } = event;
        if (!data.type || !data.type === 'webtorrent' || !data.url) return null;
        let [infoHash, ...filePath] = data.url.slice(data.url.indexOf(data.scope + 'webtorrent/') + 11 + data.scope.length).split('/');
        filePath = decodeURI(filePath.join('/'));
        if (!infoHash || !filePath) return null;
        const [port] = event.ports;
        const file = this.get(infoHash) && this.get(infoHash).files.find(file => file.path === filePath);
        if (!file) return null;

        const [response, stream, raw] = file._serve(data);

        const asyncIterator = stream && stream[Symbol.asyncIterator]();

        const cleanup = () => {
          port.onmessage = null;
          if (stream) stream.destroy();
          if (raw) raw.destroy();
          this.workerPortCount--;

          if (!this.workerPortCount) {
            clearInterval(this.workerKeepAliveInterval);
            this.workerKeepAliveInterval = null;
          }
        };

        port.onmessage = async msg => {
          if (msg.data) {
            let chunk;

            try {
              chunk = (await asyncIterator.next()).value;
            } catch (e) {// chunk is yet to be downloaded or it somehow failed, should this be logged?
            }

            port.postMessage(chunk);
            if (!chunk) cleanup();
            if (!this.workerKeepAliveInterval) this.workerKeepAliveInterval = setInterval(() => fetch("".concat(this.serviceWorker.scriptURL.slice(0, this.serviceWorker.scriptURL.lastIndexOf('/') + 1).slice(window.location.origin.length), "webtorrent/keepalive/")), keepAliveTime);
          } else {
            cleanup();
          }
        };

        this.workerPortCount++;
        port.postMessage(response);
      }); // test if browser supports cancelling sw Readable Streams

      fetch("".concat(this.serviceWorker.scriptURL.slice(0, this.serviceWorker.scriptURL.lastIndexOf('/') + 1).slice(window.location.origin.length), "webtorrent/cancel/")).then(res => {
        res.body.cancel();
      });
      cb(null, this.serviceWorker);
    }
  }, {
    key: "downloadSpeed",
    get: function () {
      return this._downloadSpeed();
    }
  }, {
    key: "uploadSpeed",
    get: function () {
      return this._uploadSpeed();
    }
  }, {
    key: "progress",
    get: function () {
      const torrents = this.torrents.filter(torrent => torrent.progress !== 1);
      const downloaded = torrents.reduce((total, torrent) => total + torrent.downloaded, 0);
      const length = torrents.reduce((total, torrent) => total + (torrent.length || 0), 0) || 1;
      return downloaded / length;
    }
  }, {
    key: "ratio",
    get: function () {
      const uploaded = this.torrents.reduce((total, torrent) => total + torrent.uploaded, 0);
      const received = this.torrents.reduce((total, torrent) => total + torrent.received, 0) || 1;
      return uploaded / received;
    }
    /**
     * Returns the torrent with the given `torrentId`. Convenience method. Easier than
     * searching through the `client.torrents` array. Returns `null` if no matching torrent
     * found.
     *
     * @param  {string|Buffer|Object|Torrent} torrentId
     * @return {Torrent|null}
     */

  }, {
    key: "get",
    value: function get(torrentId) {
      if (torrentId instanceof Torrent) {
        if (this.torrents.includes(torrentId)) return torrentId;
      } else {
        let parsed;

        try {
          parsed = parseTorrent(torrentId);
        } catch (err) {}

        if (!parsed) return null;
        if (!parsed.infoHash) throw new Error('Invalid torrent identifier');

        for (const torrent of this.torrents) {
          if (torrent.infoHash === parsed.infoHash) return torrent;
        }
      }

      return null;
    }
    /**
     * Start downloading a new torrent. Aliased as `client.download`.
     * @param {string|Buffer|Object} torrentId
     * @param {Object} opts torrent-specific options
     * @param {function=} ontorrent called when the torrent is ready (has metadata)
     */

  }, {
    key: "add",
    value: function add(torrentId) {
      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      let ontorrent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
      if (this.destroyed) throw new Error('client is destroyed');
      if (typeof opts === 'function') [opts, ontorrent] = [{}, opts];

      const onInfoHash = () => {
        if (this.destroyed) return;

        for (const t of this.torrents) {
          if (t.infoHash === torrent.infoHash && t !== torrent) {
            torrent._destroy(new Error("Cannot add duplicate torrent ".concat(torrent.infoHash)));

            return;
          }
        }
      };

      const onReady = () => {
        if (this.destroyed) return;
        ontorrent(torrent);
        this.emit('torrent', torrent);
      };

      function onClose() {
        torrent.removeListener('_infoHash', onInfoHash);
        torrent.removeListener('ready', onReady);
        torrent.removeListener('close', onClose);
      }

      this._debug('add');

      opts = opts ? Object.assign({}, opts) : {};
      const torrent = new Torrent(torrentId, this, opts);
      this.torrents.push(torrent);
      torrent.once('_infoHash', onInfoHash);
      torrent.once('ready', onReady);
      torrent.once('close', onClose);
      return torrent;
    }
    /**
     * Start seeding a new file/folder.
     * @param  {string|File|FileList|Buffer|Array.<string|File|Buffer>} input
     * @param  {Object=} opts
     * @param  {function=} onseed called when torrent is seeding
     */

  }, {
    key: "seed",
    value: function seed(input, opts, onseed) {
      if (this.destroyed) throw new Error('client is destroyed');
      if (typeof opts === 'function') [opts, onseed] = [{}, opts];

      this._debug('seed');

      opts = opts ? Object.assign({}, opts) : {}; // no need to verify the hashes we create

      opts.skipVerify = true;
      const isFilePath = typeof input === 'string'; // When seeding from fs path, initialize store from that path to avoid a copy

      if (isFilePath) opts.path = path.dirname(input);
      if (!opts.createdBy) opts.createdBy = "WebTorrent/".concat(VERSION_STR);

      const onTorrent = torrent => {
        const tasks = [cb => {
          // when a filesystem path is specified or the store is preloaded, files are already in the FS store
          if (isFilePath || opts.preloadedStore) return cb();
          torrent.load(streams, cb);
        }];

        if (this.dht) {
          tasks.push(cb => {
            torrent.once('dhtAnnounce', cb);
          });
        }

        parallel(tasks, err => {
          if (this.destroyed) return;
          if (err) return torrent._destroy(err);

          _onseed(torrent);
        });
      };

      const _onseed = torrent => {
        this._debug('on seed');

        if (typeof onseed === 'function') onseed(torrent);
        torrent.emit('seed');
        this.emit('seed', torrent);
      };

      const torrent = this.add(null, opts, onTorrent);
      let streams;
      if (isFileList(input)) input = Array.from(input);else if (!Array.isArray(input)) input = [input];
      parallel(input.map(item => cb => {
        if (!opts.preloadedStore && isReadable(item)) {
          concat(item, (err, buf) => {
            if (err) return cb(err);
            buf.name = item.name;
            cb(null, buf);
          });
        } else {
          cb(null, item);
        }
      }), (err, input) => {
        if (this.destroyed) return;
        if (err) return torrent._destroy(err);
        createTorrent.parseInput(input, opts, (err, files) => {
          if (this.destroyed) return;
          if (err) return torrent._destroy(err);
          streams = files.map(file => file.getStream);
          createTorrent(input, opts, (err, torrentBuf) => {
            if (this.destroyed) return;
            if (err) return torrent._destroy(err);
            const existingTorrent = this.get(torrentBuf);

            if (existingTorrent) {
              console.warn('A torrent with the same id is already being seeded');

              torrent._destroy();

              if (typeof onseed === 'function') onseed(existingTorrent);
            } else {
              torrent._onTorrentId(torrentBuf);
            }
          });
        });
      });
      return torrent;
    }
    /**
     * Remove a torrent from the client.
     * @param  {string|Buffer|Torrent}   torrentId
     * @param  {function} cb
     */

  }, {
    key: "remove",
    value: function remove(torrentId, opts, cb) {
      if (typeof opts === 'function') return this.remove(torrentId, null, opts);

      this._debug('remove');

      const torrent = this.get(torrentId);
      if (!torrent) throw new Error("No torrent with id ".concat(torrentId));

      this._remove(torrentId, opts, cb);
    }
  }, {
    key: "_remove",
    value: function _remove(torrentId, opts, cb) {
      if (typeof opts === 'function') return this._remove(torrentId, null, opts);
      const torrent = this.get(torrentId);
      if (!torrent) return;
      this.torrents.splice(this.torrents.indexOf(torrent), 1);
      torrent.destroy(opts, cb);

      if (this.dht) {
        this.dht._tables.remove(torrent.infoHash);
      }
    }
  }, {
    key: "address",
    value: function address() {
      if (!this.listening) return null;
      return this._connPool ? this._connPool.tcpServer.address() : {
        address: '0.0.0.0',
        family: 'IPv4',
        port: 0
      };
    }
    /**
     * Set global download throttle rate.
     * @param  {Number} rate (must be bigger or equal than zero, or -1 to disable throttling)
     */

  }, {
    key: "throttleDownload",
    value: function throttleDownload(rate) {
      rate = Number(rate);
      if (isNaN(rate) || !isFinite(rate) || rate < -1) return false;
      this._downloadLimit = rate;
      if (this._downloadLimit < 0) return this.throttleGroups.down.setEnabled(false);
      this.throttleGroups.down.setEnabled(true);
      this.throttleGroups.down.setRate(this._downloadLimit);
    }
    /**
     * Set global upload throttle rate
     * @param  {Number} rate (must be bigger or equal than zero, or -1 to disable throttling)
     */

  }, {
    key: "throttleUpload",
    value: function throttleUpload(rate) {
      rate = Number(rate);
      if (isNaN(rate) || !isFinite(rate) || rate < -1) return false;
      this._uploadLimit = rate;
      if (this._uploadLimit < 0) return this.throttleGroups.up.setEnabled(false);
      this.throttleGroups.up.setEnabled(true);
      this.throttleGroups.up.setRate(this._uploadLimit);
    }
    /**
     * Destroy the client, including all torrents and connections to peers.
     * @param  {function} cb
     */

  }, {
    key: "destroy",
    value: function destroy(cb) {
      if (this.destroyed) throw new Error('client already destroyed');

      this._destroy(null, cb);
    }
  }, {
    key: "_destroy",
    value: function _destroy(err, cb) {
      this._debug('client destroy');

      this.destroyed = true;
      const tasks = this.torrents.map(torrent => cb => {
        torrent.destroy(cb);
      });

      if (this._connPool) {
        tasks.push(cb => {
          this._connPool.destroy(cb);
        });
      }

      if (this.dht) {
        tasks.push(cb => {
          this.dht.destroy(cb);
        });
      }

      parallel(tasks, cb);
      if (err) this.emit('error', err);
      this.torrents = [];
      this._connPool = null;
      this.dht = null;
      this.throttleGroups.down.destroy();
      this.throttleGroups.up.destroy();
    }
  }, {
    key: "_onListening",
    value: function _onListening() {
      this._debug('listening');

      this.listening = true;

      if (this._connPool) {
        // Sometimes server.address() returns `null` in Docker.
        const address = this._connPool.tcpServer.address();

        if (address) this.torrentPort = address.port;
      }

      this.emit('listening');
    }
  }, {
    key: "_debug",
    value: function _debug() {
      const args = [].slice.call(arguments);
      args[0] = "[".concat(this._debugId, "] ").concat(args[0]);
      debug.apply(void 0, _toConsumableArray(args));
    }
  }, {
    key: "_getByHash",
    value: function _getByHash(infoHashHash) {
      for (const torrent of this.torrents) {
        if (!torrent.infoHashHash) {
          torrent.infoHashHash = sha1.sync(Buffer.from('72657132'
          /* 'req2' */
          + torrent.infoHash, 'hex'));
        }

        if (infoHashHash === torrent.infoHashHash) {
          return torrent;
        }
      }

      return null;
    }
  }]);

  return WebTorrent;
}(EventEmitter);

WebTorrent.WEBRTC_SUPPORT = Peer.WEBRTC_SUPPORT;
WebTorrent.UTP_SUPPORT = ConnPool.UTP_SUPPORT;
WebTorrent.VERSION = VERSION;
/**
 * Check if `obj` is a node Readable stream
 * @param  {*} obj
 * @return {boolean}
 */

function isReadable(obj) {
  return typeof obj === 'object' && obj != null && typeof obj.pipe === 'function';
}
/**
 * Check if `obj` is a W3C `FileList` object
 * @param  {*} obj
 * @return {boolean}
 */


function isFileList(obj) {
  return typeof FileList !== 'undefined' && obj instanceof FileList;
}

module.exports = WebTorrent;

/***/ }),

/***/ "./node_modules/webtorrent/lib/file-stream.js":
/*!****************************************************!*\
  !*** ./node_modules/webtorrent/lib/file-stream.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

const stream = __webpack_require__(/*! stream */ "./src/shims/stream.ts");

const debugFactory = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");

const eos = __webpack_require__(/*! end-of-stream */ "./node_modules/end-of-stream/index.js");

const debug = debugFactory('webtorrent:file-stream');
/**
 * Readable stream of a torrent file
 *
 * @param {File} file
 * @param {Object} opts
 * @param {number} opts.start stream slice of file, starting from this byte (inclusive)
 * @param {number} opts.end stream slice of file, ending with this byte (inclusive)
 */

let FileStream = /*#__PURE__*/function (_stream$Readable) {
  _inherits(FileStream, _stream$Readable);

  var _super = _createSuper(FileStream);

  function FileStream(file, opts) {
    var _this;

    _classCallCheck(this, FileStream);

    _this = _super.call(this, opts);
    _this._torrent = file._torrent;
    const start = opts && opts.start || 0;
    const end = opts && opts.end && opts.end < file.length ? opts.end : file.length - 1;
    const pieceLength = file._torrent.pieceLength;
    _this._startPiece = (start + file.offset) / pieceLength | 0;
    _this._endPiece = (end + file.offset) / pieceLength | 0;
    _this._piece = _this._startPiece;
    _this._offset = start + file.offset - _this._startPiece * pieceLength;
    _this._missing = end - start + 1;
    _this._reading = false;
    _this._notifying = false;
    _this._criticalLength = Math.min(1024 * 1024 / pieceLength | 0, 2);

    _this._torrent.select(_this._startPiece, _this._endPiece, true, () => {
      _this._notify();
    }); // Ensure that cleanup happens even if destroy() is never called (readable-stream v3 currently doesn't call it automaticallly)


    eos(_assertThisInitialized(_this), err => {
      _this.destroy(err);
    });
    return _this;
  }

  _createClass(FileStream, [{
    key: "_read",
    value: function _read() {
      if (this._reading) return;
      this._reading = true;

      this._notify();
    }
  }, {
    key: "_notify",
    value: function _notify() {
      if (!this._reading || this._missing === 0) return;

      if (!this._torrent.bitfield.get(this._piece)) {
        return this._torrent.critical(this._piece, this._piece + this._criticalLength);
      }

      if (this._notifying) return;
      this._notifying = true;
      if (this._torrent.destroyed) return this.destroy(new Error('Torrent removed'));
      const p = this._piece;
      const getOpts = {}; // Specify length for the last piece in case it is zero-padded

      if (p === this._torrent.pieces.length - 1) {
        getOpts.length = this._torrent.lastPieceLength;
      }

      this._torrent.store.get(p, getOpts, (err, buffer) => {
        this._notifying = false;
        if (this.destroyed) return;
        debug('read %s (length %s) (err %s)', p, buffer && buffer.length, err && err.message);
        if (err) return this.destroy(err);

        if (this._offset) {
          buffer = buffer.slice(this._offset);
          this._offset = 0;
        }

        if (this._missing < buffer.length) {
          buffer = buffer.slice(0, this._missing);
        }

        this._missing -= buffer.length;
        debug('pushing buffer of length %s', buffer.length);
        this._reading = false;
        this.push(buffer);
        if (this._missing === 0) this.push(null);
      });

      this._piece += 1;
    }
  }, {
    key: "_destroy",
    value: function _destroy(err, cb) {
      if (!this._torrent.destroyed) {
        this._torrent.deselect(this._startPiece, this._endPiece, true);
      }

      cb(err);
    }
  }]);

  return FileStream;
}(stream.Readable);

module.exports = FileStream;

/***/ }),

/***/ "./node_modules/webtorrent/lib/file.js":
/*!*********************************************!*\
  !*** ./node_modules/webtorrent/lib/file.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

const EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");

const {
  PassThrough
} = __webpack_require__(/*! stream */ "./src/shims/stream.ts");

const path = __webpack_require__(/*! path */ "./src/shims/path.ts");

const render = __webpack_require__(/*! render-media */ "./node_modules/render-media/index.js");

const streamToBlob = __webpack_require__(/*! stream-to-blob */ "./node_modules/stream-to-blob/index.js");

const streamToBlobURL = __webpack_require__(/*! stream-to-blob-url */ "./node_modules/stream-to-blob-url/index.js");

const streamToBuffer = __webpack_require__(/*! stream-with-known-length-to-buffer */ "./node_modules/stream-with-known-length-to-buffer/index.js");

const queueMicrotask = __webpack_require__(/*! queue-microtask */ "./node_modules/queue-microtask/index.js");

const rangeParser = __webpack_require__(/*! range-parser */ "./node_modules/range-parser/index.js");

const mime = __webpack_require__(/*! mime */ "./node_modules/mime/index.js");

const eos = __webpack_require__(/*! end-of-stream */ "./node_modules/end-of-stream/index.js");

const FileStream = __webpack_require__(/*! ./file-stream.js */ "./node_modules/webtorrent/lib/file-stream.js");

let File = /*#__PURE__*/function (_EventEmitter) {
  _inherits(File, _EventEmitter);

  var _super = _createSuper(File);

  function File(torrent, file) {
    var _this;

    _classCallCheck(this, File);

    _this = _super.call(this);
    _this._torrent = torrent;
    _this._destroyed = false;
    _this._fileStreams = new Set();
    _this.name = file.name;
    _this.path = file.path;
    _this.length = file.length;
    _this.offset = file.offset;
    _this.done = false;
    const start = file.offset;
    const end = start + file.length - 1;
    _this._startPiece = start / _this._torrent.pieceLength | 0;
    _this._endPiece = end / _this._torrent.pieceLength | 0;

    if (_this.length === 0) {
      _this.done = true;

      _this.emit('done');
    }

    _this._serviceWorker = torrent.client.serviceWorker;
    return _this;
  }

  _createClass(File, [{
    key: "downloaded",
    get: function () {
      if (this._destroyed || !this._torrent.bitfield) return 0;
      const {
        pieces,
        bitfield,
        pieceLength,
        lastPieceLength
      } = this._torrent;
      const {
        _startPiece: start,
        _endPiece: end
      } = this;

      const getPieceLength = pieceIndex => pieceIndex === pieces.length - 1 ? lastPieceLength : pieceLength;

      const getPieceDownloaded = pieceIndex => {
        const len = pieceIndex === pieces.length - 1 ? lastPieceLength : pieceLength;

        if (bitfield.get(pieceIndex)) {
          // verified data
          return len;
        } else {
          // "in progress" data
          return len - pieces[pieceIndex].missing;
        }
      };

      let downloaded = 0;

      for (let index = start; index <= end; index += 1) {
        const pieceDownloaded = getPieceDownloaded(index);
        downloaded += pieceDownloaded;

        if (index === start) {
          // First piece may have an offset, e.g. irrelevant bytes from the end of
          // the previous file
          const irrelevantFirstPieceBytes = this.offset % pieceLength;
          downloaded -= Math.min(irrelevantFirstPieceBytes, pieceDownloaded);
        }

        if (index === end) {
          // Last piece may have an offset, e.g. irrelevant bytes from the start
          // of the next file
          const irrelevantLastPieceBytes = getPieceLength(end) - (this.offset + this.length) % pieceLength;
          downloaded -= Math.min(irrelevantLastPieceBytes, pieceDownloaded);
        }
      }

      return downloaded;
    }
  }, {
    key: "progress",
    get: function () {
      return this.length ? this.downloaded / this.length : 0;
    }
  }, {
    key: "select",
    value: function select(priority) {
      if (this.length === 0) return;

      this._torrent.select(this._startPiece, this._endPiece, priority);
    }
  }, {
    key: "deselect",
    value: function deselect() {
      if (this.length === 0) return;

      this._torrent.deselect(this._startPiece, this._endPiece, false);
    }
  }, {
    key: "createReadStream",
    value: function createReadStream(opts) {
      if (this.length === 0) {
        const empty = new PassThrough();
        queueMicrotask(() => {
          empty.end();
        });
        return empty;
      }

      const fileStream = new FileStream(this, opts);

      this._fileStreams.add(fileStream);

      fileStream.once('close', () => {
        this._fileStreams.delete(fileStream);
      });
      return fileStream;
    }
  }, {
    key: "getBuffer",
    value: function getBuffer(cb) {
      streamToBuffer(this.createReadStream(), this.length, cb);
    }
  }, {
    key: "getBlob",
    value: function getBlob(cb) {
      if (typeof window === 'undefined') throw new Error('browser-only method');
      streamToBlob(this.createReadStream(), this._getMimeType()).then(blob => cb(null, blob), err => cb(err));
    }
  }, {
    key: "getBlobURL",
    value: function getBlobURL(cb) {
      if (typeof window === 'undefined') throw new Error('browser-only method');
      streamToBlobURL(this.createReadStream(), this._getMimeType()).then(blobUrl => cb(null, blobUrl), err => cb(err));
    }
  }, {
    key: "appendTo",
    value: function appendTo(elem, opts, cb) {
      if (typeof window === 'undefined') throw new Error('browser-only method');
      render.append(this, elem, opts, cb);
    }
  }, {
    key: "renderTo",
    value: function renderTo(elem, opts, cb) {
      if (typeof window === 'undefined') throw new Error('browser-only method');
      render.render(this, elem, opts, cb);
    }
  }, {
    key: "_serve",
    value: function _serve(req) {
      const res = {
        status: 200,
        headers: {
          // Support range-requests
          'Accept-Ranges': 'bytes',
          'Content-Type': mime.getType(this.name),
          'Cache-Control': 'no-cache, no-store, must-revalidate, max-age=0',
          Expires: '0'
        },
        body: req.method === 'HEAD' ? '' : 'STREAM'
      }; // force the browser to download the file if if it's opened in a new tab

      if (req.destination === 'document') {
        res.headers['Content-Type'] = 'application/octet-stream';
        res.headers['Content-Disposition'] = 'attachment';
        res.body = 'DOWNLOAD';
      } // `rangeParser` returns an array of ranges, or an error code (number) if
      // there was an error parsing the range.


      let range = rangeParser(this.length, req.headers.range || '');

      if (range.constructor === Array) {
        res.status = 206; // indicates that range-request was understood
        // no support for multi-range request, just use the first range

        range = range[0];
        res.headers['Content-Range'] = "bytes ".concat(range.start, "-").concat(range.end, "/").concat(this.length);
        res.headers['Content-Length'] = "".concat(range.end - range.start + 1);
      } else {
        res.headers['Content-Length'] = this.length;
      }

      const stream = req.method === 'GET' && this.createReadStream(range);
      let pipe = null;

      if (stream) {
        this.emit('stream', {
          stream,
          req,
          file: this
        }, piped => {
          pipe = piped; // piped stream might not close the original filestream on close/error, this is agressive but necessary

          eos(piped, () => {
            if (piped) piped.destroy();
            stream.destroy();
          });
        });
      }

      return [res, pipe || stream, pipe && stream];
    }
  }, {
    key: "getStreamURL",
    value: function getStreamURL() {
      let cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};
      if (typeof window === 'undefined') throw new Error('browser-only method');
      if (!this._serviceWorker) throw new Error('No worker registered');
      if (this._serviceWorker.state !== 'activated') throw new Error('Worker isn\'t activated');

      const workerPath = this._serviceWorker.scriptURL.slice(0, this._serviceWorker.scriptURL.lastIndexOf('/') + 1).slice(window.location.origin.length);

      const url = "".concat(workerPath, "webtorrent/").concat(this._torrent.infoHash, "/").concat(encodeURI(this.path));
      cb(null, url);
    }
  }, {
    key: "streamTo",
    value: function streamTo(elem) {
      let cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
      if (typeof window === 'undefined') throw new Error('browser-only method');
      if (!this._serviceWorker) throw new Error('No worker registered');
      if (this._serviceWorker.state !== 'activated') throw new Error('Worker isn\'t activated');

      const workerPath = this._serviceWorker.scriptURL.slice(0, this._serviceWorker.scriptURL.lastIndexOf('/') + 1).slice(window.location.origin.length);

      elem.src = "".concat(workerPath, "webtorrent/").concat(this._torrent.infoHash, "/").concat(encodeURI(this.path));
      cb(null, elem);
    }
  }, {
    key: "_getMimeType",
    value: function _getMimeType() {
      return render.mime[path.extname(this.name).toLowerCase()];
    }
  }, {
    key: "_destroy",
    value: function _destroy() {
      this._destroyed = true;
      this._torrent = null;

      for (const fileStream of this._fileStreams) {
        fileStream.destroy();
      }

      this._fileStreams.clear();
    }
  }]);

  return File;
}(EventEmitter);

module.exports = File;

/***/ }),

/***/ "./node_modules/webtorrent/lib/peer.js":
/*!*********************************************!*\
  !*** ./node_modules/webtorrent/lib/peer.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

const EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");

const {
  Transform
} = __webpack_require__(/*! stream */ "./src/shims/stream.ts");

const arrayRemove = __webpack_require__(/*! unordered-array-remove */ "./node_modules/unordered-array-remove/index.js");

const debugFactory = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");

const Wire = __webpack_require__(/*! bittorrent-protocol */ "./node_modules/bittorrent-protocol/index.js");

const CONNECT_TIMEOUT_TCP = 5000;
const CONNECT_TIMEOUT_UTP = 5000;
const CONNECT_TIMEOUT_WEBRTC = 25000;
const HANDSHAKE_TIMEOUT = 25000;
const debug = debugFactory('webtorrent:peer');
let secure = false;

exports.enableSecure = () => {
  secure = true;
};
/**
 * WebRTC peer connections start out connected, because WebRTC peers require an
 * "introduction" (i.e. WebRTC signaling), and there's no equivalent to an IP address
 * that lets you refer to a WebRTC endpoint.
 */


exports.createWebRTCPeer = (conn, swarm, throttleGroups) => {
  const peer = new Peer(conn.id, 'webrtc');
  peer.conn = conn;
  peer.swarm = swarm;
  peer.throttleGroups = throttleGroups;

  if (peer.conn.connected) {
    peer.onConnect();
  } else {
    const cleanup = () => {
      peer.conn.removeListener('connect', onConnect);
      peer.conn.removeListener('error', onError);
    };

    const onConnect = () => {
      cleanup();
      peer.onConnect();
    };

    const onError = err => {
      cleanup();
      peer.destroy(err);
    };

    peer.conn.once('connect', onConnect);
    peer.conn.once('error', onError);
    peer.startConnectTimeout();
  }

  return peer;
};
/**
 * Incoming TCP peers start out connected, because the remote peer connected to the
 * listening port of the TCP server. Until the remote peer sends a handshake, we don't
 * know what swarm the connection is intended for.
 */


exports.createTCPIncomingPeer = (conn, throttleGroups) => {
  return _createIncomingPeer(conn, 'tcpIncoming', throttleGroups);
};
/**
 * Incoming uTP peers start out connected, because the remote peer connected to the
 * listening port of the uTP server. Until the remote peer sends a handshake, we don't
 * know what swarm the connection is intended for.
 */


exports.createUTPIncomingPeer = (conn, throttleGroups) => {
  return _createIncomingPeer(conn, 'utpIncoming', throttleGroups);
};
/**
 * Outgoing TCP peers start out with just an IP address. At some point (when there is an
 * available connection), the client can attempt to connect to the address.
 */


exports.createTCPOutgoingPeer = (addr, swarm, throttleGroups) => {
  return _createOutgoingPeer(addr, swarm, 'tcpOutgoing', throttleGroups);
};
/**
 * Outgoing uTP peers start out with just an IP address. At some point (when there is an
 * available connection), the client can attempt to connect to the address.
 */


exports.createUTPOutgoingPeer = (addr, swarm, throttleGroups) => {
  return _createOutgoingPeer(addr, swarm, 'utpOutgoing', throttleGroups);
};

const _createIncomingPeer = (conn, type, throttleGroups) => {
  const addr = "".concat(conn.remoteAddress, ":").concat(conn.remotePort);
  const peer = new Peer(addr, type);
  peer.conn = conn;
  peer.addr = addr;
  peer.throttleGroups = throttleGroups;
  peer.onConnect();
  return peer;
};

const _createOutgoingPeer = (addr, swarm, type, throttleGroups) => {
  const peer = new Peer(addr, type);
  peer.addr = addr;
  peer.swarm = swarm;
  peer.throttleGroups = throttleGroups;
  return peer;
};
/**
 * Peer that represents a Web Seed (BEP17 / BEP19).
 */


exports.createWebSeedPeer = (conn, id, swarm, throttleGroups) => {
  const peer = new Peer(id, 'webSeed');
  peer.swarm = swarm;
  peer.conn = conn;
  peer.throttleGroups = throttleGroups;
  peer.onConnect();
  return peer;
};
/**
 * Peer. Represents a peer in the torrent swarm.
 *
 * @param {string} id "ip:port" string, peer id (for WebRTC peers), or url (for Web Seeds)
 * @param {string} type the type of the peer
 */


let Peer = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Peer, _EventEmitter);

  var _super = _createSuper(Peer);

  function Peer(id, type) {
    var _this;

    _classCallCheck(this, Peer);

    _this = _super.call(this);
    _this.id = id;
    _this.type = type;
    debug('new %s Peer %s', type, id);
    _this.addr = null;
    _this.conn = null;
    _this.swarm = null;
    _this.wire = null;
    _this.connected = false;
    _this.destroyed = false;
    _this.timeout = null; // handshake timeout

    _this.retries = 0; // outgoing TCP connection retry count

    _this.sentPe1 = false;
    _this.sentPe2 = false;
    _this.sentPe3 = false;
    _this.sentPe4 = false;
    _this.sentHandshake = false;
    return _this;
  }
  /**
   * Called once the peer is connected (i.e. fired 'connect' event)
   * @param {Socket} conn
   */


  _createClass(Peer, [{
    key: "onConnect",
    value: function onConnect() {
      if (this.destroyed) return;
      this.connected = true;
      debug('Peer %s connected', this.id);
      clearTimeout(this.connectTimeout);
      const conn = this.conn;
      conn.once('end', () => {
        this.destroy();
      });
      conn.once('close', () => {
        this.destroy();
      });
      conn.once('finish', () => {
        this.destroy();
      });
      conn.once('error', err => {
        this.destroy(err);
      });
      const wire = this.wire = new Wire(this.type, this.retries, secure);
      wire.once('end', () => {
        this.destroy();
      });
      wire.once('close', () => {
        this.destroy();
      });
      wire.once('finish', () => {
        this.destroy();
      });
      wire.once('error', err => {
        this.destroy(err);
      });
      wire.once('pe1', () => {
        this.onPe1();
      });
      wire.once('pe2', () => {
        this.onPe2();
      });
      wire.once('pe3', () => {
        this.onPe3();
      });
      wire.once('pe4', () => {
        this.onPe4();
      });
      wire.once('handshake', (infoHash, peerId) => {
        this.onHandshake(infoHash, peerId);
      });
      this.startHandshakeTimeout();
      this.setThrottlePipes();

      if (this.swarm) {
        if (this.type === 'tcpOutgoing') {
          if (secure && this.retries === 0 && !this.sentPe1) this.sendPe1();else if (!this.sentHandshake) this.handshake();
        } else if (this.type !== 'tcpIncoming' && !this.sentHandshake) this.handshake();
      }
    }
  }, {
    key: "sendPe1",
    value: function sendPe1() {
      this.wire.sendPe1();
      this.sentPe1 = true;
    }
  }, {
    key: "onPe1",
    value: function onPe1() {
      this.sendPe2();
    }
  }, {
    key: "sendPe2",
    value: function sendPe2() {
      this.wire.sendPe2();
      this.sentPe2 = true;
    }
  }, {
    key: "onPe2",
    value: function onPe2() {
      this.sendPe3();
    }
  }, {
    key: "sendPe3",
    value: function sendPe3() {
      this.wire.sendPe3(this.swarm.infoHash);
      this.sentPe3 = true;
    }
  }, {
    key: "onPe3",
    value: function onPe3(infoHashHash) {
      if (this.swarm) {
        if (this.swarm.infoHashHash !== infoHashHash) {
          this.destroy(new Error('unexpected crypto handshake info hash for this swarm'));
        }

        this.sendPe4();
      }
    }
  }, {
    key: "sendPe4",
    value: function sendPe4() {
      this.wire.sendPe4(this.swarm.infoHash);
      this.sentPe4 = true;
    }
  }, {
    key: "onPe4",
    value: function onPe4() {
      if (!this.sentHandshake) this.handshake();
    }
  }, {
    key: "clearPipes",
    value: function clearPipes() {
      this.conn.unpipe();
      this.wire.unpipe();
    }
  }, {
    key: "setThrottlePipes",
    value: function setThrottlePipes() {
      const self = this;
      this.conn.pipe(this.throttleGroups.down.throttle()).pipe(new Transform({
        transform(chunk, _, callback) {
          self.emit('download', chunk.length);
          if (self.destroyed) return;
          callback(null, chunk);
        }

      })).pipe(this.wire).pipe(this.throttleGroups.up.throttle()).pipe(new Transform({
        transform(chunk, _, callback) {
          self.emit('upload', chunk.length);
          if (self.destroyed) return;
          callback(null, chunk);
        }

      })).pipe(this.conn);
    }
    /**
     * Called when handshake is received from remote peer.
     * @param {string} infoHash
     * @param {string} peerId
     */

  }, {
    key: "onHandshake",
    value: function onHandshake(infoHash, peerId) {
      if (!this.swarm) return; // `this.swarm` not set yet, so do nothing

      if (this.destroyed) return;

      if (this.swarm.destroyed) {
        return this.destroy(new Error('swarm already destroyed'));
      }

      if (infoHash !== this.swarm.infoHash) {
        return this.destroy(new Error('unexpected handshake info hash for this swarm'));
      }

      if (peerId === this.swarm.peerId) {
        return this.destroy(new Error('refusing to connect to ourselves'));
      }

      debug('Peer %s got handshake %s', this.id, infoHash);
      clearTimeout(this.handshakeTimeout);
      this.retries = 0;
      let addr = this.addr;

      if (!addr && this.conn.remoteAddress && this.conn.remotePort) {
        addr = "".concat(this.conn.remoteAddress, ":").concat(this.conn.remotePort);
      }

      this.swarm._onWire(this.wire, addr); // swarm could be destroyed in user's 'wire' event handler


      if (!this.swarm || this.swarm.destroyed) return;
      if (!this.sentHandshake) this.handshake();
    }
  }, {
    key: "handshake",
    value: function handshake() {
      const opts = {
        dht: this.swarm.private ? false : !!this.swarm.client.dht,
        fast: true
      };
      this.wire.handshake(this.swarm.infoHash, this.swarm.client.peerId, opts);
      this.sentHandshake = true;
    }
  }, {
    key: "startConnectTimeout",
    value: function startConnectTimeout() {
      clearTimeout(this.connectTimeout);
      const connectTimeoutValues = {
        webrtc: CONNECT_TIMEOUT_WEBRTC,
        tcpOutgoing: CONNECT_TIMEOUT_TCP,
        utpOutgoing: CONNECT_TIMEOUT_UTP
      };
      this.connectTimeout = setTimeout(() => {
        this.destroy(new Error('connect timeout'));
      }, connectTimeoutValues[this.type]);
      if (this.connectTimeout.unref) this.connectTimeout.unref();
    }
  }, {
    key: "startHandshakeTimeout",
    value: function startHandshakeTimeout() {
      clearTimeout(this.handshakeTimeout);
      this.handshakeTimeout = setTimeout(() => {
        this.destroy(new Error('handshake timeout'));
      }, HANDSHAKE_TIMEOUT);
      if (this.handshakeTimeout.unref) this.handshakeTimeout.unref();
    }
  }, {
    key: "destroy",
    value: function destroy(err) {
      if (this.destroyed) return;
      this.destroyed = true;
      this.connected = false;
      debug('destroy %s %s (error: %s)', this.type, this.id, err && (err.message || err));
      clearTimeout(this.connectTimeout);
      clearTimeout(this.handshakeTimeout);
      const swarm = this.swarm;
      const conn = this.conn;
      const wire = this.wire;
      this.swarm = null;
      this.conn = null;
      this.wire = null;

      if (swarm && wire) {
        arrayRemove(swarm.wires, swarm.wires.indexOf(wire));
      }

      if (conn) {
        conn.on('error', () => {});
        conn.destroy();
      }

      if (wire) wire.destroy();
      if (swarm) swarm.removePeer(this.id);
    }
  }]);

  return Peer;
}(EventEmitter);

/***/ }),

/***/ "./node_modules/webtorrent/lib/rarity-map.js":
/*!***************************************************!*\
  !*** ./node_modules/webtorrent/lib/rarity-map.js ***!
  \***************************************************/
/***/ ((module) => {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Mapping of torrent pieces to their respective availability in the torrent swarm. Used
 * by the torrent manager for implementing the rarest piece first selection strategy.
 */
let RarityMap = /*#__PURE__*/function () {
  function RarityMap(torrent) {
    _classCallCheck(this, RarityMap);

    this._torrent = torrent;
    this._numPieces = torrent.pieces.length;
    this._pieces = new Array(this._numPieces);

    this._onWire = wire => {
      this.recalculate();

      this._initWire(wire);
    };

    this._onWireHave = index => {
      this._pieces[index] += 1;
    };

    this._onWireBitfield = () => {
      this.recalculate();
    };

    this._torrent.wires.forEach(wire => {
      this._initWire(wire);
    });

    this._torrent.on('wire', this._onWire);

    this.recalculate();
  }
  /**
   * Get the index of the rarest piece. Optionally, pass a filter function to exclude
   * certain pieces (for instance, those that we already have).
   *
   * @param {function} pieceFilterFunc
   * @return {number} index of rarest piece, or -1
   */


  _createClass(RarityMap, [{
    key: "getRarestPiece",
    value: function getRarestPiece(pieceFilterFunc) {
      let candidates = [];
      let min = Infinity;

      for (let i = 0; i < this._numPieces; ++i) {
        if (pieceFilterFunc && !pieceFilterFunc(i)) continue;
        const availability = this._pieces[i];

        if (availability === min) {
          candidates.push(i);
        } else if (availability < min) {
          candidates = [i];
          min = availability;
        }
      }

      if (candidates.length) {
        // if there are multiple pieces with the same availability, choose one randomly
        return candidates[Math.random() * candidates.length | 0];
      } else {
        return -1;
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this._torrent.removeListener('wire', this._onWire);

      this._torrent.wires.forEach(wire => {
        this._cleanupWireEvents(wire);
      });

      this._torrent = null;
      this._pieces = null;
      this._onWire = null;
      this._onWireHave = null;
      this._onWireBitfield = null;
    }
  }, {
    key: "_initWire",
    value: function _initWire(wire) {
      wire._onClose = () => {
        this._cleanupWireEvents(wire);

        for (let i = 0; i < this._numPieces; ++i) {
          this._pieces[i] -= wire.peerPieces.get(i);
        }
      };

      wire.on('have', this._onWireHave);
      wire.on('bitfield', this._onWireBitfield);
      wire.once('close', wire._onClose);
    }
    /**
     * Recalculates piece availability across all peers in the torrent.
     */

  }, {
    key: "recalculate",
    value: function recalculate() {
      this._pieces.fill(0);

      for (const wire of this._torrent.wires) {
        for (let i = 0; i < this._numPieces; ++i) {
          this._pieces[i] += wire.peerPieces.get(i);
        }
      }
    }
  }, {
    key: "_cleanupWireEvents",
    value: function _cleanupWireEvents(wire) {
      wire.removeListener('have', this._onWireHave);
      wire.removeListener('bitfield', this._onWireBitfield);
      if (wire._onClose) wire.removeListener('close', wire._onClose);
      wire._onClose = null;
    }
  }]);

  return RarityMap;
}();

module.exports = RarityMap;

/***/ }),

/***/ "./node_modules/webtorrent/lib/torrent.js":
/*!************************************************!*\
  !*** ./node_modules/webtorrent/lib/torrent.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/* global Blob */
const EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");

const fs = __webpack_require__(/*! fs */ "?c172");

const net = __webpack_require__(/*! net */ "?c362"); // browser exclude


const os = __webpack_require__(/*! os */ "?5efe"); // browser exclude


const path = __webpack_require__(/*! path */ "./src/shims/path.ts");

const addrToIPPort = __webpack_require__(/*! addr-to-ip-port */ "./node_modules/addr-to-ip-port/index.js");

const {
  default: BitField
} = __webpack_require__(/*! bitfield */ "./node_modules/bitfield/lib/index.js");

const CacheChunkStore = __webpack_require__(/*! cache-chunk-store */ "./node_modules/cache-chunk-store/index.js");

const ChunkStoreWriteStream = __webpack_require__(/*! chunk-store-stream/write */ "./node_modules/chunk-store-stream/write.js");

const cpus = __webpack_require__(/*! cpus */ "./node_modules/cpus/browser.js");

const debugFactory = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");

const Discovery = __webpack_require__(/*! torrent-discovery */ "./node_modules/torrent-discovery/index.js");

const FSChunkStore = __webpack_require__(/*! fs-chunk-store */ "./node_modules/memory-chunk-store/index.js"); // browser: `memory-chunk-store`


const get = __webpack_require__(/*! simple-get */ "./node_modules/simple-get/index.js");

const ImmediateChunkStore = __webpack_require__(/*! immediate-chunk-store */ "./node_modules/immediate-chunk-store/index.js");

const ltDontHave = __webpack_require__(/*! lt_donthave */ "./node_modules/lt_donthave/index.js");

const MemoryChunkStore = __webpack_require__(/*! memory-chunk-store */ "./node_modules/memory-chunk-store/index.js");

const MultiStream = __webpack_require__(/*! multistream */ "./node_modules/multistream/index.js");

const parallel = __webpack_require__(/*! run-parallel */ "./node_modules/run-parallel/index.js");

const parallelLimit = __webpack_require__(/*! run-parallel-limit */ "./node_modules/run-parallel-limit/index.js");

const parseTorrent = __webpack_require__(/*! parse-torrent */ "./node_modules/parse-torrent/index.js");

const Piece = __webpack_require__(/*! torrent-piece */ "./node_modules/torrent-piece/index.js");

const pump = __webpack_require__(/*! pump */ "./node_modules/pump/index.js");

const queueMicrotask = __webpack_require__(/*! queue-microtask */ "./node_modules/queue-microtask/index.js");

const randomIterate = __webpack_require__(/*! random-iterate */ "./node_modules/random-iterate/index.js");

const sha1 = __webpack_require__(/*! simple-sha1 */ "./node_modules/simple-sha1/browser.js");

const throughput = __webpack_require__(/*! throughput */ "./node_modules/throughput/index.js");

const utMetadata = __webpack_require__(/*! ut_metadata */ "./node_modules/ut_metadata/index.js");

const utPex = __webpack_require__(/*! ut_pex */ "?6dbd"); // browser exclude


const File = __webpack_require__(/*! ./file.js */ "./node_modules/webtorrent/lib/file.js");

const Peer = __webpack_require__(/*! ./peer.js */ "./node_modules/webtorrent/lib/peer.js");

const RarityMap = __webpack_require__(/*! ./rarity-map.js */ "./node_modules/webtorrent/lib/rarity-map.js");

const Server = __webpack_require__(/*! ./server.js */ "?8616"); // browser exclude


const utp = __webpack_require__(/*! ./utp.js */ "?26b1"); // browser exclude


const WebConn = __webpack_require__(/*! ./webconn.js */ "./node_modules/webtorrent/lib/webconn.js");

const debug = debugFactory('webtorrent:torrent');
const MAX_BLOCK_LENGTH = 128 * 1024;
const PIECE_TIMEOUT = 30000;
const CHOKE_TIMEOUT = 5000;
const SPEED_THRESHOLD = 3 * Piece.BLOCK_LENGTH;
const PIPELINE_MIN_DURATION = 0.5;
const PIPELINE_MAX_DURATION = 1;
const RECHOKE_INTERVAL = 10000; // 10 seconds

const RECHOKE_OPTIMISTIC_DURATION = 2; // 30 seconds
// IndexedDB chunk stores used in the browser benefit from high concurrency

const FILESYSTEM_CONCURRENCY = process.browser ? cpus().length : 2;
const RECONNECT_WAIT = [1000, 5000, 15000];

const VERSION = (__webpack_require__(/*! ../package.json */ "./node_modules/webtorrent/package.json").version);

const USER_AGENT = "WebTorrent/".concat(VERSION, " (https://webtorrent.io)");
let TMP;

try {
  TMP = path.join(fs.statSync('/tmp') && '/tmp', 'webtorrent');
} catch (err) {
  TMP = path.join(typeof os.tmpdir === 'function' ? os.tmpdir() : '/', 'webtorrent');
}

let Torrent = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Torrent, _EventEmitter);

  var _super = _createSuper(Torrent);

  function Torrent(torrentId, client, opts) {
    var _this;

    _classCallCheck(this, Torrent);

    _this = _super.call(this);
    _this._debugId = 'unknown infohash';
    _this.client = client;
    _this.announce = opts.announce;
    _this.urlList = opts.urlList;
    _this.path = opts.path || TMP;
    _this.addUID = opts.addUID || false;
    _this.skipVerify = !!opts.skipVerify;
    _this._store = opts.store || FSChunkStore;
    _this._preloadedStore = opts.preloadedStore || null;
    _this._storeCacheSlots = opts.storeCacheSlots !== undefined ? opts.storeCacheSlots : 20;
    _this._destroyStoreOnDestroy = opts.destroyStoreOnDestroy || false;
    _this._getAnnounceOpts = opts.getAnnounceOpts; // if defined, `opts.private` overrides default privacy of torrent

    if (typeof opts.private === 'boolean') _this.private = opts.private;
    _this.strategy = opts.strategy || 'sequential';
    _this.maxWebConns = opts.maxWebConns || 4;
    _this._rechokeNumSlots = opts.uploads === false || opts.uploads === 0 ? 0 : +opts.uploads || 10;
    _this._rechokeOptimisticWire = null;
    _this._rechokeOptimisticTime = 0;
    _this._rechokeIntervalId = null;
    _this.ready = false;
    _this.destroyed = false;
    _this.paused = opts.paused || false;
    _this.done = false;
    _this.metadata = null;
    _this.store = null;
    _this.storeOpts = opts.storeOpts;
    _this.files = [];
    _this.pieces = [];
    _this._amInterested = false;
    _this._selections = [];
    _this._critical = [];
    _this.wires = []; // open wires (added *after* handshake)

    _this._queue = []; // queue of outgoing tcp peers to connect to

    _this._peers = {}; // connected peers (addr/peerId -> Peer)

    _this._peersLength = 0; // number of elements in `this._peers` (cache, for perf)
    // stats

    _this.received = 0;
    _this.uploaded = 0;
    _this._downloadSpeed = throughput();
    _this._uploadSpeed = throughput(); // for cleanup

    _this._servers = [];
    _this._xsRequests = []; // TODO: remove this and expose a hook instead
    // optimization: don't recheck every file if it hasn't changed

    _this._fileModtimes = opts.fileModtimes;
    if (torrentId !== null) _this._onTorrentId(torrentId);

    _this._debug('new torrent');

    return _this;
  }

  _createClass(Torrent, [{
    key: "timeRemaining",
    get: function () {
      if (this.done) return 0;
      if (this.downloadSpeed === 0) return Infinity;
      return (this.length - this.downloaded) / this.downloadSpeed * 1000;
    }
  }, {
    key: "downloaded",
    get: function () {
      if (!this.bitfield) return 0;
      let downloaded = 0;

      for (let index = 0, len = this.pieces.length; index < len; ++index) {
        if (this.bitfield.get(index)) {
          // verified data
          downloaded += index === len - 1 ? this.lastPieceLength : this.pieceLength;
        } else {
          // "in progress" data
          const piece = this.pieces[index];
          downloaded += piece.length - piece.missing;
        }
      }

      return downloaded;
    } // TODO: re-enable this. The number of missing pieces. Used to implement 'end game' mode.
    // Object.defineProperty(Storage.prototype, 'numMissing', {
    //   get: function () {
    //     var self = this
    //     var numMissing = self.pieces.length
    //     for (var index = 0, len = self.pieces.length; index < len; index++) {
    //       numMissing -= self.bitfield.get(index)
    //     }
    //     return numMissing
    //   }
    // })

  }, {
    key: "downloadSpeed",
    get: function () {
      return this._downloadSpeed();
    }
  }, {
    key: "uploadSpeed",
    get: function () {
      return this._uploadSpeed();
    }
  }, {
    key: "progress",
    get: function () {
      return this.length ? this.downloaded / this.length : 0;
    }
  }, {
    key: "ratio",
    get: function () {
      return this.uploaded / (this.received || this.length);
    }
  }, {
    key: "numPeers",
    get: function () {
      return this.wires.length;
    }
  }, {
    key: "torrentFileBlobURL",
    get: function () {
      if (typeof window === 'undefined') throw new Error('browser-only property');
      if (!this.torrentFile) return null;
      return URL.createObjectURL(new Blob([this.torrentFile], {
        type: 'application/x-bittorrent'
      }));
    }
  }, {
    key: "_numQueued",
    get: function () {
      return this._queue.length + (this._peersLength - this._numConns);
    }
  }, {
    key: "_numConns",
    get: function () {
      let numConns = 0;

      for (const id in this._peers) {
        if (this._peers[id].connected) numConns += 1;
      }

      return numConns;
    }
  }, {
    key: "_onTorrentId",
    value: function _onTorrentId(torrentId) {
      if (this.destroyed) return;
      let parsedTorrent;

      try {
        parsedTorrent = parseTorrent(torrentId);
      } catch (err) {}

      if (parsedTorrent) {
        // Attempt to set infoHash property synchronously
        this.infoHash = parsedTorrent.infoHash;
        this._debugId = parsedTorrent.infoHash.toString('hex').substring(0, 7);
        queueMicrotask(() => {
          if (this.destroyed) return;

          this._onParsedTorrent(parsedTorrent);
        });
      } else {
        // If torrentId failed to parse, it could be in a form that requires an async
        // operation, i.e. http/https link, filesystem path, or Blob.
        parseTorrent.remote(torrentId, (err, parsedTorrent) => {
          if (this.destroyed) return;
          if (err) return this._destroy(err);

          this._onParsedTorrent(parsedTorrent);
        });
      }
    }
  }, {
    key: "_onParsedTorrent",
    value: function _onParsedTorrent(parsedTorrent) {
      if (this.destroyed) return;

      this._processParsedTorrent(parsedTorrent);

      if (!this.infoHash) {
        return this._destroy(new Error('Malformed torrent data: No info hash'));
      }

      this._rechokeIntervalId = setInterval(() => {
        this._rechoke();
      }, RECHOKE_INTERVAL);
      if (this._rechokeIntervalId.unref) this._rechokeIntervalId.unref(); // Private 'infoHash' event allows client.add to check for duplicate torrents and
      // destroy them before the normal 'infoHash' event is emitted. Prevents user
      // applications from needing to deal with duplicate 'infoHash' events.

      this.emit('_infoHash', this.infoHash);
      if (this.destroyed) return;
      this.emit('infoHash', this.infoHash);
      if (this.destroyed) return; // user might destroy torrent in event handler

      if (this.client.listening) {
        this._onListening();
      } else {
        this.client.once('listening', () => {
          this._onListening();
        });
      }
    }
  }, {
    key: "_processParsedTorrent",
    value: function _processParsedTorrent(parsedTorrent) {
      this._debugId = parsedTorrent.infoHash.toString('hex').substring(0, 7);

      if (typeof this.private !== 'undefined') {
        // `private` option overrides default, only if it's defined
        parsedTorrent.private = this.private;
      }

      if (this.announce) {
        // Allow specifying trackers via `opts` parameter
        parsedTorrent.announce = parsedTorrent.announce.concat(this.announce);
      }

      if (this.client.tracker && __webpack_require__.g.WEBTORRENT_ANNOUNCE && !parsedTorrent.private) {
        // So `webtorrent-hybrid` can force specific trackers to be used
        parsedTorrent.announce = parsedTorrent.announce.concat(__webpack_require__.g.WEBTORRENT_ANNOUNCE);
      }

      if (this.urlList) {
        // Allow specifying web seeds via `opts` parameter
        parsedTorrent.urlList = parsedTorrent.urlList.concat(this.urlList);
      } // remove duplicates by converting to Set and back


      parsedTorrent.announce = Array.from(new Set(parsedTorrent.announce));
      parsedTorrent.urlList = Array.from(new Set(parsedTorrent.urlList));
      Object.assign(this, parsedTorrent);
      this.magnetURI = parseTorrent.toMagnetURI(parsedTorrent);
      this.torrentFile = parseTorrent.toTorrentFile(parsedTorrent);
    }
  }, {
    key: "_onListening",
    value: function _onListening() {
      if (this.destroyed) return;

      if (this.info) {
        // if full metadata was included in initial torrent id, use it immediately. Otherwise,
        // wait for torrent-discovery to find peers and ut_metadata to get the metadata.
        this._onMetadata(this);
      } else {
        if (this.xs) this._getMetadataFromServer();

        this._startDiscovery();
      }
    }
  }, {
    key: "_startDiscovery",
    value: function _startDiscovery() {
      if (this.discovery || this.destroyed) return;
      let trackerOpts = this.client.tracker;

      if (trackerOpts) {
        trackerOpts = Object.assign({}, this.client.tracker, {
          getAnnounceOpts: () => {
            if (this.destroyed) return;
            const opts = {
              uploaded: this.uploaded,
              downloaded: this.downloaded,
              left: Math.max(this.length - this.downloaded, 0)
            };

            if (this.client.tracker.getAnnounceOpts) {
              Object.assign(opts, this.client.tracker.getAnnounceOpts());
            }

            if (this._getAnnounceOpts) {
              // TODO: consider deprecating this, as it's redundant with the former case
              Object.assign(opts, this._getAnnounceOpts());
            }

            return opts;
          }
        });
      } // add BEP09 peer-address


      if (this.peerAddresses) {
        this.peerAddresses.forEach(peer => this.addPeer(peer));
      } // begin discovering peers via DHT and trackers


      this.discovery = new Discovery({
        infoHash: this.infoHash,
        announce: this.announce,
        peerId: this.client.peerId,
        dht: !this.private && this.client.dht,
        tracker: trackerOpts,
        port: this.client.torrentPort,
        userAgent: USER_AGENT,
        lsd: this.client.lsd
      });
      this.discovery.on('error', err => {
        this._destroy(err);
      });
      this.discovery.on('peer', (peer, source) => {
        this._debug('peer %s discovered via %s', peer, source); // Don't create new outgoing TCP connections when torrent is done


        if (typeof peer === 'string' && this.done) return;
        this.addPeer(peer);
      });
      this.discovery.on('trackerAnnounce', () => {
        this.emit('trackerAnnounce');
        if (this.numPeers === 0) this.emit('noPeers', 'tracker');
      });
      this.discovery.on('dhtAnnounce', () => {
        this.emit('dhtAnnounce');
        if (this.numPeers === 0) this.emit('noPeers', 'dht');
      });
      this.discovery.on('warning', err => {
        this.emit('warning', err);
      });
    }
  }, {
    key: "_getMetadataFromServer",
    value: function _getMetadataFromServer() {
      // to allow function hoisting
      const self = this;
      const urls = Array.isArray(this.xs) ? this.xs : [this.xs];
      const tasks = urls.map(url => cb => {
        getMetadataFromURL(url, cb);
      });
      parallel(tasks);

      function getMetadataFromURL(url, cb) {
        if (url.indexOf('http://') !== 0 && url.indexOf('https://') !== 0) {
          self.emit('warning', new Error("skipping non-http xs param: ".concat(url)));
          return cb(null);
        }

        const opts = {
          url,
          method: 'GET',
          headers: {
            'user-agent': USER_AGENT
          }
        };
        let req;

        try {
          req = get.concat(opts, onResponse);
        } catch (err) {
          self.emit('warning', new Error("skipping invalid url xs param: ".concat(url)));
          return cb(null);
        }

        self._xsRequests.push(req);

        function onResponse(err, res, torrent) {
          if (self.destroyed) return cb(null);
          if (self.metadata) return cb(null);

          if (err) {
            self.emit('warning', new Error("http error from xs param: ".concat(url)));
            return cb(null);
          }

          if (res.statusCode !== 200) {
            self.emit('warning', new Error("non-200 status code ".concat(res.statusCode, " from xs param: ").concat(url)));
            return cb(null);
          }

          let parsedTorrent;

          try {
            parsedTorrent = parseTorrent(torrent);
          } catch (err) {}

          if (!parsedTorrent) {
            self.emit('warning', new Error("got invalid torrent file from xs param: ".concat(url)));
            return cb(null);
          }

          if (parsedTorrent.infoHash !== self.infoHash) {
            self.emit('warning', new Error("got torrent file with incorrect info hash from xs param: ".concat(url)));
            return cb(null);
          }

          self._onMetadata(parsedTorrent);

          cb(null);
        }
      }
    }
    /**
     * Called when the full torrent metadata is received.
     */

  }, {
    key: "_onMetadata",
    value: function _onMetadata(metadata) {
      if (this.metadata || this.destroyed) return;

      this._debug('got metadata');

      this._xsRequests.forEach(req => {
        req.abort();
      });

      this._xsRequests = [];
      let parsedTorrent;

      if (metadata && metadata.infoHash) {
        // `metadata` is a parsed torrent (from parse-torrent module)
        parsedTorrent = metadata;
      } else {
        try {
          parsedTorrent = parseTorrent(metadata);
        } catch (err) {
          return this._destroy(err);
        }
      }

      this._processParsedTorrent(parsedTorrent);

      this.metadata = this.torrentFile; // add web seed urls (BEP19)

      if (this.client.enableWebSeeds) {
        this.urlList.forEach(url => {
          this.addWebSeed(url);
        });
      }

      this._rarityMap = new RarityMap(this);
      this.files = this.files.map(file => new File(this, file));
      let rawStore = this._preloadedStore;

      if (!rawStore) {
        rawStore = new this._store(this.pieceLength, _objectSpread(_objectSpread({}, this.storeOpts), {}, {
          torrent: this,
          path: this.path,
          files: this.files,
          length: this.length,
          name: this.name + ' - ' + this.infoHash.slice(0, 8),
          addUID: this.addUID
        }));
      } // don't use the cache if the store is already in memory


      if (this._storeCacheSlots > 0 && !(rawStore instanceof MemoryChunkStore)) {
        rawStore = new CacheChunkStore(rawStore, {
          max: this._storeCacheSlots
        });
      }

      this.store = new ImmediateChunkStore(rawStore); // Select only specified files (BEP53) http://www.bittorrent.org/beps/bep_0053.html

      if (this.so) {
        this.files.forEach((v, i) => {
          if (this.so.includes(i)) {
            this.files[i].select();
          } else {
            this.files[i].deselect();
          }
        });
      } else {
        // start off selecting the entire torrent with low priority
        if (this.pieces.length !== 0) {
          this.select(0, this.pieces.length - 1, false);
        }
      }

      this._hashes = this.pieces;
      this.pieces = this.pieces.map((hash, i) => {
        const pieceLength = i === this.pieces.length - 1 ? this.lastPieceLength : this.pieceLength;
        return new Piece(pieceLength);
      });
      this._reservations = this.pieces.map(() => []);
      this.bitfield = new BitField(this.pieces.length); // Emit 'metadata' before 'ready' and 'done'

      this.emit('metadata'); // User might destroy torrent in response to 'metadata' event

      if (this.destroyed) return;

      if (this.skipVerify) {
        // Skip verifying exisitng data and just assume it's correct
        this._markAllVerified();

        this._onStore();
      } else {
        const onPiecesVerified = err => {
          if (err) return this._destroy(err);

          this._debug('done verifying');

          this._onStore();
        };

        this._debug('verifying existing torrent data');

        if (this._fileModtimes && this._store === FSChunkStore) {
          // don't verify if the files haven't been modified since we last checked
          this.getFileModtimes((err, fileModtimes) => {
            if (err) return this._destroy(err);
            const unchanged = this.files.map((_, index) => fileModtimes[index] === this._fileModtimes[index]).every(x => x);

            if (unchanged) {
              this._markAllVerified();

              this._onStore();
            } else {
              this._verifyPieces(onPiecesVerified);
            }
          });
        } else {
          this._verifyPieces(onPiecesVerified);
        }
      }
    }
    /*
     * TODO: remove this
     * Gets the last modified time of every file on disk for this torrent.
     * Only valid in Node, not in the browser.
     */

  }, {
    key: "getFileModtimes",
    value: function getFileModtimes(cb) {
      const ret = [];
      parallelLimit(this.files.map((file, index) => cb => {
        const filePath = this.addUID ? path.join(this.name + ' - ' + this.infoHash.slice(0, 8)) : path.join(this.path, file.path);
        fs.stat(filePath, (err, stat) => {
          if (err && err.code !== 'ENOENT') return cb(err);
          ret[index] = stat && stat.mtime.getTime();
          cb(null);
        });
      }), FILESYSTEM_CONCURRENCY, err => {
        this._debug('done getting file modtimes');

        cb(err, ret);
      });
    }
  }, {
    key: "_verifyPieces",
    value: function _verifyPieces(cb) {
      parallelLimit(this.pieces.map((piece, index) => cb => {
        if (this.destroyed) return cb(new Error('torrent is destroyed'));
        const getOpts = {}; // Specify length for the last piece in case it is zero-padded

        if (index === this.pieces.length - 1) {
          getOpts.length = this.lastPieceLength;
        }

        this.store.get(index, getOpts, (err, buf) => {
          if (this.destroyed) return cb(new Error('torrent is destroyed'));
          if (err) return queueMicrotask(() => cb(null)); // ignore error

          sha1(buf, hash => {
            if (this.destroyed) return cb(new Error('torrent is destroyed'));

            if (hash === this._hashes[index]) {
              this._debug('piece verified %s', index);

              this._markVerified(index);
            } else {
              this._debug('piece invalid %s', index);
            }

            cb(null);
          });
        });
      }), FILESYSTEM_CONCURRENCY, cb);
    }
  }, {
    key: "rescanFiles",
    value: function rescanFiles(cb) {
      if (this.destroyed) throw new Error('torrent is destroyed');
      if (!cb) cb = noop;

      this._verifyPieces(err => {
        if (err) {
          this._destroy(err);

          return cb(err);
        }

        this._checkDone();

        cb(null);
      });
    }
  }, {
    key: "_markAllVerified",
    value: function _markAllVerified() {
      for (let index = 0; index < this.pieces.length; index++) {
        this._markVerified(index);
      }
    }
  }, {
    key: "_markVerified",
    value: function _markVerified(index) {
      this.pieces[index] = null;
      this._reservations[index] = null;
      this.bitfield.set(index, true);
    }
  }, {
    key: "_hasAllPieces",
    value: function _hasAllPieces() {
      for (let index = 0; index < this.pieces.length; index++) {
        if (!this.bitfield.get(index)) return false;
      }

      return true;
    }
  }, {
    key: "_hasNoPieces",
    value: function _hasNoPieces() {
      return !this._hasMorePieces(0);
    }
  }, {
    key: "_hasMorePieces",
    value: function _hasMorePieces(threshold) {
      let count = 0;

      for (let index = 0; index < this.pieces.length; index++) {
        if (this.bitfield.get(index)) {
          count += 1;
          if (count > threshold) return true;
        }
      }

      return false;
    }
    /**
     * Called when the metadata, listening server, and underlying chunk store is initialized.
     */

  }, {
    key: "_onStore",
    value: function _onStore() {
      if (this.destroyed) return;

      this._debug('on store'); // Start discovery before emitting 'ready'


      this._startDiscovery();

      this.ready = true;
      this.emit('ready'); // Files may start out done if the file was already in the store

      this._checkDone(); // In case any selections were made before torrent was ready


      this._updateSelections(); // Start requesting pieces after we have initially verified them


      this.wires.forEach(wire => {
        // If we didn't have the metadata at the time ut_metadata was initialized for this
        // wire, we still want to make it available to the peer in case they request it.
        if (wire.ut_metadata) wire.ut_metadata.setMetadata(this.metadata);

        this._onWireWithMetadata(wire);
      });
    }
  }, {
    key: "destroy",
    value: function destroy(opts, cb) {
      if (typeof opts === 'function') return this.destroy(null, opts);

      this._destroy(null, opts, cb);
    }
  }, {
    key: "_destroy",
    value: function _destroy(err, opts, cb) {
      if (typeof opts === 'function') return this._destroy(err, null, opts);
      if (this.destroyed) return;
      this.destroyed = true;

      this._debug('destroy');

      this.client._remove(this);

      clearInterval(this._rechokeIntervalId);

      this._xsRequests.forEach(req => {
        req.abort();
      });

      if (this._rarityMap) {
        this._rarityMap.destroy();
      }

      for (const id in this._peers) {
        this.removePeer(id);
      }

      this.files.forEach(file => {
        if (file instanceof File) file._destroy();
      });

      const tasks = this._servers.map(server => cb => {
        server.destroy(cb);
      });

      if (this.discovery) {
        tasks.push(cb => {
          this.discovery.destroy(cb);
        });
      }

      if (this.store) {
        let destroyStore = this._destroyStoreOnDestroy;

        if (opts && opts.destroyStore !== undefined) {
          destroyStore = opts.destroyStore;
        }

        tasks.push(cb => {
          if (destroyStore) {
            this.store.destroy(cb);
          } else {
            this.store.close(cb);
          }
        });
      }

      parallel(tasks, cb);

      if (err) {
        // Torrent errors are emitted at `torrent.on('error')`. If there are no 'error'
        // event handlers on the torrent instance, then the error will be emitted at
        // `client.on('error')`. This prevents throwing an uncaught exception
        // (unhandled 'error' event), but it makes it impossible to distinguish client
        // errors versus torrent errors. Torrent errors are not fatal, and the client
        // is still usable afterwards. Therefore, always listen for errors in both
        // places (`client.on('error')` and `torrent.on('error')`).
        if (this.listenerCount('error') === 0) {
          this.client.emit('error', err);
        } else {
          this.emit('error', err);
        }
      }

      this.emit('close');
      this.client = null;
      this.files = [];
      this.discovery = null;
      this.store = null;
      this._rarityMap = null;
      this._peers = null;
      this._servers = null;
      this._xsRequests = null;
    }
  }, {
    key: "addPeer",
    value: function addPeer(peer) {
      if (this.destroyed) throw new Error('torrent is destroyed');
      if (!this.infoHash) throw new Error('addPeer() must not be called before the `infoHash` event');
      let host;

      if (this.client.blocked) {
        if (typeof peer === 'string') {
          let parts;

          try {
            parts = addrToIPPort(peer);
          } catch (e) {
            this._debug('ignoring peer: invalid %s', peer);

            this.emit('invalidPeer', peer);
            return false;
          }

          host = parts[0];
        } else if (typeof peer.remoteAddress === 'string') {
          host = peer.remoteAddress;
        }

        if (host && this.client.blocked.contains(host)) {
          this._debug('ignoring peer: blocked %s', peer);

          if (typeof peer !== 'string') peer.destroy();
          this.emit('blockedPeer', peer);
          return false;
        }
      } // if the utp connection fails to connect, then it is replaced with a tcp connection to the same ip:port


      const type = this.client.utp && this._isIPv4(host) ? 'utp' : 'tcp';
      const wasAdded = !!this._addPeer(peer, type);

      if (wasAdded) {
        this.emit('peer', peer);
      } else {
        this.emit('invalidPeer', peer);
      }

      return wasAdded;
    }
  }, {
    key: "_addPeer",
    value: function _addPeer(peer, type) {
      if (this.destroyed) {
        if (typeof peer !== 'string') peer.destroy();
        return null;
      }

      if (typeof peer === 'string' && !this._validAddr(peer)) {
        this._debug('ignoring peer: invalid %s', peer);

        return null;
      }

      const id = peer && peer.id || peer;

      if (this._peers[id]) {
        this._debug('ignoring peer: duplicate (%s)', id);

        if (typeof peer !== 'string') peer.destroy();
        return null;
      }

      if (this.paused) {
        this._debug('ignoring peer: torrent is paused');

        if (typeof peer !== 'string') peer.destroy();
        return null;
      }

      this._debug('add peer %s', id);

      let newPeer;

      if (typeof peer === 'string') {
        // `peer` is an addr ("ip:port" string)
        newPeer = type === 'utp' ? Peer.createUTPOutgoingPeer(peer, this, this.client.throttleGroups) : Peer.createTCPOutgoingPeer(peer, this, this.client.throttleGroups);
      } else {
        // `peer` is a WebRTC connection (simple-peer)
        newPeer = Peer.createWebRTCPeer(peer, this, this.client.throttleGroups);
      }

      this._registerPeer(newPeer);

      if (typeof peer === 'string') {
        // `peer` is an addr ("ip:port" string)
        this._queue.push(newPeer);

        this._drain();
      }

      return newPeer;
    }
  }, {
    key: "addWebSeed",
    value: function addWebSeed(urlOrConn) {
      if (this.destroyed) throw new Error('torrent is destroyed');
      let id;
      let conn;

      if (typeof urlOrConn === 'string') {
        id = urlOrConn;

        if (!/^https?:\/\/.+/.test(id)) {
          this.emit('warning', new Error("ignoring invalid web seed: ".concat(id)));
          this.emit('invalidPeer', id);
          return;
        }

        if (this._peers[id]) {
          this.emit('warning', new Error("ignoring duplicate web seed: ".concat(id)));
          this.emit('invalidPeer', id);
          return;
        }

        conn = new WebConn(id, this);
      } else if (urlOrConn && typeof urlOrConn.connId === 'string') {
        conn = urlOrConn;
        id = conn.connId;

        if (this._peers[id]) {
          this.emit('warning', new Error("ignoring duplicate web seed: ".concat(id)));
          this.emit('invalidPeer', id);
          return;
        }
      } else {
        this.emit('warning', new Error('addWebSeed must be passed a string or connection object with id property'));
        return;
      }

      this._debug('add web seed %s', id);

      const newPeer = Peer.createWebSeedPeer(conn, id, this, this.client.throttleGroups);

      this._registerPeer(newPeer);

      this.emit('peer', id);
    }
    /**
     * Called whenever a new incoming TCP peer connects to this torrent swarm. Called with a
     * peer that has already sent a handshake.
     */

  }, {
    key: "_addIncomingPeer",
    value: function _addIncomingPeer(peer) {
      if (this.destroyed) return peer.destroy(new Error('torrent is destroyed'));
      if (this.paused) return peer.destroy(new Error('torrent is paused'));

      this._debug('add incoming peer %s', peer.id);

      this._registerPeer(peer);
    }
  }, {
    key: "_registerPeer",
    value: function _registerPeer(newPeer) {
      newPeer.on('download', downloaded => {
        if (this.destroyed) return;
        this.received += downloaded;

        this._downloadSpeed(downloaded);

        this.client._downloadSpeed(downloaded);

        this.emit('download', downloaded);
        if (this.destroyed) return;
        this.client.emit('download', downloaded);
      });
      newPeer.on('upload', uploaded => {
        if (this.destroyed) return;
        this.uploaded += uploaded;

        this._uploadSpeed(uploaded);

        this.client._uploadSpeed(uploaded);

        this.emit('upload', uploaded);
        if (this.destroyed) return;
        this.client.emit('upload', uploaded);
      });
      this._peers[newPeer.id] = newPeer;
      this._peersLength += 1;
    }
  }, {
    key: "removePeer",
    value: function removePeer(peer) {
      const id = peer && peer.id || peer;
      peer = this._peers[id];
      if (!peer) return;

      this._debug('removePeer %s', id);

      delete this._peers[id];
      this._peersLength -= 1;
      peer.destroy(); // If torrent swarm was at capacity before, try to open a new connection now

      this._drain();
    }
  }, {
    key: "select",
    value: function select(start, end, priority, notify) {
      if (this.destroyed) throw new Error('torrent is destroyed');

      if (start < 0 || end < start || this.pieces.length <= end) {
        throw new Error("invalid selection ".concat(start, " : ").concat(end));
      }

      priority = Number(priority) || 0;

      this._debug('select %s-%s (priority %s)', start, end, priority);

      this._selections.push({
        from: start,
        to: end,
        offset: 0,
        priority,
        notify: notify || noop
      });

      this._selections.sort((a, b) => b.priority - a.priority);

      this._updateSelections();
    }
  }, {
    key: "deselect",
    value: function deselect(start, end, priority) {
      if (this.destroyed) throw new Error('torrent is destroyed');
      priority = Number(priority) || 0;

      this._debug('deselect %s-%s (priority %s)', start, end, priority);

      for (let i = 0; i < this._selections.length; ++i) {
        const s = this._selections[i];

        if (s.from === start && s.to === end && s.priority === priority) {
          this._selections.splice(i, 1);

          break;
        }
      }

      this._updateSelections();
    }
  }, {
    key: "critical",
    value: function critical(start, end) {
      if (this.destroyed) throw new Error('torrent is destroyed');

      this._debug('critical %s-%s', start, end);

      for (let i = start; i <= end; ++i) {
        this._critical[i] = true;
      }

      this._updateSelections();
    }
  }, {
    key: "_onWire",
    value: function _onWire(wire, addr) {
      this._debug('got wire %s (%s)', wire._debugId, addr || 'Unknown');

      this.wires.push(wire);

      if (addr) {
        // Sometimes RTCPeerConnection.getStats() doesn't return an ip:port for peers
        const parts = addrToIPPort(addr);
        wire.remoteAddress = parts[0];
        wire.remotePort = parts[1];
      } // When peer sends PORT message, add that DHT node to routing table


      if (this.client.dht && this.client.dht.listening) {
        wire.on('port', port => {
          if (this.destroyed || this.client.dht.destroyed) {
            return;
          }

          if (!wire.remoteAddress) {
            return this._debug('ignoring PORT from peer with no address');
          }

          if (port === 0 || port > 65536) {
            return this._debug('ignoring invalid PORT from peer');
          }

          this._debug('port: %s (from %s)', port, addr);

          this.client.dht.addNode({
            host: wire.remoteAddress,
            port
          });
        });
      }

      wire.on('timeout', () => {
        this._debug('wire timeout (%s)', addr); // TODO: this might be destroying wires too eagerly


        wire.destroy();
      }); // Timeout for piece requests to this peer

      if (wire.type !== 'webSeed') {
        // webseeds always send 'unhave' on http timeout
        wire.setTimeout(PIECE_TIMEOUT, true);
      } // Send KEEP-ALIVE (every 60s) so peers will not disconnect the wire


      wire.setKeepAlive(true); // use ut_metadata extension

      wire.use(utMetadata(this.metadata));
      wire.ut_metadata.on('warning', err => {
        this._debug('ut_metadata warning: %s', err.message);
      });

      if (!this.metadata) {
        wire.ut_metadata.on('metadata', metadata => {
          this._debug('got metadata via ut_metadata');

          this._onMetadata(metadata);
        });
        wire.ut_metadata.fetch();
      } // use ut_pex extension if the torrent is not flagged as private


      if (typeof utPex === 'function' && !this.private) {
        wire.use(utPex());
        wire.ut_pex.on('peer', peer => {
          // Only add potential new peers when we're not seeding
          if (this.done) return;

          this._debug('ut_pex: got peer: %s (from %s)', peer, addr);

          this.addPeer(peer);
        });
        wire.ut_pex.on('dropped', peer => {
          // the remote peer believes a given peer has been dropped from the torrent swarm.
          // if we're not currently connected to it, then remove it from the queue.
          const peerObj = this._peers[peer];

          if (peerObj && !peerObj.connected) {
            this._debug('ut_pex: dropped peer: %s (from %s)', peer, addr);

            this.removePeer(peer);
          }
        });
        wire.once('close', () => {
          // Stop sending updates to remote peer
          wire.ut_pex.reset();
        });
      }

      wire.use(ltDontHave()); // Hook to allow user-defined `bittorrent-protocol` extensions
      // More info: https://github.com/webtorrent/bittorrent-protocol#extension-api

      this.emit('wire', wire, addr);

      if (this.ready) {
        queueMicrotask(() => {
          // This allows wire.handshake() to be called (by Peer.onHandshake) before any
          // messages get sent on the wire
          this._onWireWithMetadata(wire);
        });
      }
    }
  }, {
    key: "_onWireWithMetadata",
    value: function _onWireWithMetadata(wire) {
      let timeoutId = null;

      const onChokeTimeout = () => {
        if (this.destroyed || wire.destroyed) return;

        if (this._numQueued > 2 * (this._numConns - this.numPeers) && wire.amInterested) {
          wire.destroy();
        } else {
          timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT);
          if (timeoutId.unref) timeoutId.unref();
        }
      };

      let i;

      const updateSeedStatus = () => {
        if (wire.peerPieces.buffer.length !== this.bitfield.buffer.length) return;

        for (i = 0; i < this.pieces.length; ++i) {
          if (!wire.peerPieces.get(i)) return;
        }

        wire.isSeeder = true;
        wire.choke(); // always choke seeders
      };

      wire.on('bitfield', () => {
        updateSeedStatus();

        this._update();

        this._updateWireInterest(wire);
      });
      wire.on('have', () => {
        updateSeedStatus();

        this._update();

        this._updateWireInterest(wire);
      });
      wire.lt_donthave.on('donthave', () => {
        updateSeedStatus();

        this._update();

        this._updateWireInterest(wire);
      }); // fast extension (BEP6)

      wire.on('have-all', () => {
        wire.isSeeder = true;
        wire.choke(); // always choke seeders

        this._update();

        this._updateWireInterest(wire);
      }); // fast extension (BEP6)

      wire.on('have-none', () => {
        wire.isSeeder = false;

        this._update();

        this._updateWireInterest(wire);
      }); // fast extension (BEP6)

      wire.on('allowed-fast', index => {
        this._update();
      });
      wire.once('interested', () => {
        wire.unchoke();
      });
      wire.once('close', () => {
        clearTimeout(timeoutId);
      });
      wire.on('choke', () => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT);
        if (timeoutId.unref) timeoutId.unref();
      });
      wire.on('unchoke', () => {
        clearTimeout(timeoutId);

        this._update();
      });
      wire.on('request', (index, offset, length, cb) => {
        if (length > MAX_BLOCK_LENGTH) {
          // Per spec, disconnect from peers that request >128KB
          return wire.destroy();
        }

        if (this.pieces[index]) return;
        this.store.get(index, {
          offset,
          length
        }, cb);
      }); // always send bitfield or equivalent fast extension message (required)

      if (wire.hasFast && this._hasAllPieces()) wire.haveAll();else if (wire.hasFast && this._hasNoPieces()) wire.haveNone();else wire.bitfield(this.bitfield); // initialize interest in case bitfield message was already received before above handler was registered

      this._updateWireInterest(wire); // Send PORT message to peers that support DHT


      if (wire.peerExtensions.dht && this.client.dht && this.client.dht.listening) {
        wire.port(this.client.dht.address().port);
      }

      if (wire.type !== 'webSeed') {
        // do not choke on webseeds
        timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT);
        if (timeoutId.unref) timeoutId.unref();
      }

      wire.isSeeder = false;
      updateSeedStatus();
    }
    /**
     * Called on selection changes.
     */

  }, {
    key: "_updateSelections",
    value: function _updateSelections() {
      if (!this.ready || this.destroyed) return;
      queueMicrotask(() => {
        this._gcSelections();
      });

      this._updateInterest();

      this._update();
    }
    /**
     * Garbage collect selections with respect to the store's current state.
     */

  }, {
    key: "_gcSelections",
    value: function _gcSelections() {
      for (let i = 0; i < this._selections.length; ++i) {
        const s = this._selections[i];
        const oldOffset = s.offset; // check for newly downloaded pieces in selection

        while (this.bitfield.get(s.from + s.offset) && s.from + s.offset < s.to) {
          s.offset += 1;
        }

        if (oldOffset !== s.offset) s.notify();
        if (s.to !== s.from + s.offset) continue;
        if (!this.bitfield.get(s.from + s.offset)) continue;

        this._selections.splice(i, 1); // remove fully downloaded selection


        i -= 1; // decrement i to offset splice

        s.notify();

        this._updateInterest();
      }

      if (!this._selections.length) this.emit('idle');
    }
    /**
     * Update interested status for all peers.
     */

  }, {
    key: "_updateInterest",
    value: function _updateInterest() {
      const prev = this._amInterested;
      this._amInterested = !!this._selections.length;
      this.wires.forEach(wire => this._updateWireInterest(wire));
      if (prev === this._amInterested) return;
      if (this._amInterested) this.emit('interested');else this.emit('uninterested');
    }
  }, {
    key: "_updateWireInterest",
    value: function _updateWireInterest(wire) {
      let interested = false;

      for (let index = 0; index < this.pieces.length; ++index) {
        if (this.pieces[index] && wire.peerPieces.get(index)) {
          interested = true;
          break;
        }
      }

      if (interested) wire.interested();else wire.uninterested();
    }
    /**
     * Heartbeat to update all peers and their requests.
     */

  }, {
    key: "_update",
    value: function _update() {
      if (this.destroyed) return; // update wires in random order for better request distribution

      const ite = randomIterate(this.wires);
      let wire;

      while (wire = ite()) {
        this._updateWireWrapper(wire);
      }
    }
  }, {
    key: "_updateWireWrapper",
    value: function _updateWireWrapper(wire) {
      const self = this;

      if (typeof window !== 'undefined' && typeof window.requestIdleCallback === 'function') {
        window.requestIdleCallback(() => {
          self._updateWire(wire);
        }, {
          timeout: 250
        });
      } else {
        self._updateWire(wire);
      }
    }
    /**
     * Attempts to update a peer's requests
     */

  }, {
    key: "_updateWire",
    value: function _updateWire(wire) {
      // to allow function hoisting
      const self = this;
      const minOutstandingRequests = getBlockPipelineLength(wire, PIPELINE_MIN_DURATION);
      if (wire.requests.length >= minOutstandingRequests) return;
      const maxOutstandingRequests = getBlockPipelineLength(wire, PIPELINE_MAX_DURATION);

      if (wire.peerChoking) {
        if (wire.hasFast && wire.peerAllowedFastSet.length > 0 && !this._hasMorePieces(wire.peerAllowedFastSet.length - 1)) {
          requestAllowedFastSet();
        }

        return;
      }

      if (!wire.downloaded) return validateWire();
      trySelectWire(false) || trySelectWire(true);

      function requestAllowedFastSet() {
        if (wire.requests.length >= maxOutstandingRequests) return false;

        for (const piece of wire.peerAllowedFastSet) {
          if (wire.peerPieces.get(piece) && !self.bitfield.get(piece)) {
            while (self._request(wire, piece, false) && wire.requests.length < maxOutstandingRequests) {// body intentionally empty
              // request all non-reserved blocks in this piece
            }
          }

          if (wire.requests.length < maxOutstandingRequests) continue;
          return true;
        }

        return false;
      }

      function genPieceFilterFunc(start, end, tried, rank) {
        return i => i >= start && i <= end && !(i in tried) && wire.peerPieces.get(i) && (!rank || rank(i));
      } // TODO: Do we need both validateWire and trySelectWire?


      function validateWire() {
        if (wire.requests.length) return;
        let i = self._selections.length;

        while (i--) {
          const next = self._selections[i];
          let piece;

          if (self.strategy === 'rarest') {
            const start = next.from + next.offset;
            const end = next.to;
            const len = end - start + 1;
            const tried = {};
            let tries = 0;
            const filter = genPieceFilterFunc(start, end, tried);

            while (tries < len) {
              piece = self._rarityMap.getRarestPiece(filter);
              if (piece < 0) break;
              if (self._request(wire, piece, false)) return;
              tried[piece] = true;
              tries += 1;
            }
          } else {
            for (piece = next.to; piece >= next.from + next.offset; --piece) {
              if (!wire.peerPieces.get(piece)) continue;
              if (self._request(wire, piece, false)) return;
            }
          }
        } // TODO: wire failed to validate as useful; should we close it?
        // probably not, since 'have' and 'bitfield' messages might be coming

      }

      function speedRanker() {
        const speed = wire.downloadSpeed() || 1;
        if (speed > SPEED_THRESHOLD) return () => true;
        const secs = Math.max(1, wire.requests.length) * Piece.BLOCK_LENGTH / speed;
        let tries = 10;
        let ptr = 0;
        return index => {
          if (!tries || self.bitfield.get(index)) return true;
          let missing = self.pieces[index].missing;

          for (; ptr < self.wires.length; ptr++) {
            const otherWire = self.wires[ptr];
            const otherSpeed = otherWire.downloadSpeed();
            if (otherSpeed < SPEED_THRESHOLD) continue;
            if (otherSpeed <= speed) continue;
            if (!otherWire.peerPieces.get(index)) continue;
            if ((missing -= otherSpeed * secs) > 0) continue;
            tries--;
            return false;
          }

          return true;
        };
      }

      function shufflePriority(i) {
        let last = i;

        for (let j = i; j < self._selections.length && self._selections[j].priority; j++) {
          last = j;
        }

        const tmp = self._selections[i];
        self._selections[i] = self._selections[last];
        self._selections[last] = tmp;
      }

      function trySelectWire(hotswap) {
        if (wire.requests.length >= maxOutstandingRequests) return true;
        const rank = speedRanker();

        for (let i = 0; i < self._selections.length; i++) {
          const next = self._selections[i];
          let piece;

          if (self.strategy === 'rarest') {
            const start = next.from + next.offset;
            const end = next.to;
            const len = end - start + 1;
            const tried = {};
            let tries = 0;
            const filter = genPieceFilterFunc(start, end, tried, rank);

            while (tries < len) {
              piece = self._rarityMap.getRarestPiece(filter);
              if (piece < 0) break;

              while (self._request(wire, piece, self._critical[piece] || hotswap) && wire.requests.length < maxOutstandingRequests) {// body intentionally empty
                // request all non-reserved blocks in this piece
              }

              if (wire.requests.length < maxOutstandingRequests) {
                tried[piece] = true;
                tries++;
                continue;
              }

              if (next.priority) shufflePriority(i);
              return true;
            }
          } else {
            for (piece = next.from + next.offset; piece <= next.to; piece++) {
              if (!wire.peerPieces.get(piece) || !rank(piece)) continue;

              while (self._request(wire, piece, self._critical[piece] || hotswap) && wire.requests.length < maxOutstandingRequests) {// body intentionally empty
                // request all non-reserved blocks in piece
              }

              if (wire.requests.length < maxOutstandingRequests) continue;
              if (next.priority) shufflePriority(i);
              return true;
            }
          }
        }

        return false;
      }
    }
    /**
     * Called periodically to update the choked status of all peers, handling optimistic
     * unchoking as described in BEP3.
     */

  }, {
    key: "_rechoke",
    value: function _rechoke() {
      if (!this.ready) return; // wires in increasing order of quality (pop() gives next best peer)

      const wireStack = this.wires.map(wire => ({
        wire,
        random: Math.random()
      })) // insert a random seed for randomizing the sort
      .sort((objA, objB) => {
        const wireA = objA.wire;
        const wireB = objB.wire; // prefer peers that send us data faster

        if (wireA.downloadSpeed() !== wireB.downloadSpeed()) {
          return wireA.downloadSpeed() - wireB.downloadSpeed();
        } // then prefer peers that can download data from us faster


        if (wireA.uploadSpeed() !== wireB.uploadSpeed()) {
          return wireA.uploadSpeed() - wireB.uploadSpeed();
        } // then prefer already unchoked peers (to minimize fibrillation)


        if (wireA.amChoking !== wireB.amChoking) {
          return wireA.amChoking ? -1 : 1; // choking < unchoked
        } // otherwise random order


        return objA.random - objB.random;
      }).map(obj => obj.wire); // return array of wires (remove random seed)

      if (this._rechokeOptimisticTime <= 0) {
        // clear old optimistic peer, so it can be rechoked normally and then replaced
        this._rechokeOptimisticWire = null;
      } else {
        this._rechokeOptimisticTime -= 1;
      }

      let numInterestedUnchoked = 0; // leave one rechoke slot open for optimistic unchoking

      while (wireStack.length > 0 && numInterestedUnchoked < this._rechokeNumSlots - 1) {
        const wire = wireStack.pop(); // next best quality peer

        if (wire.isSeeder || wire === this._rechokeOptimisticWire) {
          continue;
        }

        wire.unchoke(); // only stop unchoking once we fill the slots with interested peers that will actually download

        if (wire.peerInterested) {
          numInterestedUnchoked++;
        }
      } // fill optimistic unchoke slot if empty


      if (this._rechokeOptimisticWire === null && this._rechokeNumSlots > 0) {
        // don't optimistically unchoke uninterested peers
        const remaining = wireStack.filter(wire => wire.peerInterested);

        if (remaining.length > 0) {
          // select random remaining (not yet unchoked) peer
          const newOptimisticPeer = remaining[randomInt(remaining.length)];
          newOptimisticPeer.unchoke();
          this._rechokeOptimisticWire = newOptimisticPeer;
          this._rechokeOptimisticTime = RECHOKE_OPTIMISTIC_DURATION;
        }
      } // choke the rest


      wireStack.filter(wire => wire !== this._rechokeOptimisticWire) // except the optimistically unchoked peer
      .forEach(wire => wire.choke());
    }
    /**
     * Attempts to cancel a slow block request from another wire such that the
     * given wire may effectively swap out the request for one of its own.
     */

  }, {
    key: "_hotswap",
    value: function _hotswap(wire, index) {
      const speed = wire.downloadSpeed();
      if (speed < Piece.BLOCK_LENGTH) return false;
      if (!this._reservations[index]) return false;
      const r = this._reservations[index];

      if (!r) {
        return false;
      }

      let minSpeed = Infinity;
      let minWire;
      let i;

      for (i = 0; i < r.length; i++) {
        const otherWire = r[i];
        if (!otherWire || otherWire === wire) continue;
        const otherSpeed = otherWire.downloadSpeed();
        if (otherSpeed >= SPEED_THRESHOLD) continue;
        if (2 * otherSpeed > speed || otherSpeed > minSpeed) continue;
        minWire = otherWire;
        minSpeed = otherSpeed;
      }

      if (!minWire) return false;

      for (i = 0; i < r.length; i++) {
        if (r[i] === minWire) r[i] = null;
      }

      for (i = 0; i < minWire.requests.length; i++) {
        const req = minWire.requests[i];
        if (req.piece !== index) continue;
        this.pieces[index].cancel(req.offset / Piece.BLOCK_LENGTH | 0);
      }

      this.emit('hotswap', minWire, wire, index);
      return true;
    }
    /**
     * Attempts to request a block from the given wire.
     */

  }, {
    key: "_request",
    value: function _request(wire, index, hotswap) {
      const self = this;
      const numRequests = wire.requests.length;
      const isWebSeed = wire.type === 'webSeed';
      if (self.bitfield.get(index)) return false;
      const maxOutstandingRequests = isWebSeed ? Math.min(getPiecePipelineLength(wire, PIPELINE_MAX_DURATION, self.pieceLength), self.maxWebConns) : getBlockPipelineLength(wire, PIPELINE_MAX_DURATION);
      if (numRequests >= maxOutstandingRequests) return false; // var endGame = (wire.requests.length === 0 && self.store.numMissing < 30)

      const piece = self.pieces[index];
      let reservation = isWebSeed ? piece.reserveRemaining() : piece.reserve();

      if (reservation === -1 && hotswap && self._hotswap(wire, index)) {
        reservation = isWebSeed ? piece.reserveRemaining() : piece.reserve();
      }

      if (reservation === -1) return false;
      let r = self._reservations[index];
      if (!r) r = self._reservations[index] = [];
      let i = r.indexOf(null);
      if (i === -1) i = r.length;
      r[i] = wire;
      const chunkOffset = piece.chunkOffset(reservation);
      const chunkLength = isWebSeed ? piece.chunkLengthRemaining(reservation) : piece.chunkLength(reservation);
      wire.request(index, chunkOffset, chunkLength, function onChunk(err, chunk) {
        if (self.destroyed) return; // TODO: what is this for?

        if (!self.ready) return self.once('ready', () => {
          onChunk(err, chunk);
        });
        if (r[i] === wire) r[i] = null;
        if (piece !== self.pieces[index]) return onUpdateTick();

        if (err) {
          self._debug('error getting piece %s (offset: %s length: %s) from %s: %s', index, chunkOffset, chunkLength, "".concat(wire.remoteAddress, ":").concat(wire.remotePort), err.message);

          isWebSeed ? piece.cancelRemaining(reservation) : piece.cancel(reservation);
          onUpdateTick();
          return;
        }

        self._debug('got piece %s (offset: %s length: %s) from %s', index, chunkOffset, chunkLength, "".concat(wire.remoteAddress, ":").concat(wire.remotePort));

        if (!piece.set(reservation, chunk, wire)) return onUpdateTick();
        const buf = piece.flush(); // TODO: might need to set self.pieces[index] = null here since sha1 is async

        sha1(buf, hash => {
          if (self.destroyed) return;

          if (hash === self._hashes[index]) {
            self._debug('piece verified %s', index);

            self.store.put(index, buf, err => {
              if (err) {
                self._destroy(err);

                return;
              } else {
                self.pieces[index] = null;

                self._markVerified(index);

                self.wires.forEach(wire => {
                  wire.have(index);
                });
              } // We also check `self.destroyed` since `torrent.destroy()` could have been
              // called in the `torrent.on('done')` handler, triggered by `_checkDone()`.


              if (self._checkDone() && !self.destroyed) self.discovery.complete();
              onUpdateTick();
            });
          } else {
            self.pieces[index] = new Piece(piece.length);
            self.emit('warning', new Error("Piece ".concat(index, " failed verification")));
            onUpdateTick();
          }
        });
      });

      function onUpdateTick() {
        queueMicrotask(() => {
          self._update();
        });
      }

      return true;
    }
  }, {
    key: "_checkDone",
    value: function _checkDone() {
      if (this.destroyed) return; // are any new files done?

      this.files.forEach(file => {
        if (file.done) return;

        for (let i = file._startPiece; i <= file._endPiece; ++i) {
          if (!this.bitfield.get(i)) return;
        }

        file.done = true;
        file.emit('done');

        this._debug("file done: ".concat(file.name));
      }); // is the torrent done? (if all current selections are satisfied, or there are
      // no selections, then torrent is done)

      let done = true;

      for (const selection of this._selections) {
        for (let piece = selection.from; piece <= selection.to; piece++) {
          if (!this.bitfield.get(piece)) {
            done = false;
            break;
          }
        }

        if (!done) break;
      }

      if (!this.done && done) {
        this.done = true;

        this._debug("torrent done: ".concat(this.infoHash));

        this.emit('done');
      } else {
        this.done = false;
      }

      this._gcSelections();

      return done;
    }
  }, {
    key: "load",
    value: function load(streams, cb) {
      if (this.destroyed) throw new Error('torrent is destroyed');
      if (!this.ready) return this.once('ready', () => {
        this.load(streams, cb);
      });
      if (!Array.isArray(streams)) streams = [streams];
      if (!cb) cb = noop;
      const readable = new MultiStream(streams);
      const writable = new ChunkStoreWriteStream(this.store, this.pieceLength);
      pump(readable, writable, err => {
        if (err) return cb(err);

        this._markAllVerified();

        this._checkDone();

        cb(null);
      });
    }
  }, {
    key: "createServer",
    value: function createServer(requestListener) {
      if (typeof Server !== 'function') throw new Error('node.js-only method');
      if (this.destroyed) throw new Error('torrent is destroyed');
      const server = new Server(this, requestListener);

      this._servers.push(server);

      return server;
    }
  }, {
    key: "pause",
    value: function pause() {
      if (this.destroyed) return;

      this._debug('pause');

      this.paused = true;
    }
  }, {
    key: "resume",
    value: function resume() {
      if (this.destroyed) return;

      this._debug('resume');

      this.paused = false;

      this._drain();
    }
  }, {
    key: "_debug",
    value: function _debug() {
      const args = [].slice.call(arguments);
      args[0] = "[".concat(this.client ? this.client._debugId : 'No Client', "] [").concat(this._debugId, "] ").concat(args[0]);
      debug.apply(void 0, _toConsumableArray(args));
    }
    /**
     * Pop a peer off the FIFO queue and connect to it. When _drain() gets called,
     * the queue will usually have only one peer in it, except when there are too
     * many peers (over `this.maxConns`) in which case they will just sit in the
     * queue until another connection closes.
     */

  }, {
    key: "_drain",
    value: function _drain() {
      this._debug('_drain numConns %s maxConns %s', this._numConns, this.client.maxConns);

      if (typeof net.connect !== 'function' || this.destroyed || this.paused || this._numConns >= this.client.maxConns) {
        return;
      }

      this._debug('drain (%s queued, %s/%s peers)', this._numQueued, this.numPeers, this.client.maxConns);

      const peer = this._queue.shift();

      if (!peer) return; // queue could be empty

      this._debug('%s connect attempt to %s', peer.type, peer.addr);

      const parts = addrToIPPort(peer.addr);
      const opts = {
        host: parts[0],
        port: parts[1]
      };

      if (this.client.utp && peer.type === 'utpOutgoing') {
        peer.conn = utp.connect(opts.port, opts.host);
      } else {
        peer.conn = net.connect(opts);
      }

      const conn = peer.conn;
      conn.once('connect', () => {
        peer.onConnect();
      });
      conn.once('error', err => {
        peer.destroy(err);
      });
      peer.startConnectTimeout(); // When connection closes, attempt reconnect after timeout (with exponential backoff)

      conn.on('close', () => {
        if (this.destroyed) return;

        if (peer.retries >= RECONNECT_WAIT.length) {
          if (this.client.utp) {
            const newPeer = this._addPeer(peer.addr, 'tcp');

            if (newPeer) newPeer.retries = 0;
          } else {
            this._debug('conn %s closed: will not re-add (max %s attempts)', peer.addr, RECONNECT_WAIT.length);
          }

          return;
        }

        const ms = RECONNECT_WAIT[peer.retries];

        this._debug('conn %s closed: will re-add to queue in %sms (attempt %s)', peer.addr, ms, peer.retries + 1);

        const reconnectTimeout = setTimeout(() => {
          if (this.destroyed) return;
          const host = addrToIPPort(peer.addr)[0];
          const type = this.client.utp && this._isIPv4(host) ? 'utp' : 'tcp';

          const newPeer = this._addPeer(peer.addr, type);

          if (newPeer) newPeer.retries = peer.retries + 1;
        }, ms);
        if (reconnectTimeout.unref) reconnectTimeout.unref();
      });
    }
    /**
     * Returns `true` if string is valid IPv4/6 address.
     * @param {string} addr
     * @return {boolean}
     */

  }, {
    key: "_validAddr",
    value: function _validAddr(addr) {
      let parts;

      try {
        parts = addrToIPPort(addr);
      } catch (e) {
        return false;
      }

      const host = parts[0];
      const port = parts[1];
      return port > 0 && port < 65535 && !(host === '127.0.0.1' && port === this.client.torrentPort);
    }
    /**
     * Return `true` if string is a valid IPv4 address.
     * @param {string} addr
     * @return {boolean}
     */

  }, {
    key: "_isIPv4",
    value: function _isIPv4(addr) {
      const IPv4Pattern = /^((?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$/;
      return IPv4Pattern.test(addr);
    }
  }]);

  return Torrent;
}(EventEmitter);

function getBlockPipelineLength(wire, duration) {
  let length = 2 + Math.ceil(duration * wire.downloadSpeed() / Piece.BLOCK_LENGTH); // Honor reqq (maximum number of outstanding request messages) if specified by peer

  if (wire.peerExtendedHandshake) {
    const reqq = wire.peerExtendedHandshake.reqq;

    if (typeof reqq === 'number' && reqq > 0) {
      length = Math.min(length, reqq);
    }
  }

  return length;
}

function getPiecePipelineLength(wire, duration, pieceLength) {
  return 1 + Math.ceil(duration * wire.downloadSpeed() / pieceLength);
}
/**
 * Returns a random integer in [0,high)
 */


function randomInt(high) {
  return Math.random() * high | 0;
}

function noop() {}

module.exports = Torrent;

/***/ }),

/***/ "./node_modules/webtorrent/lib/webconn.js":
/*!************************************************!*\
  !*** ./node_modules/webtorrent/lib/webconn.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

const {
  default: BitField
} = __webpack_require__(/*! bitfield */ "./node_modules/bitfield/lib/index.js");

const debugFactory = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");

const get = __webpack_require__(/*! simple-get */ "./node_modules/simple-get/index.js");

const ltDontHave = __webpack_require__(/*! lt_donthave */ "./node_modules/lt_donthave/index.js");

const sha1 = __webpack_require__(/*! simple-sha1 */ "./node_modules/simple-sha1/browser.js");

const Wire = __webpack_require__(/*! bittorrent-protocol */ "./node_modules/bittorrent-protocol/index.js");

const debug = debugFactory('webtorrent:webconn');

const VERSION = (__webpack_require__(/*! ../package.json */ "./node_modules/webtorrent/package.json").version);

const SOCKET_TIMEOUT = 60000;
const RETRY_DELAY = 10000;
/**
 * Converts requests for torrent blocks into http range requests.
 * @param {string} url web seed url
 * @param {Object} torrent
 */

let WebConn = /*#__PURE__*/function (_Wire) {
  _inherits(WebConn, _Wire);

  var _super = _createSuper(WebConn);

  function WebConn(url, torrent) {
    var _this;

    _classCallCheck(this, WebConn);

    _this = _super.call(this);
    _this.url = url;
    _this.connId = url; // Unique id to deduplicate web seeds

    _this.webPeerId = sha1.sync(url); // Used as the peerId for this fake remote peer

    _this._torrent = torrent;

    _this._init();

    return _this;
  }

  _createClass(WebConn, [{
    key: "_init",
    value: function _init() {
      this.setKeepAlive(true);
      this.use(ltDontHave());
      this.once('handshake', (infoHash, peerId) => {
        if (this.destroyed) return;
        this.handshake(infoHash, this.webPeerId);
        const numPieces = this._torrent.pieces.length;
        const bitfield = new BitField(numPieces);

        for (let i = 0; i <= numPieces; i++) {
          bitfield.set(i, true);
        }

        this.bitfield(bitfield);
      });
      this.once('interested', () => {
        debug('interested');
        this.unchoke();
      });
      this.on('uninterested', () => {
        debug('uninterested');
      });
      this.on('choke', () => {
        debug('choke');
      });
      this.on('unchoke', () => {
        debug('unchoke');
      });
      this.on('bitfield', () => {
        debug('bitfield');
      });
      this.lt_donthave.on('donthave', () => {
        debug('donthave');
      });
      this.on('request', (pieceIndex, offset, length, callback) => {
        debug('request pieceIndex=%d offset=%d length=%d', pieceIndex, offset, length);
        this.httpRequest(pieceIndex, offset, length, (err, data) => {
          if (err) {
            // Cancel all in progress requests for this piece
            this.lt_donthave.donthave(pieceIndex); // Wait a little while before saying the webseed has the failed piece again

            const retryTimeout = setTimeout(() => {
              if (this.destroyed) return;
              this.have(pieceIndex);
            }, RETRY_DELAY);
            if (retryTimeout.unref) retryTimeout.unref();
          }

          callback(err, data);
        });
      });
    }
  }, {
    key: "httpRequest",
    value: function httpRequest(pieceIndex, offset, length, cb) {
      const pieceOffset = pieceIndex * this._torrent.pieceLength;
      const rangeStart = pieceOffset + offset;
      /* offset within whole torrent */

      const rangeEnd = rangeStart + length - 1; // Web seed URL format:
      // For single-file torrents, make HTTP range requests directly to the web seed URL
      // For multi-file torrents, add the torrent folder and file name to the URL

      const files = this._torrent.files;
      let requests;

      if (files.length <= 1) {
        requests = [{
          url: this.url,
          start: rangeStart,
          end: rangeEnd
        }];
      } else {
        const requestedFiles = files.filter(file => file.offset <= rangeEnd && file.offset + file.length > rangeStart);

        if (requestedFiles.length < 1) {
          return cb(new Error('Could not find file corresponding to web seed range request'));
        }

        requests = requestedFiles.map(requestedFile => {
          const fileEnd = requestedFile.offset + requestedFile.length - 1;
          const url = this.url + (this.url[this.url.length - 1] === '/' ? '' : '/') + requestedFile.path.replace(this._torrent.path, '');
          return {
            url,
            fileOffsetInRange: Math.max(requestedFile.offset - rangeStart, 0),
            start: Math.max(rangeStart - requestedFile.offset, 0),
            end: Math.min(fileEnd, rangeEnd - requestedFile.offset)
          };
        });
      } // Now make all the HTTP requests we need in order to load this piece
      // Usually that's one requests, but sometimes it will be multiple
      // Send requests in parallel and wait for them all to come back


      let numRequestsSucceeded = 0;
      let hasError = false;
      let ret;

      if (requests.length > 1) {
        ret = Buffer.alloc(length);
      }

      requests.forEach(request => {
        const url = request.url;
        const start = request.start;
        const end = request.end;
        debug('Requesting url=%s pieceIndex=%d offset=%d length=%d start=%d end=%d', url, pieceIndex, offset, length, start, end);
        const opts = {
          url,
          method: 'GET',
          headers: {
            'user-agent': "WebTorrent/".concat(VERSION, " (https://webtorrent.io)"),
            range: "bytes=".concat(start, "-").concat(end)
          },
          timeout: SOCKET_TIMEOUT
        };

        function onResponse(res, data) {
          if (res.statusCode < 200 || res.statusCode >= 300) {
            if (hasError) return;
            hasError = true;
            return cb(new Error("Unexpected HTTP status code ".concat(res.statusCode)));
          }

          debug('Got data of length %d', data.length);

          if (requests.length === 1) {
            // Common case: fetch piece in a single HTTP request, return directly
            cb(null, data);
          } else {
            // Rare case: reconstruct multiple HTTP requests across 2+ files into one
            // piece buffer
            data.copy(ret, request.fileOffsetInRange);

            if (++numRequestsSucceeded === requests.length) {
              cb(null, ret);
            }
          }
        }

        get.concat(opts, (err, res, data) => {
          if (hasError) return;

          if (err) {
            // Browsers allow HTTP redirects for simple cross-origin
            // requests but not for requests that require preflight.
            // Use a simple request to unravel any redirects and get the
            // final URL.  Retry the original request with the new URL if
            // it's different.
            //
            // This test is imperfect but it's simple and good for common
            // cases.  It catches all cross-origin cases but matches a few
            // same-origin cases too.
            if (typeof window === 'undefined' || url.startsWith("".concat(window.location.origin, "/"))) {
              hasError = true;
              return cb(err);
            }

            return get.head(url, (errHead, res) => {
              if (hasError) return;

              if (errHead) {
                hasError = true;
                return cb(errHead);
              }

              if (res.statusCode < 200 || res.statusCode >= 300) {
                hasError = true;
                return cb(new Error("Unexpected HTTP status code ".concat(res.statusCode)));
              }

              if (res.url === url) {
                hasError = true;
                return cb(err);
              }

              opts.url = res.url;
              get.concat(opts, (err, res, data) => {
                if (hasError) return;

                if (err) {
                  hasError = true;
                  return cb(err);
                }

                onResponse(res, data);
              });
            });
          }

          onResponse(res, data);
        });
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      _get(_getPrototypeOf(WebConn.prototype), "destroy", this).call(this);

      this._torrent = null;
    }
  }]);

  return WebConn;
}(Wire);

module.exports = WebConn;

/***/ }),

/***/ "./node_modules/xtend/immutable.js":
/*!*****************************************!*\
  !*** ./node_modules/xtend/immutable.js ***!
  \*****************************************/
/***/ ((module) => {

module.exports = extend;
var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
  var target = {};

  for (var i = 0; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
}

/***/ }),

/***/ "./node_modules/dexie/dist/modern/dexie.mjs":
/*!**************************************************!*\
  !*** ./node_modules/dexie/dist/modern/dexie.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dexie": () => (/* binding */ Dexie$1),
/* harmony export */   "RangeSet": () => (/* binding */ RangeSet),
/* harmony export */   "default": () => (/* binding */ Dexie$1),
/* harmony export */   "liveQuery": () => (/* binding */ liveQuery),
/* harmony export */   "mergeRanges": () => (/* binding */ mergeRanges),
/* harmony export */   "rangesOverlap": () => (/* binding */ rangesOverlap)
/* harmony export */ });
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/*
 * Dexie.js - a minimalistic wrapper for IndexedDB
 * ===============================================
 *
 * By David Fahlander, david.fahlander@gmail.com
 *
 * Version 3.2.2, Wed Apr 27 2022
 *
 * https://dexie.org
 *
 * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/
 */
const _global = typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : global;

const keys = Object.keys;
const isArray = Array.isArray;

if (typeof Promise !== 'undefined' && !_global.Promise) {
  _global.Promise = Promise;
}

function extend(obj, extension) {
  if (typeof extension !== 'object') return obj;
  keys(extension).forEach(function (key) {
    obj[key] = extension[key];
  });
  return obj;
}

const getProto = Object.getPrototypeOf;
const _hasOwn = {}.hasOwnProperty;

function hasOwn(obj, prop) {
  return _hasOwn.call(obj, prop);
}

function props(proto, extension) {
  if (typeof extension === 'function') extension = extension(getProto(proto));
  (typeof Reflect === "undefined" ? keys : Reflect.ownKeys)(extension).forEach(key => {
    setProp(proto, key, extension[key]);
  });
}

const defineProperty = Object.defineProperty;

function setProp(obj, prop, functionOrGetSet, options) {
  defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === 'function' ? {
    get: functionOrGetSet.get,
    set: functionOrGetSet.set,
    configurable: true
  } : {
    value: functionOrGetSet,
    configurable: true,
    writable: true
  }, options));
}

function derive(Child) {
  return {
    from: function (Parent) {
      Child.prototype = Object.create(Parent.prototype);
      setProp(Child.prototype, "constructor", Child);
      return {
        extend: props.bind(null, Child.prototype)
      };
    }
  };
}

const getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

function getPropertyDescriptor(obj, prop) {
  const pd = getOwnPropertyDescriptor(obj, prop);
  let proto;
  return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
}

const _slice = [].slice;

function slice(args, start, end) {
  return _slice.call(args, start, end);
}

function override(origFunc, overridedFactory) {
  return overridedFactory(origFunc);
}

function assert(b) {
  if (!b) throw new Error("Assertion Failed");
}

function asap$1(fn) {
  if (_global.setImmediate) setImmediate(fn);else setTimeout(fn, 0);
}

function arrayToObject(array, extractor) {
  return array.reduce((result, item, i) => {
    var nameAndValue = extractor(item, i);
    if (nameAndValue) result[nameAndValue[0]] = nameAndValue[1];
    return result;
  }, {});
}

function tryCatch(fn, onerror, args) {
  try {
    fn.apply(null, args);
  } catch (ex) {
    onerror && onerror(ex);
  }
}

function getByKeyPath(obj, keyPath) {
  if (hasOwn(obj, keyPath)) return obj[keyPath];
  if (!keyPath) return obj;

  if (typeof keyPath !== 'string') {
    var rv = [];

    for (var i = 0, l = keyPath.length; i < l; ++i) {
      var val = getByKeyPath(obj, keyPath[i]);
      rv.push(val);
    }

    return rv;
  }

  var period = keyPath.indexOf('.');

  if (period !== -1) {
    var innerObj = obj[keyPath.substr(0, period)];
    return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));
  }

  return undefined;
}

function setByKeyPath(obj, keyPath, value) {
  if (!obj || keyPath === undefined) return;
  if ('isFrozen' in Object && Object.isFrozen(obj)) return;

  if (typeof keyPath !== 'string' && 'length' in keyPath) {
    assert(typeof value !== 'string' && 'length' in value);

    for (var i = 0, l = keyPath.length; i < l; ++i) {
      setByKeyPath(obj, keyPath[i], value[i]);
    }
  } else {
    var period = keyPath.indexOf('.');

    if (period !== -1) {
      var currentKeyPath = keyPath.substr(0, period);
      var remainingKeyPath = keyPath.substr(period + 1);
      if (remainingKeyPath === "") {
        if (value === undefined) {
          if (isArray(obj) && !isNaN(parseInt(currentKeyPath))) obj.splice(currentKeyPath, 1);else delete obj[currentKeyPath];
        } else obj[currentKeyPath] = value;
      } else {
        var innerObj = obj[currentKeyPath];
        if (!innerObj || !hasOwn(obj, currentKeyPath)) innerObj = obj[currentKeyPath] = {};
        setByKeyPath(innerObj, remainingKeyPath, value);
      }
    } else {
      if (value === undefined) {
        if (isArray(obj) && !isNaN(parseInt(keyPath))) obj.splice(keyPath, 1);else delete obj[keyPath];
      } else obj[keyPath] = value;
    }
  }
}

function delByKeyPath(obj, keyPath) {
  if (typeof keyPath === 'string') setByKeyPath(obj, keyPath, undefined);else if ('length' in keyPath) [].map.call(keyPath, function (kp) {
    setByKeyPath(obj, kp, undefined);
  });
}

function shallowClone(obj) {
  var rv = {};

  for (var m in obj) {
    if (hasOwn(obj, m)) rv[m] = obj[m];
  }

  return rv;
}

const concat = [].concat;

function flatten(a) {
  return concat.apply([], a);
}

const intrinsicTypeNames = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(',').concat(flatten([8, 16, 32, 64].map(num => ["Int", "Uint", "Float"].map(t => t + num + "Array")))).filter(t => _global[t]);
const intrinsicTypes = intrinsicTypeNames.map(t => _global[t]);
arrayToObject(intrinsicTypeNames, x => [x, true]);
let circularRefs = null;

function deepClone(any) {
  circularRefs = typeof WeakMap !== 'undefined' && new WeakMap();
  const rv = innerDeepClone(any);
  circularRefs = null;
  return rv;
}

function innerDeepClone(any) {
  if (!any || typeof any !== 'object') return any;
  let rv = circularRefs && circularRefs.get(any);
  if (rv) return rv;

  if (isArray(any)) {
    rv = [];
    circularRefs && circularRefs.set(any, rv);

    for (var i = 0, l = any.length; i < l; ++i) {
      rv.push(innerDeepClone(any[i]));
    }
  } else if (intrinsicTypes.indexOf(any.constructor) >= 0) {
    rv = any;
  } else {
    const proto = getProto(any);
    rv = proto === Object.prototype ? {} : Object.create(proto);
    circularRefs && circularRefs.set(any, rv);

    for (var prop in any) {
      if (hasOwn(any, prop)) {
        rv[prop] = innerDeepClone(any[prop]);
      }
    }
  }

  return rv;
}

const {
  toString
} = {};

function toStringTag(o) {
  return toString.call(o).slice(8, -1);
}

const iteratorSymbol = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
const getIteratorOf = typeof iteratorSymbol === "symbol" ? function (x) {
  var i;
  return x != null && (i = x[iteratorSymbol]) && i.apply(x);
} : function () {
  return null;
};
const NO_CHAR_ARRAY = {};

function getArrayOf(arrayLike) {
  var i, a, x, it;

  if (arguments.length === 1) {
    if (isArray(arrayLike)) return arrayLike.slice();
    if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string') return [arrayLike];

    if (it = getIteratorOf(arrayLike)) {
      a = [];

      while (x = it.next(), !x.done) a.push(x.value);

      return a;
    }

    if (arrayLike == null) return [arrayLike];
    i = arrayLike.length;

    if (typeof i === 'number') {
      a = new Array(i);

      while (i--) a[i] = arrayLike[i];

      return a;
    }

    return [arrayLike];
  }

  i = arguments.length;
  a = new Array(i);

  while (i--) a[i] = arguments[i];

  return a;
}

const isAsyncFunction = typeof Symbol !== 'undefined' ? fn => fn[Symbol.toStringTag] === 'AsyncFunction' : () => false;
var debug = typeof location !== 'undefined' && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);

function setDebug(value, filter) {
  debug = value;
  libraryFilter = filter;
}

var libraryFilter = () => true;

const NEEDS_THROW_FOR_STACK = !new Error("").stack;

function getErrorWithStack() {
  if (NEEDS_THROW_FOR_STACK) try {
    getErrorWithStack.arguments;
    throw new Error();
  } catch (e) {
    return e;
  }
  return new Error();
}

function prettyStack(exception, numIgnoredFrames) {
  var stack = exception.stack;
  if (!stack) return "";
  numIgnoredFrames = numIgnoredFrames || 0;
  if (stack.indexOf(exception.name) === 0) numIgnoredFrames += (exception.name + exception.message).split('\n').length;
  return stack.split('\n').slice(numIgnoredFrames).filter(libraryFilter).map(frame => "\n" + frame).join('');
}

var dexieErrorNames = ['Modify', 'Bulk', 'OpenFailed', 'VersionChange', 'Schema', 'Upgrade', 'InvalidTable', 'MissingAPI', 'NoSuchDatabase', 'InvalidArgument', 'SubTransaction', 'Unsupported', 'Internal', 'DatabaseClosed', 'PrematureCommit', 'ForeignAwait'];
var idbDomErrorNames = ['Unknown', 'Constraint', 'Data', 'TransactionInactive', 'ReadOnly', 'Version', 'NotFound', 'InvalidState', 'InvalidAccess', 'Abort', 'Timeout', 'QuotaExceeded', 'Syntax', 'DataClone'];
var errorList = dexieErrorNames.concat(idbDomErrorNames);
var defaultTexts = {
  VersionChanged: "Database version changed by other database connection",
  DatabaseClosed: "Database has been closed",
  Abort: "Transaction aborted",
  TransactionInactive: "Transaction has already completed or failed",
  MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
};

function DexieError(name, msg) {
  this._e = getErrorWithStack();
  this.name = name;
  this.message = msg;
}

derive(DexieError).from(Error).extend({
  stack: {
    get: function () {
      return this._stack || (this._stack = this.name + ": " + this.message + prettyStack(this._e, 2));
    }
  },
  toString: function () {
    return this.name + ": " + this.message;
  }
});

function getMultiErrorMessage(msg, failures) {
  return msg + ". Errors: " + Object.keys(failures).map(key => failures[key].toString()).filter((v, i, s) => s.indexOf(v) === i).join('\n');
}

function ModifyError(msg, failures, successCount, failedKeys) {
  this._e = getErrorWithStack();
  this.failures = failures;
  this.failedKeys = failedKeys;
  this.successCount = successCount;
  this.message = getMultiErrorMessage(msg, failures);
}

derive(ModifyError).from(DexieError);

function BulkError(msg, failures) {
  this._e = getErrorWithStack();
  this.name = "BulkError";
  this.failures = Object.keys(failures).map(pos => failures[pos]);
  this.failuresByPos = failures;
  this.message = getMultiErrorMessage(msg, failures);
}

derive(BulkError).from(DexieError);
var errnames = errorList.reduce((obj, name) => (obj[name] = name + "Error", obj), {});
const BaseException = DexieError;
var exceptions = errorList.reduce((obj, name) => {
  var fullName = name + "Error";

  function DexieError(msgOrInner, inner) {
    this._e = getErrorWithStack();
    this.name = fullName;

    if (!msgOrInner) {
      this.message = defaultTexts[name] || fullName;
      this.inner = null;
    } else if (typeof msgOrInner === 'string') {
      this.message = "".concat(msgOrInner).concat(!inner ? '' : '\n ' + inner);
      this.inner = inner || null;
    } else if (typeof msgOrInner === 'object') {
      this.message = "".concat(msgOrInner.name, " ").concat(msgOrInner.message);
      this.inner = msgOrInner;
    }
  }

  derive(DexieError).from(BaseException);
  obj[name] = DexieError;
  return obj;
}, {});
exceptions.Syntax = SyntaxError;
exceptions.Type = TypeError;
exceptions.Range = RangeError;
var exceptionMap = idbDomErrorNames.reduce((obj, name) => {
  obj[name + "Error"] = exceptions[name];
  return obj;
}, {});

function mapError(domError, message) {
  if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name]) return domError;
  var rv = new exceptionMap[domError.name](message || domError.message, domError);

  if ("stack" in domError) {
    setProp(rv, "stack", {
      get: function () {
        return this.inner.stack;
      }
    });
  }

  return rv;
}

var fullNameExceptions = errorList.reduce((obj, name) => {
  if (["Syntax", "Type", "Range"].indexOf(name) === -1) obj[name + "Error"] = exceptions[name];
  return obj;
}, {});
fullNameExceptions.ModifyError = ModifyError;
fullNameExceptions.DexieError = DexieError;
fullNameExceptions.BulkError = BulkError;

function nop() {}

function mirror(val) {
  return val;
}

function pureFunctionChain(f1, f2) {
  if (f1 == null || f1 === mirror) return f2;
  return function (val) {
    return f2(f1(val));
  };
}

function callBoth(on1, on2) {
  return function () {
    on1.apply(this, arguments);
    on2.apply(this, arguments);
  };
}

function hookCreatingChain(f1, f2) {
  if (f1 === nop) return f2;
  return function () {
    var res = f1.apply(this, arguments);
    if (res !== undefined) arguments[0] = res;
    var onsuccess = this.onsuccess,
        onerror = this.onerror;
    this.onsuccess = null;
    this.onerror = null;
    var res2 = f2.apply(this, arguments);
    if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
    if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
    return res2 !== undefined ? res2 : res;
  };
}

function hookDeletingChain(f1, f2) {
  if (f1 === nop) return f2;
  return function () {
    f1.apply(this, arguments);
    var onsuccess = this.onsuccess,
        onerror = this.onerror;
    this.onsuccess = this.onerror = null;
    f2.apply(this, arguments);
    if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
    if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
  };
}

function hookUpdatingChain(f1, f2) {
  if (f1 === nop) return f2;
  return function (modifications) {
    var res = f1.apply(this, arguments);
    extend(modifications, res);
    var onsuccess = this.onsuccess,
        onerror = this.onerror;
    this.onsuccess = null;
    this.onerror = null;
    var res2 = f2.apply(this, arguments);
    if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
    if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
    return res === undefined ? res2 === undefined ? undefined : res2 : extend(res, res2);
  };
}

function reverseStoppableEventChain(f1, f2) {
  if (f1 === nop) return f2;
  return function () {
    if (f2.apply(this, arguments) === false) return false;
    return f1.apply(this, arguments);
  };
}

function promisableChain(f1, f2) {
  if (f1 === nop) return f2;
  return function () {
    var res = f1.apply(this, arguments);

    if (res && typeof res.then === 'function') {
      var thiz = this,
          i = arguments.length,
          args = new Array(i);

      while (i--) args[i] = arguments[i];

      return res.then(function () {
        return f2.apply(thiz, args);
      });
    }

    return f2.apply(this, arguments);
  };
}

var INTERNAL = {};
const LONG_STACKS_CLIP_LIMIT = 100,
      MAX_LONG_STACKS = 20,
      ZONE_ECHO_LIMIT = 100,
      [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === 'undefined' ? [] : (() => {
  let globalP = Promise.resolve();
  if (typeof crypto === 'undefined' || !crypto.subtle) return [globalP, getProto(globalP), globalP];
  const nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
  return [nativeP, getProto(nativeP), globalP];
})(),
      nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
const NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
const patchGlobalPromise = !!resolvedGlobalPromise;
var stack_being_generated = false;
var schedulePhysicalTick = resolvedGlobalPromise ? () => {
  resolvedGlobalPromise.then(physicalTick);
} : _global.setImmediate ? setImmediate.bind(null, physicalTick) : _global.MutationObserver ? () => {
  var hiddenDiv = document.createElement("div");
  new MutationObserver(() => {
    physicalTick();
    hiddenDiv = null;
  }).observe(hiddenDiv, {
    attributes: true
  });
  hiddenDiv.setAttribute('i', '1');
} : () => {
  setTimeout(physicalTick, 0);
};

var asap = function (callback, args) {
  microtickQueue.push([callback, args]);

  if (needsNewPhysicalTick) {
    schedulePhysicalTick();
    needsNewPhysicalTick = false;
  }
};

var isOutsideMicroTick = true,
    needsNewPhysicalTick = true,
    unhandledErrors = [],
    rejectingErrors = [],
    currentFulfiller = null,
    rejectionMapper = mirror;
var globalPSD = {
  id: 'global',
  global: true,
  ref: 0,
  unhandleds: [],
  onunhandled: globalError,
  pgp: false,
  env: {},
  finalize: function () {
    this.unhandleds.forEach(uh => {
      try {
        globalError(uh[0], uh[1]);
      } catch (e) {}
    });
  }
};
var PSD = globalPSD;
var microtickQueue = [];
var numScheduledCalls = 0;
var tickFinalizers = [];

function DexiePromise(fn) {
  if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
  this._listeners = [];
  this.onuncatched = nop;
  this._lib = false;
  var psd = this._PSD = PSD;

  if (debug) {
    this._stackHolder = getErrorWithStack();
    this._prev = null;
    this._numPrev = 0;
  }

  if (typeof fn !== 'function') {
    if (fn !== INTERNAL) throw new TypeError('Not a function');
    this._state = arguments[1];
    this._value = arguments[2];
    if (this._state === false) handleRejection(this, this._value);
    return;
  }

  this._state = null;
  this._value = null;
  ++psd.ref;
  executePromiseTask(this, fn);
}

const thenProp = {
  get: function () {
    var psd = PSD,
        microTaskId = totalEchoes;

    function then(onFulfilled, onRejected) {
      var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
      const cleanup = possibleAwait && !decrementExpectedAwaits();
      var rv = new DexiePromise((resolve, reject) => {
        propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));
      });
      debug && linkToPreviousPromise(rv, this);
      return rv;
    }

    then.prototype = INTERNAL;
    return then;
  },
  set: function (value) {
    setProp(this, 'then', value && value.prototype === INTERNAL ? thenProp : {
      get: function () {
        return value;
      },
      set: thenProp.set
    });
  }
};
props(DexiePromise.prototype, {
  then: thenProp,
  _then: function (onFulfilled, onRejected) {
    propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
  },
  catch: function (onRejected) {
    if (arguments.length === 1) return this.then(null, onRejected);
    var type = arguments[0],
        handler = arguments[1];
    return typeof type === 'function' ? this.then(null, err => err instanceof type ? handler(err) : PromiseReject(err)) : this.then(null, err => err && err.name === type ? handler(err) : PromiseReject(err));
  },
  finally: function (onFinally) {
    return this.then(value => {
      onFinally();
      return value;
    }, err => {
      onFinally();
      return PromiseReject(err);
    });
  },
  stack: {
    get: function () {
      if (this._stack) return this._stack;

      try {
        stack_being_generated = true;
        var stacks = getStack(this, [], MAX_LONG_STACKS);
        var stack = stacks.join("\nFrom previous: ");
        if (this._state !== null) this._stack = stack;
        return stack;
      } finally {
        stack_being_generated = false;
      }
    }
  },
  timeout: function (ms, msg) {
    return ms < Infinity ? new DexiePromise((resolve, reject) => {
      var handle = setTimeout(() => reject(new exceptions.Timeout(msg)), ms);
      this.then(resolve, reject).finally(clearTimeout.bind(null, handle));
    }) : this;
  }
});
if (typeof Symbol !== 'undefined' && Symbol.toStringTag) setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');
globalPSD.env = snapShot();

function Listener(onFulfilled, onRejected, resolve, reject, zone) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.resolve = resolve;
  this.reject = reject;
  this.psd = zone;
}

props(DexiePromise, {
  all: function () {
    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
    return new DexiePromise(function (resolve, reject) {
      if (values.length === 0) resolve([]);
      var remaining = values.length;
      values.forEach((a, i) => DexiePromise.resolve(a).then(x => {
        values[i] = x;
        if (! --remaining) resolve(values);
      }, reject));
    });
  },
  resolve: value => {
    if (value instanceof DexiePromise) return value;
    if (value && typeof value.then === 'function') return new DexiePromise((resolve, reject) => {
      value.then(resolve, reject);
    });
    var rv = new DexiePromise(INTERNAL, true, value);
    linkToPreviousPromise(rv, currentFulfiller);
    return rv;
  },
  reject: PromiseReject,
  race: function () {
    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
    return new DexiePromise((resolve, reject) => {
      values.map(value => DexiePromise.resolve(value).then(resolve, reject));
    });
  },
  PSD: {
    get: () => PSD,
    set: value => PSD = value
  },
  totalEchoes: {
    get: () => totalEchoes
  },
  newPSD: newScope,
  usePSD: usePSD,
  scheduler: {
    get: () => asap,
    set: value => {
      asap = value;
    }
  },
  rejectionMapper: {
    get: () => rejectionMapper,
    set: value => {
      rejectionMapper = value;
    }
  },
  follow: (fn, zoneProps) => {
    return new DexiePromise((resolve, reject) => {
      return newScope((resolve, reject) => {
        var psd = PSD;
        psd.unhandleds = [];
        psd.onunhandled = reject;
        psd.finalize = callBoth(function () {
          run_at_end_of_this_or_next_physical_tick(() => {
            this.unhandleds.length === 0 ? resolve() : reject(this.unhandleds[0]);
          });
        }, psd.finalize);
        fn();
      }, zoneProps, resolve, reject);
    });
  }
});

if (NativePromise) {
  if (NativePromise.allSettled) setProp(DexiePromise, "allSettled", function () {
    const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
    return new DexiePromise(resolve => {
      if (possiblePromises.length === 0) resolve([]);
      let remaining = possiblePromises.length;
      const results = new Array(remaining);
      possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => results[i] = {
        status: "fulfilled",
        value
      }, reason => results[i] = {
        status: "rejected",
        reason
      }).then(() => --remaining || resolve(results)));
    });
  });
  if (NativePromise.any && typeof AggregateError !== 'undefined') setProp(DexiePromise, "any", function () {
    const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
    return new DexiePromise((resolve, reject) => {
      if (possiblePromises.length === 0) reject(new AggregateError([]));
      let remaining = possiblePromises.length;
      const failures = new Array(remaining);
      possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => resolve(value), failure => {
        failures[i] = failure;
        if (! --remaining) reject(new AggregateError(failures));
      }));
    });
  });
}

function executePromiseTask(promise, fn) {
  try {
    fn(value => {
      if (promise._state !== null) return;
      if (value === promise) throw new TypeError('A promise cannot be resolved with itself.');
      var shouldExecuteTick = promise._lib && beginMicroTickScope();

      if (value && typeof value.then === 'function') {
        executePromiseTask(promise, (resolve, reject) => {
          value instanceof DexiePromise ? value._then(resolve, reject) : value.then(resolve, reject);
        });
      } else {
        promise._state = true;
        promise._value = value;
        propagateAllListeners(promise);
      }

      if (shouldExecuteTick) endMicroTickScope();
    }, handleRejection.bind(null, promise));
  } catch (ex) {
    handleRejection(promise, ex);
  }
}

function handleRejection(promise, reason) {
  rejectingErrors.push(reason);
  if (promise._state !== null) return;
  var shouldExecuteTick = promise._lib && beginMicroTickScope();
  reason = rejectionMapper(reason);
  promise._state = false;
  promise._value = reason;
  debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(() => {
    var origProp = getPropertyDescriptor(reason, "stack");
    reason._promise = promise;
    setProp(reason, "stack", {
      get: () => stack_being_generated ? origProp && (origProp.get ? origProp.get.apply(reason) : origProp.value) : promise.stack
    });
  });
  addPossiblyUnhandledError(promise);
  propagateAllListeners(promise);
  if (shouldExecuteTick) endMicroTickScope();
}

function propagateAllListeners(promise) {
  var listeners = promise._listeners;
  promise._listeners = [];

  for (var i = 0, len = listeners.length; i < len; ++i) {
    propagateToListener(promise, listeners[i]);
  }

  var psd = promise._PSD;
  --psd.ref || psd.finalize();

  if (numScheduledCalls === 0) {
    ++numScheduledCalls;
    asap(() => {
      if (--numScheduledCalls === 0) finalizePhysicalTick();
    }, []);
  }
}

function propagateToListener(promise, listener) {
  if (promise._state === null) {
    promise._listeners.push(listener);

    return;
  }

  var cb = promise._state ? listener.onFulfilled : listener.onRejected;

  if (cb === null) {
    return (promise._state ? listener.resolve : listener.reject)(promise._value);
  }

  ++listener.psd.ref;
  ++numScheduledCalls;
  asap(callListener, [cb, promise, listener]);
}

function callListener(cb, promise, listener) {
  try {
    currentFulfiller = promise;
    var ret,
        value = promise._value;

    if (promise._state) {
      ret = cb(value);
    } else {
      if (rejectingErrors.length) rejectingErrors = [];
      ret = cb(value);
      if (rejectingErrors.indexOf(value) === -1) markErrorAsHandled(promise);
    }

    listener.resolve(ret);
  } catch (e) {
    listener.reject(e);
  } finally {
    currentFulfiller = null;
    if (--numScheduledCalls === 0) finalizePhysicalTick();
    --listener.psd.ref || listener.psd.finalize();
  }
}

function getStack(promise, stacks, limit) {
  if (stacks.length === limit) return stacks;
  var stack = "";

  if (promise._state === false) {
    var failure = promise._value,
        errorName,
        message;

    if (failure != null) {
      errorName = failure.name || "Error";
      message = failure.message || failure;
      stack = prettyStack(failure, 0);
    } else {
      errorName = failure;
      message = "";
    }

    stacks.push(errorName + (message ? ": " + message : "") + stack);
  }

  if (debug) {
    stack = prettyStack(promise._stackHolder, 2);
    if (stack && stacks.indexOf(stack) === -1) stacks.push(stack);
    if (promise._prev) getStack(promise._prev, stacks, limit);
  }

  return stacks;
}

function linkToPreviousPromise(promise, prev) {
  var numPrev = prev ? prev._numPrev + 1 : 0;

  if (numPrev < LONG_STACKS_CLIP_LIMIT) {
    promise._prev = prev;
    promise._numPrev = numPrev;
  }
}

function physicalTick() {
  beginMicroTickScope() && endMicroTickScope();
}

function beginMicroTickScope() {
  var wasRootExec = isOutsideMicroTick;
  isOutsideMicroTick = false;
  needsNewPhysicalTick = false;
  return wasRootExec;
}

function endMicroTickScope() {
  var callbacks, i, l;

  do {
    while (microtickQueue.length > 0) {
      callbacks = microtickQueue;
      microtickQueue = [];
      l = callbacks.length;

      for (i = 0; i < l; ++i) {
        var item = callbacks[i];
        item[0].apply(null, item[1]);
      }
    }
  } while (microtickQueue.length > 0);

  isOutsideMicroTick = true;
  needsNewPhysicalTick = true;
}

function finalizePhysicalTick() {
  var unhandledErrs = unhandledErrors;
  unhandledErrors = [];
  unhandledErrs.forEach(p => {
    p._PSD.onunhandled.call(null, p._value, p);
  });
  var finalizers = tickFinalizers.slice(0);
  var i = finalizers.length;

  while (i) finalizers[--i]();
}

function run_at_end_of_this_or_next_physical_tick(fn) {
  function finalizer() {
    fn();
    tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
  }

  tickFinalizers.push(finalizer);
  ++numScheduledCalls;
  asap(() => {
    if (--numScheduledCalls === 0) finalizePhysicalTick();
  }, []);
}

function addPossiblyUnhandledError(promise) {
  if (!unhandledErrors.some(p => p._value === promise._value)) unhandledErrors.push(promise);
}

function markErrorAsHandled(promise) {
  var i = unhandledErrors.length;

  while (i) if (unhandledErrors[--i]._value === promise._value) {
    unhandledErrors.splice(i, 1);
    return;
  }
}

function PromiseReject(reason) {
  return new DexiePromise(INTERNAL, false, reason);
}

function wrap(fn, errorCatcher) {
  var psd = PSD;
  return function () {
    var wasRootExec = beginMicroTickScope(),
        outerScope = PSD;

    try {
      switchToZone(psd, true);
      return fn.apply(this, arguments);
    } catch (e) {
      errorCatcher && errorCatcher(e);
    } finally {
      switchToZone(outerScope, false);
      if (wasRootExec) endMicroTickScope();
    }
  };
}

const task = {
  awaits: 0,
  echoes: 0,
  id: 0
};
var taskCounter = 0;
var zoneStack = [];
var zoneEchoes = 0;
var totalEchoes = 0;
var zone_id_counter = 0;

function newScope(fn, props, a1, a2) {
  var parent = PSD,
      psd = Object.create(parent);
  psd.parent = parent;
  psd.ref = 0;
  psd.global = false;
  psd.id = ++zone_id_counter;
  var globalEnv = globalPSD.env;
  psd.env = patchGlobalPromise ? {
    Promise: DexiePromise,
    PromiseProp: {
      value: DexiePromise,
      configurable: true,
      writable: true
    },
    all: DexiePromise.all,
    race: DexiePromise.race,
    allSettled: DexiePromise.allSettled,
    any: DexiePromise.any,
    resolve: DexiePromise.resolve,
    reject: DexiePromise.reject,
    nthen: getPatchedPromiseThen(globalEnv.nthen, psd),
    gthen: getPatchedPromiseThen(globalEnv.gthen, psd)
  } : {};
  if (props) extend(psd, props);
  ++parent.ref;

  psd.finalize = function () {
    --this.parent.ref || this.parent.finalize();
  };

  var rv = usePSD(psd, fn, a1, a2);
  if (psd.ref === 0) psd.finalize();
  return rv;
}

function incrementExpectedAwaits() {
  if (!task.id) task.id = ++taskCounter;
  ++task.awaits;
  task.echoes += ZONE_ECHO_LIMIT;
  return task.id;
}

function decrementExpectedAwaits() {
  if (!task.awaits) return false;
  if (--task.awaits === 0) task.id = 0;
  task.echoes = task.awaits * ZONE_ECHO_LIMIT;
  return true;
}

if (('' + nativePromiseThen).indexOf('[native code]') === -1) {
  incrementExpectedAwaits = decrementExpectedAwaits = nop;
}

function onPossibleParallellAsync(possiblePromise) {
  if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
    incrementExpectedAwaits();
    return possiblePromise.then(x => {
      decrementExpectedAwaits();
      return x;
    }, e => {
      decrementExpectedAwaits();
      return rejection(e);
    });
  }

  return possiblePromise;
}

function zoneEnterEcho(targetZone) {
  ++totalEchoes;

  if (!task.echoes || --task.echoes === 0) {
    task.echoes = task.id = 0;
  }

  zoneStack.push(PSD);
  switchToZone(targetZone, true);
}

function zoneLeaveEcho() {
  var zone = zoneStack[zoneStack.length - 1];
  zoneStack.pop();
  switchToZone(zone, false);
}

function switchToZone(targetZone, bEnteringZone) {
  var currentZone = PSD;

  if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (! --zoneEchoes || targetZone !== PSD)) {
    enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
  }

  if (targetZone === PSD) return;
  PSD = targetZone;
  if (currentZone === globalPSD) globalPSD.env = snapShot();

  if (patchGlobalPromise) {
    var GlobalPromise = globalPSD.env.Promise;
    var targetEnv = targetZone.env;
    nativePromiseProto.then = targetEnv.nthen;
    GlobalPromise.prototype.then = targetEnv.gthen;

    if (currentZone.global || targetZone.global) {
      Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);
      GlobalPromise.all = targetEnv.all;
      GlobalPromise.race = targetEnv.race;
      GlobalPromise.resolve = targetEnv.resolve;
      GlobalPromise.reject = targetEnv.reject;
      if (targetEnv.allSettled) GlobalPromise.allSettled = targetEnv.allSettled;
      if (targetEnv.any) GlobalPromise.any = targetEnv.any;
    }
  }
}

function snapShot() {
  var GlobalPromise = _global.Promise;
  return patchGlobalPromise ? {
    Promise: GlobalPromise,
    PromiseProp: Object.getOwnPropertyDescriptor(_global, "Promise"),
    all: GlobalPromise.all,
    race: GlobalPromise.race,
    allSettled: GlobalPromise.allSettled,
    any: GlobalPromise.any,
    resolve: GlobalPromise.resolve,
    reject: GlobalPromise.reject,
    nthen: nativePromiseProto.then,
    gthen: GlobalPromise.prototype.then
  } : {};
}

function usePSD(psd, fn, a1, a2, a3) {
  var outerScope = PSD;

  try {
    switchToZone(psd, true);
    return fn(a1, a2, a3);
  } finally {
    switchToZone(outerScope, false);
  }
}

function enqueueNativeMicroTask(job) {
  nativePromiseThen.call(resolvedNativePromise, job);
}

function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {
  return typeof fn !== 'function' ? fn : function () {
    var outerZone = PSD;
    if (possibleAwait) incrementExpectedAwaits();
    switchToZone(zone, true);

    try {
      return fn.apply(this, arguments);
    } finally {
      switchToZone(outerZone, false);
      if (cleanup) enqueueNativeMicroTask(decrementExpectedAwaits);
    }
  };
}

function getPatchedPromiseThen(origThen, zone) {
  return function (onResolved, onRejected) {
    return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));
  };
}

const UNHANDLEDREJECTION = "unhandledrejection";

function globalError(err, promise) {
  var rv;

  try {
    rv = promise.onuncatched(err);
  } catch (e) {}

  if (rv !== false) try {
    var event,
        eventData = {
      promise: promise,
      reason: err
    };

    if (_global.document && document.createEvent) {
      event = document.createEvent('Event');
      event.initEvent(UNHANDLEDREJECTION, true, true);
      extend(event, eventData);
    } else if (_global.CustomEvent) {
      event = new CustomEvent(UNHANDLEDREJECTION, {
        detail: eventData
      });
      extend(event, eventData);
    }

    if (event && _global.dispatchEvent) {
      dispatchEvent(event);
      if (!_global.PromiseRejectionEvent && _global.onunhandledrejection) try {
        _global.onunhandledrejection(event);
      } catch (_) {}
    }

    if (debug && event && !event.defaultPrevented) {
      console.warn("Unhandled rejection: ".concat(err.stack || err));
    }
  } catch (e) {}
}

var rejection = DexiePromise.reject;

function tempTransaction(db, mode, storeNames, fn) {
  if (!db.idbdb || !db._state.openComplete && !PSD.letThrough && !db._vip) {
    if (db._state.openComplete) {
      return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));
    }

    if (!db._state.isBeingOpened) {
      if (!db._options.autoOpen) return rejection(new exceptions.DatabaseClosed());
      db.open().catch(nop);
    }

    return db._state.dbReadyPromise.then(() => tempTransaction(db, mode, storeNames, fn));
  } else {
    var trans = db._createTransaction(mode, storeNames, db._dbSchema);

    try {
      trans.create();
      db._state.PR1398_maxLoop = 3;
    } catch (ex) {
      if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
        console.warn('Dexie: Need to reopen db');

        db._close();

        return db.open().then(() => tempTransaction(db, mode, storeNames, fn));
      }

      return rejection(ex);
    }

    return trans._promise(mode, (resolve, reject) => {
      return newScope(() => {
        PSD.trans = trans;
        return fn(resolve, reject, trans);
      });
    }).then(result => {
      return trans._completion.then(() => result);
    });
  }
}

const DEXIE_VERSION = '3.2.2';
const maxString = String.fromCharCode(65535);
const minKey = -Infinity;
const INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
const STRING_EXPECTED = "String expected.";
const connections = [];
const isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);
const hasIEDeleteObjectStoreBug = isIEOrEdge;
const hangsOnDeleteLargeKeyRange = isIEOrEdge;

const dexieStackFrameFilter = frame => !/(dexie\.js|dexie\.min\.js)/.test(frame);

const DBNAMES_DB = '__dbnames';
const READONLY = 'readonly';
const READWRITE = 'readwrite';

function combine(filter1, filter2) {
  return filter1 ? filter2 ? function () {
    return filter1.apply(this, arguments) && filter2.apply(this, arguments);
  } : filter1 : filter2;
}

const AnyRange = {
  type: 3,
  lower: -Infinity,
  lowerOpen: false,
  upper: [[]],
  upperOpen: false
};

function workaroundForUndefinedPrimKey(keyPath) {
  return typeof keyPath === "string" && !/\./.test(keyPath) ? obj => {
    if (obj[keyPath] === undefined && keyPath in obj) {
      obj = deepClone(obj);
      delete obj[keyPath];
    }

    return obj;
  } : obj => obj;
}

let Table = /*#__PURE__*/function () {
  function Table() {
    _classCallCheck(this, Table);
  }

  _createClass(Table, [{
    key: "_trans",
    value: function _trans(mode, fn, writeLocked) {
      const trans = this._tx || PSD.trans;
      const tableName = this.name;

      function checkTableInTransaction(resolve, reject, trans) {
        if (!trans.schema[tableName]) throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
        return fn(trans.idbtrans, trans);
      }

      const wasRootExec = beginMicroTickScope();

      try {
        return trans && trans.db === this.db ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(() => trans._promise(mode, checkTableInTransaction, writeLocked), {
          trans: trans,
          transless: PSD.transless || PSD
        }) : tempTransaction(this.db, mode, [this.name], checkTableInTransaction);
      } finally {
        if (wasRootExec) endMicroTickScope();
      }
    }
  }, {
    key: "get",
    value: function get(keyOrCrit, cb) {
      if (keyOrCrit && keyOrCrit.constructor === Object) return this.where(keyOrCrit).first(cb);
      return this._trans('readonly', trans => {
        return this.core.get({
          trans,
          key: keyOrCrit
        }).then(res => this.hook.reading.fire(res));
      }).then(cb);
    }
  }, {
    key: "where",
    value: function where(indexOrCrit) {
      if (typeof indexOrCrit === 'string') return new this.db.WhereClause(this, indexOrCrit);
      if (isArray(indexOrCrit)) return new this.db.WhereClause(this, "[".concat(indexOrCrit.join('+'), "]"));
      const keyPaths = keys(indexOrCrit);
      if (keyPaths.length === 1) return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);
      const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(ix => ix.compound && keyPaths.every(keyPath => ix.keyPath.indexOf(keyPath) >= 0) && ix.keyPath.every(keyPath => keyPaths.indexOf(keyPath) >= 0))[0];
      if (compoundIndex && this.db._maxKey !== maxString) return this.where(compoundIndex.name).equals(compoundIndex.keyPath.map(kp => indexOrCrit[kp]));
      if (!compoundIndex && debug) console.warn("The query ".concat(JSON.stringify(indexOrCrit), " on ").concat(this.name, " would benefit of a ") + "compound index [".concat(keyPaths.join('+'), "]"));
      const {
        idxByName
      } = this.schema;
      const idb = this.db._deps.indexedDB;

      function equals(a, b) {
        try {
          return idb.cmp(a, b) === 0;
        } catch (e) {
          return false;
        }
      }

      const [idx, filterFunction] = keyPaths.reduce((_ref, keyPath) => {
        let [prevIndex, prevFilterFn] = _ref;
        const index = idxByName[keyPath];
        const value = indexOrCrit[keyPath];
        return [prevIndex || index, prevIndex || !index ? combine(prevFilterFn, index && index.multi ? x => {
          const prop = getByKeyPath(x, keyPath);
          return isArray(prop) && prop.some(item => equals(value, item));
        } : x => equals(value, getByKeyPath(x, keyPath))) : prevFilterFn];
      }, [null, null]);
      return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals('');
    }
  }, {
    key: "filter",
    value: function filter(filterFunction) {
      return this.toCollection().and(filterFunction);
    }
  }, {
    key: "count",
    value: function count(thenShortcut) {
      return this.toCollection().count(thenShortcut);
    }
  }, {
    key: "offset",
    value: function offset(_offset) {
      return this.toCollection().offset(_offset);
    }
  }, {
    key: "limit",
    value: function limit(numRows) {
      return this.toCollection().limit(numRows);
    }
  }, {
    key: "each",
    value: function each(callback) {
      return this.toCollection().each(callback);
    }
  }, {
    key: "toArray",
    value: function toArray(thenShortcut) {
      return this.toCollection().toArray(thenShortcut);
    }
  }, {
    key: "toCollection",
    value: function toCollection() {
      return new this.db.Collection(new this.db.WhereClause(this));
    }
  }, {
    key: "orderBy",
    value: function orderBy(index) {
      return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ? "[".concat(index.join('+'), "]") : index));
    }
  }, {
    key: "reverse",
    value: function reverse() {
      return this.toCollection().reverse();
    }
  }, {
    key: "mapToClass",
    value: function mapToClass(constructor) {
      this.schema.mappedClass = constructor;

      const readHook = obj => {
        if (!obj) return obj;
        const res = Object.create(constructor.prototype);

        for (var m in obj) if (hasOwn(obj, m)) try {
          res[m] = obj[m];
        } catch (_) {}

        return res;
      };

      if (this.schema.readHook) {
        this.hook.reading.unsubscribe(this.schema.readHook);
      }

      this.schema.readHook = readHook;
      this.hook("reading", readHook);
      return constructor;
    }
  }, {
    key: "defineClass",
    value: function defineClass() {
      function Class(content) {
        extend(this, content);
      }

      return this.mapToClass(Class);
    }
  }, {
    key: "add",
    value: function add(obj, key) {
      const {
        auto,
        keyPath
      } = this.schema.primKey;
      let objToAdd = obj;

      if (keyPath && auto) {
        objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
      }

      return this._trans('readwrite', trans => {
        return this.core.mutate({
          trans,
          type: 'add',
          keys: key != null ? [key] : null,
          values: [objToAdd]
        });
      }).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then(lastResult => {
        if (keyPath) {
          try {
            setByKeyPath(obj, keyPath, lastResult);
          } catch (_) {}
        }

        return lastResult;
      });
    }
  }, {
    key: "update",
    value: function update(keyOrObject, modifications) {
      if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {
        const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
        if (key === undefined) return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));

        try {
          if (typeof modifications !== "function") {
            keys(modifications).forEach(keyPath => {
              setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);
            });
          } else {
            modifications(keyOrObject, {
              value: keyOrObject,
              primKey: key
            });
          }
        } catch (_a) {}

        return this.where(":id").equals(key).modify(modifications);
      } else {
        return this.where(":id").equals(keyOrObject).modify(modifications);
      }
    }
  }, {
    key: "put",
    value: function put(obj, key) {
      const {
        auto,
        keyPath
      } = this.schema.primKey;
      let objToAdd = obj;

      if (keyPath && auto) {
        objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
      }

      return this._trans('readwrite', trans => this.core.mutate({
        trans,
        type: 'put',
        values: [objToAdd],
        keys: key != null ? [key] : null
      })).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then(lastResult => {
        if (keyPath) {
          try {
            setByKeyPath(obj, keyPath, lastResult);
          } catch (_) {}
        }

        return lastResult;
      });
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      return this._trans('readwrite', trans => this.core.mutate({
        trans,
        type: 'delete',
        keys: [key]
      })).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);
    }
  }, {
    key: "clear",
    value: function clear() {
      return this._trans('readwrite', trans => this.core.mutate({
        trans,
        type: 'deleteRange',
        range: AnyRange
      })).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);
    }
  }, {
    key: "bulkGet",
    value: function bulkGet(keys) {
      return this._trans('readonly', trans => {
        return this.core.getMany({
          keys,
          trans
        }).then(result => result.map(res => this.hook.reading.fire(res)));
      });
    }
  }, {
    key: "bulkAdd",
    value: function bulkAdd(objects, keysOrOptions, options) {
      const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;
      options = options || (keys ? undefined : keysOrOptions);
      const wantResults = options ? options.allKeys : undefined;
      return this._trans('readwrite', trans => {
        const {
          auto,
          keyPath
        } = this.schema.primKey;
        if (keyPath && keys) throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
        if (keys && keys.length !== objects.length) throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
        const numObjects = objects.length;
        let objectsToAdd = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
        return this.core.mutate({
          trans,
          type: 'add',
          keys: keys,
          values: objectsToAdd,
          wantResults
        }).then(_ref2 => {
          let {
            numFailures,
            results,
            lastResult,
            failures
          } = _ref2;
          const result = wantResults ? results : lastResult;
          if (numFailures === 0) return result;
          throw new BulkError("".concat(this.name, ".bulkAdd(): ").concat(numFailures, " of ").concat(numObjects, " operations failed"), failures);
        });
      });
    }
  }, {
    key: "bulkPut",
    value: function bulkPut(objects, keysOrOptions, options) {
      const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;
      options = options || (keys ? undefined : keysOrOptions);
      const wantResults = options ? options.allKeys : undefined;
      return this._trans('readwrite', trans => {
        const {
          auto,
          keyPath
        } = this.schema.primKey;
        if (keyPath && keys) throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
        if (keys && keys.length !== objects.length) throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
        const numObjects = objects.length;
        let objectsToPut = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
        return this.core.mutate({
          trans,
          type: 'put',
          keys: keys,
          values: objectsToPut,
          wantResults
        }).then(_ref3 => {
          let {
            numFailures,
            results,
            lastResult,
            failures
          } = _ref3;
          const result = wantResults ? results : lastResult;
          if (numFailures === 0) return result;
          throw new BulkError("".concat(this.name, ".bulkPut(): ").concat(numFailures, " of ").concat(numObjects, " operations failed"), failures);
        });
      });
    }
  }, {
    key: "bulkDelete",
    value: function bulkDelete(keys) {
      const numKeys = keys.length;
      return this._trans('readwrite', trans => {
        return this.core.mutate({
          trans,
          type: 'delete',
          keys: keys
        });
      }).then(_ref4 => {
        let {
          numFailures,
          lastResult,
          failures
        } = _ref4;
        if (numFailures === 0) return lastResult;
        throw new BulkError("".concat(this.name, ".bulkDelete(): ").concat(numFailures, " of ").concat(numKeys, " operations failed"), failures);
      });
    }
  }]);

  return Table;
}();

function Events(ctx) {
  var evs = {};

  var rv = function (eventName, subscriber) {
    if (subscriber) {
      var i = arguments.length,
          args = new Array(i - 1);

      while (--i) args[i - 1] = arguments[i];

      evs[eventName].subscribe.apply(null, args);
      return ctx;
    } else if (typeof eventName === 'string') {
      return evs[eventName];
    }
  };

  rv.addEventType = add;

  for (var i = 1, l = arguments.length; i < l; ++i) {
    add(arguments[i]);
  }

  return rv;

  function add(eventName, chainFunction, defaultFunction) {
    if (typeof eventName === 'object') return addConfiguredEvents(eventName);
    if (!chainFunction) chainFunction = reverseStoppableEventChain;
    if (!defaultFunction) defaultFunction = nop;
    var context = {
      subscribers: [],
      fire: defaultFunction,
      subscribe: function (cb) {
        if (context.subscribers.indexOf(cb) === -1) {
          context.subscribers.push(cb);
          context.fire = chainFunction(context.fire, cb);
        }
      },
      unsubscribe: function (cb) {
        context.subscribers = context.subscribers.filter(function (fn) {
          return fn !== cb;
        });
        context.fire = context.subscribers.reduce(chainFunction, defaultFunction);
      }
    };
    evs[eventName] = rv[eventName] = context;
    return context;
  }

  function addConfiguredEvents(cfg) {
    keys(cfg).forEach(function (eventName) {
      var args = cfg[eventName];

      if (isArray(args)) {
        add(eventName, cfg[eventName][0], cfg[eventName][1]);
      } else if (args === 'asap') {
        var context = add(eventName, mirror, function fire() {
          var i = arguments.length,
              args = new Array(i);

          while (i--) args[i] = arguments[i];

          context.subscribers.forEach(function (fn) {
            asap$1(function fireEvent() {
              fn.apply(null, args);
            });
          });
        });
      } else throw new exceptions.InvalidArgument("Invalid event config");
    });
  }
}

function makeClassConstructor(prototype, constructor) {
  derive(constructor).from({
    prototype
  });
  return constructor;
}

function createTableConstructor(db) {
  return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {
    this.db = db;
    this._tx = trans;
    this.name = name;
    this.schema = tableSchema;
    this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {
      "creating": [hookCreatingChain, nop],
      "reading": [pureFunctionChain, mirror],
      "updating": [hookUpdatingChain, nop],
      "deleting": [hookDeletingChain, nop]
    });
  });
}

function isPlainKeyRange(ctx, ignoreLimitFilter) {
  return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
}

function addFilter(ctx, fn) {
  ctx.filter = combine(ctx.filter, fn);
}

function addReplayFilter(ctx, factory, isLimitFilter) {
  var curr = ctx.replayFilter;
  ctx.replayFilter = curr ? () => combine(curr(), factory()) : factory;
  ctx.justLimit = isLimitFilter && !curr;
}

function addMatchFilter(ctx, fn) {
  ctx.isMatch = combine(ctx.isMatch, fn);
}

function getIndexOrStore(ctx, coreSchema) {
  if (ctx.isPrimKey) return coreSchema.primaryKey;
  const index = coreSchema.getIndexByKeyPath(ctx.index);
  if (!index) throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
  return index;
}

function openCursor(ctx, coreTable, trans) {
  const index = getIndexOrStore(ctx, coreTable.schema);
  return coreTable.openCursor({
    trans,
    values: !ctx.keysOnly,
    reverse: ctx.dir === 'prev',
    unique: !!ctx.unique,
    query: {
      index,
      range: ctx.range
    }
  });
}

function iter(ctx, fn, coreTrans, coreTable) {
  const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;

  if (!ctx.or) {
    return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);
  } else {
    const set = {};

    const union = (item, cursor, advance) => {
      if (!filter || filter(cursor, advance, result => cursor.stop(result), err => cursor.fail(err))) {
        var primaryKey = cursor.primaryKey;
        var key = '' + primaryKey;
        if (key === '[object ArrayBuffer]') key = '' + new Uint8Array(primaryKey);

        if (!hasOwn(set, key)) {
          set[key] = true;
          fn(item, cursor, advance);
        }
      }
    };

    return Promise.all([ctx.or._iterate(union, coreTrans), iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)]);
  }
}

function iterate(cursorPromise, filter, fn, valueMapper) {
  var mappedFn = valueMapper ? (x, c, a) => fn(valueMapper(x), c, a) : fn;
  var wrappedFn = wrap(mappedFn);
  return cursorPromise.then(cursor => {
    if (cursor) {
      return cursor.start(() => {
        var c = () => cursor.continue();

        if (!filter || filter(cursor, advancer => c = advancer, val => {
          cursor.stop(val);
          c = nop;
        }, e => {
          cursor.fail(e);
          c = nop;
        })) wrappedFn(cursor.value, cursor, advancer => c = advancer);
        c();
      });
    }
  });
}

function cmp(a, b) {
  try {
    const ta = type(a);
    const tb = type(b);

    if (ta !== tb) {
      if (ta === 'Array') return 1;
      if (tb === 'Array') return -1;
      if (ta === 'binary') return 1;
      if (tb === 'binary') return -1;
      if (ta === 'string') return 1;
      if (tb === 'string') return -1;
      if (ta === 'Date') return 1;
      if (tb !== 'Date') return NaN;
      return -1;
    }

    switch (ta) {
      case 'number':
      case 'Date':
      case 'string':
        return a > b ? 1 : a < b ? -1 : 0;

      case 'binary':
        {
          return compareUint8Arrays(getUint8Array(a), getUint8Array(b));
        }

      case 'Array':
        return compareArrays(a, b);
    }
  } catch (_a) {}

  return NaN;
}

function compareArrays(a, b) {
  const al = a.length;
  const bl = b.length;
  const l = al < bl ? al : bl;

  for (let i = 0; i < l; ++i) {
    const res = cmp(a[i], b[i]);
    if (res !== 0) return res;
  }

  return al === bl ? 0 : al < bl ? -1 : 1;
}

function compareUint8Arrays(a, b) {
  const al = a.length;
  const bl = b.length;
  const l = al < bl ? al : bl;

  for (let i = 0; i < l; ++i) {
    if (a[i] !== b[i]) return a[i] < b[i] ? -1 : 1;
  }

  return al === bl ? 0 : al < bl ? -1 : 1;
}

function type(x) {
  const t = typeof x;
  if (t !== 'object') return t;
  if (ArrayBuffer.isView(x)) return 'binary';
  const tsTag = toStringTag(x);
  return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;
}

function getUint8Array(a) {
  if (a instanceof Uint8Array) return a;
  if (ArrayBuffer.isView(a)) return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
  return new Uint8Array(a);
}

let Collection = /*#__PURE__*/function () {
  function Collection() {
    _classCallCheck(this, Collection);
  }

  _createClass(Collection, [{
    key: "_read",
    value: function _read(fn, cb) {
      var ctx = this._ctx;
      return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans('readonly', fn).then(cb);
    }
  }, {
    key: "_write",
    value: function _write(fn) {
      var ctx = this._ctx;
      return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans('readwrite', fn, "locked");
    }
  }, {
    key: "_addAlgorithm",
    value: function _addAlgorithm(fn) {
      var ctx = this._ctx;
      ctx.algorithm = combine(ctx.algorithm, fn);
    }
  }, {
    key: "_iterate",
    value: function _iterate(fn, coreTrans) {
      return iter(this._ctx, fn, coreTrans, this._ctx.table.core);
    }
  }, {
    key: "clone",
    value: function clone(props) {
      var rv = Object.create(this.constructor.prototype),
          ctx = Object.create(this._ctx);
      if (props) extend(ctx, props);
      rv._ctx = ctx;
      return rv;
    }
  }, {
    key: "raw",
    value: function raw() {
      this._ctx.valueMapper = null;
      return this;
    }
  }, {
    key: "each",
    value: function each(fn) {
      var ctx = this._ctx;
      return this._read(trans => iter(ctx, fn, trans, ctx.table.core));
    }
  }, {
    key: "count",
    value: function count(cb) {
      return this._read(trans => {
        const ctx = this._ctx;
        const coreTable = ctx.table.core;

        if (isPlainKeyRange(ctx, true)) {
          return coreTable.count({
            trans,
            query: {
              index: getIndexOrStore(ctx, coreTable.schema),
              range: ctx.range
            }
          }).then(count => Math.min(count, ctx.limit));
        } else {
          var count = 0;
          return iter(ctx, () => {
            ++count;
            return false;
          }, trans, coreTable).then(() => count);
        }
      }).then(cb);
    }
  }, {
    key: "sortBy",
    value: function sortBy(keyPath, cb) {
      const parts = keyPath.split('.').reverse(),
            lastPart = parts[0],
            lastIndex = parts.length - 1;

      function getval(obj, i) {
        if (i) return getval(obj[parts[i]], i - 1);
        return obj[lastPart];
      }

      var order = this._ctx.dir === "next" ? 1 : -1;

      function sorter(a, b) {
        var aVal = getval(a, lastIndex),
            bVal = getval(b, lastIndex);
        return aVal < bVal ? -order : aVal > bVal ? order : 0;
      }

      return this.toArray(function (a) {
        return a.sort(sorter);
      }).then(cb);
    }
  }, {
    key: "toArray",
    value: function toArray(cb) {
      return this._read(trans => {
        var ctx = this._ctx;

        if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
          const {
            valueMapper
          } = ctx;
          const index = getIndexOrStore(ctx, ctx.table.core.schema);
          return ctx.table.core.query({
            trans,
            limit: ctx.limit,
            values: true,
            query: {
              index,
              range: ctx.range
            }
          }).then(_ref5 => {
            let {
              result
            } = _ref5;
            return valueMapper ? result.map(valueMapper) : result;
          });
        } else {
          const a = [];
          return iter(ctx, item => a.push(item), trans, ctx.table.core).then(() => a);
        }
      }, cb);
    }
  }, {
    key: "offset",
    value: function offset(_offset2) {
      var ctx = this._ctx;
      if (_offset2 <= 0) return this;
      ctx.offset += _offset2;

      if (isPlainKeyRange(ctx)) {
        addReplayFilter(ctx, () => {
          var offsetLeft = _offset2;
          return (cursor, advance) => {
            if (offsetLeft === 0) return true;

            if (offsetLeft === 1) {
              --offsetLeft;
              return false;
            }

            advance(() => {
              cursor.advance(offsetLeft);
              offsetLeft = 0;
            });
            return false;
          };
        });
      } else {
        addReplayFilter(ctx, () => {
          var offsetLeft = _offset2;
          return () => --offsetLeft < 0;
        });
      }

      return this;
    }
  }, {
    key: "limit",
    value: function limit(numRows) {
      this._ctx.limit = Math.min(this._ctx.limit, numRows);
      addReplayFilter(this._ctx, () => {
        var rowsLeft = numRows;
        return function (cursor, advance, resolve) {
          if (--rowsLeft <= 0) advance(resolve);
          return rowsLeft >= 0;
        };
      }, true);
      return this;
    }
  }, {
    key: "until",
    value: function until(filterFunction, bIncludeStopEntry) {
      addFilter(this._ctx, function (cursor, advance, resolve) {
        if (filterFunction(cursor.value)) {
          advance(resolve);
          return bIncludeStopEntry;
        } else {
          return true;
        }
      });
      return this;
    }
  }, {
    key: "first",
    value: function first(cb) {
      return this.limit(1).toArray(function (a) {
        return a[0];
      }).then(cb);
    }
  }, {
    key: "last",
    value: function last(cb) {
      return this.reverse().first(cb);
    }
  }, {
    key: "filter",
    value: function filter(filterFunction) {
      addFilter(this._ctx, function (cursor) {
        return filterFunction(cursor.value);
      });
      addMatchFilter(this._ctx, filterFunction);
      return this;
    }
  }, {
    key: "and",
    value: function and(filter) {
      return this.filter(filter);
    }
  }, {
    key: "or",
    value: function or(indexName) {
      return new this.db.WhereClause(this._ctx.table, indexName, this);
    }
  }, {
    key: "reverse",
    value: function reverse() {
      this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev";
      if (this._ondirectionchange) this._ondirectionchange(this._ctx.dir);
      return this;
    }
  }, {
    key: "desc",
    value: function desc() {
      return this.reverse();
    }
  }, {
    key: "eachKey",
    value: function eachKey(cb) {
      var ctx = this._ctx;
      ctx.keysOnly = !ctx.isMatch;
      return this.each(function (val, cursor) {
        cb(cursor.key, cursor);
      });
    }
  }, {
    key: "eachUniqueKey",
    value: function eachUniqueKey(cb) {
      this._ctx.unique = "unique";
      return this.eachKey(cb);
    }
  }, {
    key: "eachPrimaryKey",
    value: function eachPrimaryKey(cb) {
      var ctx = this._ctx;
      ctx.keysOnly = !ctx.isMatch;
      return this.each(function (val, cursor) {
        cb(cursor.primaryKey, cursor);
      });
    }
  }, {
    key: "keys",
    value: function keys(cb) {
      var ctx = this._ctx;
      ctx.keysOnly = !ctx.isMatch;
      var a = [];
      return this.each(function (item, cursor) {
        a.push(cursor.key);
      }).then(function () {
        return a;
      }).then(cb);
    }
  }, {
    key: "primaryKeys",
    value: function primaryKeys(cb) {
      var ctx = this._ctx;

      if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
        return this._read(trans => {
          var index = getIndexOrStore(ctx, ctx.table.core.schema);
          return ctx.table.core.query({
            trans,
            values: false,
            limit: ctx.limit,
            query: {
              index,
              range: ctx.range
            }
          });
        }).then(_ref6 => {
          let {
            result
          } = _ref6;
          return result;
        }).then(cb);
      }

      ctx.keysOnly = !ctx.isMatch;
      var a = [];
      return this.each(function (item, cursor) {
        a.push(cursor.primaryKey);
      }).then(function () {
        return a;
      }).then(cb);
    }
  }, {
    key: "uniqueKeys",
    value: function uniqueKeys(cb) {
      this._ctx.unique = "unique";
      return this.keys(cb);
    }
  }, {
    key: "firstKey",
    value: function firstKey(cb) {
      return this.limit(1).keys(function (a) {
        return a[0];
      }).then(cb);
    }
  }, {
    key: "lastKey",
    value: function lastKey(cb) {
      return this.reverse().firstKey(cb);
    }
  }, {
    key: "distinct",
    value: function distinct() {
      var ctx = this._ctx,
          idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
      if (!idx || !idx.multi) return this;
      var set = {};
      addFilter(this._ctx, function (cursor) {
        var strKey = cursor.primaryKey.toString();
        var found = hasOwn(set, strKey);
        set[strKey] = true;
        return !found;
      });
      return this;
    }
  }, {
    key: "modify",
    value: function modify(changes) {
      var ctx = this._ctx;
      return this._write(trans => {
        var modifyer;

        if (typeof changes === 'function') {
          modifyer = changes;
        } else {
          var keyPaths = keys(changes);
          var numKeys = keyPaths.length;

          modifyer = function (item) {
            var anythingModified = false;

            for (var i = 0; i < numKeys; ++i) {
              var keyPath = keyPaths[i],
                  val = changes[keyPath];

              if (getByKeyPath(item, keyPath) !== val) {
                setByKeyPath(item, keyPath, val);
                anythingModified = true;
              }
            }

            return anythingModified;
          };
        }

        const coreTable = ctx.table.core;
        const {
          outbound,
          extractKey
        } = coreTable.schema.primaryKey;
        const limit = this.db._options.modifyChunkSize || 200;
        const totalFailures = [];
        let successCount = 0;
        const failedKeys = [];

        const applyMutateResult = (expectedCount, res) => {
          const {
            failures,
            numFailures
          } = res;
          successCount += expectedCount - numFailures;

          for (let pos of keys(failures)) {
            totalFailures.push(failures[pos]);
          }
        };

        return this.clone().primaryKeys().then(keys => {
          const nextChunk = offset => {
            const count = Math.min(limit, keys.length - offset);
            return coreTable.getMany({
              trans,
              keys: keys.slice(offset, offset + count),
              cache: "immutable"
            }).then(values => {
              const addValues = [];
              const putValues = [];
              const putKeys = outbound ? [] : null;
              const deleteKeys = [];

              for (let i = 0; i < count; ++i) {
                const origValue = values[i];
                const ctx = {
                  value: deepClone(origValue),
                  primKey: keys[offset + i]
                };

                if (modifyer.call(ctx, ctx.value, ctx) !== false) {
                  if (ctx.value == null) {
                    deleteKeys.push(keys[offset + i]);
                  } else if (!outbound && cmp(extractKey(origValue), extractKey(ctx.value)) !== 0) {
                    deleteKeys.push(keys[offset + i]);
                    addValues.push(ctx.value);
                  } else {
                    putValues.push(ctx.value);
                    if (outbound) putKeys.push(keys[offset + i]);
                  }
                }
              }

              const criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== 'function' || changes === deleteCallback) && {
                index: ctx.index,
                range: ctx.range
              };
              return Promise.resolve(addValues.length > 0 && coreTable.mutate({
                trans,
                type: 'add',
                values: addValues
              }).then(res => {
                for (let pos in res.failures) {
                  deleteKeys.splice(parseInt(pos), 1);
                }

                applyMutateResult(addValues.length, res);
              })).then(() => (putValues.length > 0 || criteria && typeof changes === 'object') && coreTable.mutate({
                trans,
                type: 'put',
                keys: putKeys,
                values: putValues,
                criteria,
                changeSpec: typeof changes !== 'function' && changes
              }).then(res => applyMutateResult(putValues.length, res))).then(() => (deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({
                trans,
                type: 'delete',
                keys: deleteKeys,
                criteria
              }).then(res => applyMutateResult(deleteKeys.length, res))).then(() => {
                return keys.length > offset + count && nextChunk(offset + limit);
              });
            });
          };

          return nextChunk(0).then(() => {
            if (totalFailures.length > 0) throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
            return keys.length;
          });
        });
      });
    }
  }, {
    key: "delete",
    value: function _delete() {
      var ctx = this._ctx,
          range = ctx.range;

      if (isPlainKeyRange(ctx) && (ctx.isPrimKey && !hangsOnDeleteLargeKeyRange || range.type === 3)) {
        return this._write(trans => {
          const {
            primaryKey
          } = ctx.table.core.schema;
          const coreRange = range;
          return ctx.table.core.count({
            trans,
            query: {
              index: primaryKey,
              range: coreRange
            }
          }).then(count => {
            return ctx.table.core.mutate({
              trans,
              type: 'deleteRange',
              range: coreRange
            }).then(_ref7 => {
              let {
                failures,
                lastResult,
                results,
                numFailures
              } = _ref7;
              if (numFailures) throw new ModifyError("Could not delete some values", Object.keys(failures).map(pos => failures[pos]), count - numFailures);
              return count - numFailures;
            });
          });
        });
      }

      return this.modify(deleteCallback);
    }
  }]);

  return Collection;
}();

const deleteCallback = (value, ctx) => ctx.value = null;

function createCollectionConstructor(db) {
  return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {
    this.db = db;
    let keyRange = AnyRange,
        error = null;
    if (keyRangeGenerator) try {
      keyRange = keyRangeGenerator();
    } catch (ex) {
      error = ex;
    }
    const whereCtx = whereClause._ctx;
    const table = whereCtx.table;
    const readingHook = table.hook.reading.fire;
    this._ctx = {
      table: table,
      index: whereCtx.index,
      isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,
      range: keyRange,
      keysOnly: false,
      dir: "next",
      unique: "",
      algorithm: null,
      filter: null,
      replayFilter: null,
      justLimit: true,
      isMatch: null,
      offset: 0,
      limit: Infinity,
      error: error,
      or: whereCtx.or,
      valueMapper: readingHook !== mirror ? readingHook : null
    };
  });
}

function simpleCompare(a, b) {
  return a < b ? -1 : a === b ? 0 : 1;
}

function simpleCompareReverse(a, b) {
  return a > b ? -1 : a === b ? 0 : 1;
}

function fail(collectionOrWhereClause, err, T) {
  var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;
  collection._ctx.error = T ? new T(err) : new TypeError(err);
  return collection;
}

function emptyCollection(whereClause) {
  return new whereClause.Collection(whereClause, () => rangeEqual("")).limit(0);
}

function upperFactory(dir) {
  return dir === "next" ? s => s.toUpperCase() : s => s.toLowerCase();
}

function lowerFactory(dir) {
  return dir === "next" ? s => s.toLowerCase() : s => s.toUpperCase();
}

function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {
  var length = Math.min(key.length, lowerNeedle.length);
  var llp = -1;

  for (var i = 0; i < length; ++i) {
    var lwrKeyChar = lowerKey[i];

    if (lwrKeyChar !== lowerNeedle[i]) {
      if (cmp(key[i], upperNeedle[i]) < 0) return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
      if (cmp(key[i], lowerNeedle[i]) < 0) return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
      if (llp >= 0) return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
      return null;
    }

    if (cmp(key[i], lwrKeyChar) < 0) llp = i;
  }

  if (length < lowerNeedle.length && dir === "next") return key + upperNeedle.substr(key.length);
  if (length < key.length && dir === "prev") return key.substr(0, upperNeedle.length);
  return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);
}

function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {
  var upper,
      lower,
      compare,
      upperNeedles,
      lowerNeedles,
      direction,
      nextKeySuffix,
      needlesLen = needles.length;

  if (!needles.every(s => typeof s === 'string')) {
    return fail(whereClause, STRING_EXPECTED);
  }

  function initDirection(dir) {
    upper = upperFactory(dir);
    lower = lowerFactory(dir);
    compare = dir === "next" ? simpleCompare : simpleCompareReverse;
    var needleBounds = needles.map(function (needle) {
      return {
        lower: lower(needle),
        upper: upper(needle)
      };
    }).sort(function (a, b) {
      return compare(a.lower, b.lower);
    });
    upperNeedles = needleBounds.map(function (nb) {
      return nb.upper;
    });
    lowerNeedles = needleBounds.map(function (nb) {
      return nb.lower;
    });
    direction = dir;
    nextKeySuffix = dir === "next" ? "" : suffix;
  }

  initDirection("next");
  var c = new whereClause.Collection(whereClause, () => createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));

  c._ondirectionchange = function (direction) {
    initDirection(direction);
  };

  var firstPossibleNeedle = 0;

  c._addAlgorithm(function (cursor, advance, resolve) {
    var key = cursor.key;
    if (typeof key !== 'string') return false;
    var lowerKey = lower(key);

    if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {
      return true;
    } else {
      var lowestPossibleCasing = null;

      for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
        var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
        if (casing === null && lowestPossibleCasing === null) firstPossibleNeedle = i + 1;else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
          lowestPossibleCasing = casing;
        }
      }

      if (lowestPossibleCasing !== null) {
        advance(function () {
          cursor.continue(lowestPossibleCasing + nextKeySuffix);
        });
      } else {
        advance(resolve);
      }

      return false;
    }
  });

  return c;
}

function createRange(lower, upper, lowerOpen, upperOpen) {
  return {
    type: 2,
    lower,
    upper,
    lowerOpen,
    upperOpen
  };
}

function rangeEqual(value) {
  return {
    type: 1,
    lower: value,
    upper: value
  };
}

let WhereClause = /*#__PURE__*/function () {
  function WhereClause() {
    _classCallCheck(this, WhereClause);
  }

  _createClass(WhereClause, [{
    key: "Collection",
    get: function () {
      return this._ctx.table.db.Collection;
    }
  }, {
    key: "between",
    value: function between(lower, upper, includeLower, includeUpper) {
      includeLower = includeLower !== false;
      includeUpper = includeUpper === true;

      try {
        if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)) return emptyCollection(this);
        return new this.Collection(this, () => createRange(lower, upper, !includeLower, !includeUpper));
      } catch (e) {
        return fail(this, INVALID_KEY_ARGUMENT);
      }
    }
  }, {
    key: "equals",
    value: function equals(value) {
      if (value == null) return fail(this, INVALID_KEY_ARGUMENT);
      return new this.Collection(this, () => rangeEqual(value));
    }
  }, {
    key: "above",
    value: function above(value) {
      if (value == null) return fail(this, INVALID_KEY_ARGUMENT);
      return new this.Collection(this, () => createRange(value, undefined, true));
    }
  }, {
    key: "aboveOrEqual",
    value: function aboveOrEqual(value) {
      if (value == null) return fail(this, INVALID_KEY_ARGUMENT);
      return new this.Collection(this, () => createRange(value, undefined, false));
    }
  }, {
    key: "below",
    value: function below(value) {
      if (value == null) return fail(this, INVALID_KEY_ARGUMENT);
      return new this.Collection(this, () => createRange(undefined, value, false, true));
    }
  }, {
    key: "belowOrEqual",
    value: function belowOrEqual(value) {
      if (value == null) return fail(this, INVALID_KEY_ARGUMENT);
      return new this.Collection(this, () => createRange(undefined, value));
    }
  }, {
    key: "startsWith",
    value: function startsWith(str) {
      if (typeof str !== 'string') return fail(this, STRING_EXPECTED);
      return this.between(str, str + maxString, true, true);
    }
  }, {
    key: "startsWithIgnoreCase",
    value: function startsWithIgnoreCase(str) {
      if (str === "") return this.startsWith(str);
      return addIgnoreCaseAlgorithm(this, (x, a) => x.indexOf(a[0]) === 0, [str], maxString);
    }
  }, {
    key: "equalsIgnoreCase",
    value: function equalsIgnoreCase(str) {
      return addIgnoreCaseAlgorithm(this, (x, a) => x === a[0], [str], "");
    }
  }, {
    key: "anyOfIgnoreCase",
    value: function anyOfIgnoreCase() {
      var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
      if (set.length === 0) return emptyCollection(this);
      return addIgnoreCaseAlgorithm(this, (x, a) => a.indexOf(x) !== -1, set, "");
    }
  }, {
    key: "startsWithAnyOfIgnoreCase",
    value: function startsWithAnyOfIgnoreCase() {
      var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
      if (set.length === 0) return emptyCollection(this);
      return addIgnoreCaseAlgorithm(this, (x, a) => a.some(n => x.indexOf(n) === 0), set, maxString);
    }
  }, {
    key: "anyOf",
    value: function anyOf() {
      const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
      let compare = this._cmp;

      try {
        set.sort(compare);
      } catch (e) {
        return fail(this, INVALID_KEY_ARGUMENT);
      }

      if (set.length === 0) return emptyCollection(this);
      const c = new this.Collection(this, () => createRange(set[0], set[set.length - 1]));

      c._ondirectionchange = direction => {
        compare = direction === "next" ? this._ascending : this._descending;
        set.sort(compare);
      };

      let i = 0;

      c._addAlgorithm((cursor, advance, resolve) => {
        const key = cursor.key;

        while (compare(key, set[i]) > 0) {
          ++i;

          if (i === set.length) {
            advance(resolve);
            return false;
          }
        }

        if (compare(key, set[i]) === 0) {
          return true;
        } else {
          advance(() => {
            cursor.continue(set[i]);
          });
          return false;
        }
      });

      return c;
    }
  }, {
    key: "notEqual",
    value: function notEqual(value) {
      return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], {
        includeLowers: false,
        includeUppers: false
      });
    }
  }, {
    key: "noneOf",
    value: function noneOf() {
      const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
      if (set.length === 0) return new this.Collection(this);

      try {
        set.sort(this._ascending);
      } catch (e) {
        return fail(this, INVALID_KEY_ARGUMENT);
      }

      const ranges = set.reduce((res, val) => res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]], null);
      ranges.push([set[set.length - 1], this.db._maxKey]);
      return this.inAnyRange(ranges, {
        includeLowers: false,
        includeUppers: false
      });
    }
  }, {
    key: "inAnyRange",
    value: function inAnyRange(ranges, options) {
      const cmp = this._cmp,
            ascending = this._ascending,
            descending = this._descending,
            min = this._min,
            max = this._max;
      if (ranges.length === 0) return emptyCollection(this);

      if (!ranges.every(range => range[0] !== undefined && range[1] !== undefined && ascending(range[0], range[1]) <= 0)) {
        return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
      }

      const includeLowers = !options || options.includeLowers !== false;
      const includeUppers = options && options.includeUppers === true;

      function addRange(ranges, newRange) {
        let i = 0,
            l = ranges.length;

        for (; i < l; ++i) {
          const range = ranges[i];

          if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {
            range[0] = min(range[0], newRange[0]);
            range[1] = max(range[1], newRange[1]);
            break;
          }
        }

        if (i === l) ranges.push(newRange);
        return ranges;
      }

      let sortDirection = ascending;

      function rangeSorter(a, b) {
        return sortDirection(a[0], b[0]);
      }

      let set;

      try {
        set = ranges.reduce(addRange, []);
        set.sort(rangeSorter);
      } catch (ex) {
        return fail(this, INVALID_KEY_ARGUMENT);
      }

      let rangePos = 0;
      const keyIsBeyondCurrentEntry = includeUppers ? key => ascending(key, set[rangePos][1]) > 0 : key => ascending(key, set[rangePos][1]) >= 0;
      const keyIsBeforeCurrentEntry = includeLowers ? key => descending(key, set[rangePos][0]) > 0 : key => descending(key, set[rangePos][0]) >= 0;

      function keyWithinCurrentRange(key) {
        return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
      }

      let checkKey = keyIsBeyondCurrentEntry;
      const c = new this.Collection(this, () => createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));

      c._ondirectionchange = direction => {
        if (direction === "next") {
          checkKey = keyIsBeyondCurrentEntry;
          sortDirection = ascending;
        } else {
          checkKey = keyIsBeforeCurrentEntry;
          sortDirection = descending;
        }

        set.sort(rangeSorter);
      };

      c._addAlgorithm((cursor, advance, resolve) => {
        var key = cursor.key;

        while (checkKey(key)) {
          ++rangePos;

          if (rangePos === set.length) {
            advance(resolve);
            return false;
          }
        }

        if (keyWithinCurrentRange(key)) {
          return true;
        } else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {
          return false;
        } else {
          advance(() => {
            if (sortDirection === ascending) cursor.continue(set[rangePos][0]);else cursor.continue(set[rangePos][1]);
          });
          return false;
        }
      });

      return c;
    }
  }, {
    key: "startsWithAnyOf",
    value: function startsWithAnyOf() {
      const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);

      if (!set.every(s => typeof s === 'string')) {
        return fail(this, "startsWithAnyOf() only works with strings");
      }

      if (set.length === 0) return emptyCollection(this);
      return this.inAnyRange(set.map(str => [str, str + maxString]));
    }
  }]);

  return WhereClause;
}();

function createWhereClauseConstructor(db) {
  return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {
    this.db = db;
    this._ctx = {
      table: table,
      index: index === ":id" ? null : index,
      or: orCollection
    };
    const indexedDB = db._deps.indexedDB;
    if (!indexedDB) throw new exceptions.MissingAPI();
    this._cmp = this._ascending = indexedDB.cmp.bind(indexedDB);

    this._descending = (a, b) => indexedDB.cmp(b, a);

    this._max = (a, b) => indexedDB.cmp(a, b) > 0 ? a : b;

    this._min = (a, b) => indexedDB.cmp(a, b) < 0 ? a : b;

    this._IDBKeyRange = db._deps.IDBKeyRange;
  });
}

function eventRejectHandler(reject) {
  return wrap(function (event) {
    preventDefault(event);
    reject(event.target.error);
    return false;
  });
}

function preventDefault(event) {
  if (event.stopPropagation) event.stopPropagation();
  if (event.preventDefault) event.preventDefault();
}

const DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';
const STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';
const globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);

let Transaction = /*#__PURE__*/function () {
  function Transaction() {
    _classCallCheck(this, Transaction);
  }

  _createClass(Transaction, [{
    key: "_lock",
    value: function _lock() {
      assert(!PSD.global);
      ++this._reculock;
      if (this._reculock === 1 && !PSD.global) PSD.lockOwnerFor = this;
      return this;
    }
  }, {
    key: "_unlock",
    value: function _unlock() {
      assert(!PSD.global);

      if (--this._reculock === 0) {
        if (!PSD.global) PSD.lockOwnerFor = null;

        while (this._blockedFuncs.length > 0 && !this._locked()) {
          var fnAndPSD = this._blockedFuncs.shift();

          try {
            usePSD(fnAndPSD[1], fnAndPSD[0]);
          } catch (e) {}
        }
      }

      return this;
    }
  }, {
    key: "_locked",
    value: function _locked() {
      return this._reculock && PSD.lockOwnerFor !== this;
    }
  }, {
    key: "create",
    value: function create(idbtrans) {
      if (!this.mode) return this;
      const idbdb = this.db.idbdb;
      const dbOpenError = this.db._state.dbOpenError;
      assert(!this.idbtrans);

      if (!idbtrans && !idbdb) {
        switch (dbOpenError && dbOpenError.name) {
          case "DatabaseClosedError":
            throw new exceptions.DatabaseClosed(dbOpenError);

          case "MissingAPIError":
            throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);

          default:
            throw new exceptions.OpenFailed(dbOpenError);
        }
      }

      if (!this.active) throw new exceptions.TransactionInactive();
      assert(this._completion._state === null);
      idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, {
        durability: this.chromeTransactionDurability
      }) : idbdb.transaction(this.storeNames, this.mode, {
        durability: this.chromeTransactionDurability
      }));
      idbtrans.onerror = wrap(ev => {
        preventDefault(ev);

        this._reject(idbtrans.error);
      });
      idbtrans.onabort = wrap(ev => {
        preventDefault(ev);
        this.active && this._reject(new exceptions.Abort(idbtrans.error));
        this.active = false;
        this.on("abort").fire(ev);
      });
      idbtrans.oncomplete = wrap(() => {
        this.active = false;

        this._resolve();

        if ('mutatedParts' in idbtrans) {
          globalEvents.storagemutated.fire(idbtrans["mutatedParts"]);
        }
      });
      return this;
    }
  }, {
    key: "_promise",
    value: function _promise(mode, fn, bWriteLock) {
      if (mode === 'readwrite' && this.mode !== 'readwrite') return rejection(new exceptions.ReadOnly("Transaction is readonly"));
      if (!this.active) return rejection(new exceptions.TransactionInactive());

      if (this._locked()) {
        return new DexiePromise((resolve, reject) => {
          this._blockedFuncs.push([() => {
            this._promise(mode, fn, bWriteLock).then(resolve, reject);
          }, PSD]);
        });
      } else if (bWriteLock) {
        return newScope(() => {
          var p = new DexiePromise((resolve, reject) => {
            this._lock();

            const rv = fn(resolve, reject, this);
            if (rv && rv.then) rv.then(resolve, reject);
          });
          p.finally(() => this._unlock());
          p._lib = true;
          return p;
        });
      } else {
        var p = new DexiePromise((resolve, reject) => {
          var rv = fn(resolve, reject, this);
          if (rv && rv.then) rv.then(resolve, reject);
        });
        p._lib = true;
        return p;
      }
    }
  }, {
    key: "_root",
    value: function _root() {
      return this.parent ? this.parent._root() : this;
    }
  }, {
    key: "waitFor",
    value: function waitFor(promiseLike) {
      var root = this._root();

      const promise = DexiePromise.resolve(promiseLike);

      if (root._waitingFor) {
        root._waitingFor = root._waitingFor.then(() => promise);
      } else {
        root._waitingFor = promise;
        root._waitingQueue = [];
        var store = root.idbtrans.objectStore(root.storeNames[0]);

        (function spin() {
          ++root._spinCount;

          while (root._waitingQueue.length) root._waitingQueue.shift()();

          if (root._waitingFor) store.get(-Infinity).onsuccess = spin;
        })();
      }

      var currentWaitPromise = root._waitingFor;
      return new DexiePromise((resolve, reject) => {
        promise.then(res => root._waitingQueue.push(wrap(resolve.bind(null, res))), err => root._waitingQueue.push(wrap(reject.bind(null, err)))).finally(() => {
          if (root._waitingFor === currentWaitPromise) {
            root._waitingFor = null;
          }
        });
      });
    }
  }, {
    key: "abort",
    value: function abort() {
      if (this.active) {
        this.active = false;
        if (this.idbtrans) this.idbtrans.abort();

        this._reject(new exceptions.Abort());
      }
    }
  }, {
    key: "table",
    value: function table(tableName) {
      const memoizedTables = this._memoizedTables || (this._memoizedTables = {});
      if (hasOwn(memoizedTables, tableName)) return memoizedTables[tableName];
      const tableSchema = this.schema[tableName];

      if (!tableSchema) {
        throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
      }

      const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
      transactionBoundTable.core = this.db.core.table(tableName);
      memoizedTables[tableName] = transactionBoundTable;
      return transactionBoundTable;
    }
  }]);

  return Transaction;
}();

function createTransactionConstructor(db) {
  return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {
    this.db = db;
    this.mode = mode;
    this.storeNames = storeNames;
    this.schema = dbschema;
    this.chromeTransactionDurability = chromeTransactionDurability;
    this.idbtrans = null;
    this.on = Events(this, "complete", "error", "abort");
    this.parent = parent || null;
    this.active = true;
    this._reculock = 0;
    this._blockedFuncs = [];
    this._resolve = null;
    this._reject = null;
    this._waitingFor = null;
    this._waitingQueue = null;
    this._spinCount = 0;
    this._completion = new DexiePromise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });

    this._completion.then(() => {
      this.active = false;
      this.on.complete.fire();
    }, e => {
      var wasActive = this.active;
      this.active = false;
      this.on.error.fire(e);
      this.parent ? this.parent._reject(e) : wasActive && this.idbtrans && this.idbtrans.abort();
      return rejection(e);
    });
  });
}

function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {
  return {
    name,
    keyPath,
    unique,
    multi,
    auto,
    compound,
    src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? "++" : "") + nameFromKeyPath(keyPath)
  };
}

function nameFromKeyPath(keyPath) {
  return typeof keyPath === 'string' ? keyPath : keyPath ? '[' + [].join.call(keyPath, '+') + ']' : "";
}

function createTableSchema(name, primKey, indexes) {
  return {
    name,
    primKey,
    indexes,
    mappedClass: null,
    idxByName: arrayToObject(indexes, index => [index.name, index])
  };
}

function safariMultiStoreFix(storeNames) {
  return storeNames.length === 1 ? storeNames[0] : storeNames;
}

let getMaxKey = IdbKeyRange => {
  try {
    IdbKeyRange.only([[]]);

    getMaxKey = () => [[]];

    return [[]];
  } catch (e) {
    getMaxKey = () => maxString;

    return maxString;
  }
};

function getKeyExtractor(keyPath) {
  if (keyPath == null) {
    return () => undefined;
  } else if (typeof keyPath === 'string') {
    return getSinglePathKeyExtractor(keyPath);
  } else {
    return obj => getByKeyPath(obj, keyPath);
  }
}

function getSinglePathKeyExtractor(keyPath) {
  const split = keyPath.split('.');

  if (split.length === 1) {
    return obj => obj[keyPath];
  } else {
    return obj => getByKeyPath(obj, keyPath);
  }
}

function arrayify(arrayLike) {
  return [].slice.call(arrayLike);
}

let _id_counter = 0;

function getKeyPathAlias(keyPath) {
  return keyPath == null ? ":id" : typeof keyPath === 'string' ? keyPath : "[".concat(keyPath.join('+'), "]");
}

function createDBCore(db, IdbKeyRange, tmpTrans) {
  function extractSchema(db, trans) {
    const tables = arrayify(db.objectStoreNames);
    return {
      schema: {
        name: db.name,
        tables: tables.map(table => trans.objectStore(table)).map(store => {
          const {
            keyPath,
            autoIncrement
          } = store;
          const compound = isArray(keyPath);
          const outbound = keyPath == null;
          const indexByKeyPath = {};
          const result = {
            name: store.name,
            primaryKey: {
              name: null,
              isPrimaryKey: true,
              outbound,
              compound,
              keyPath,
              autoIncrement,
              unique: true,
              extractKey: getKeyExtractor(keyPath)
            },
            indexes: arrayify(store.indexNames).map(indexName => store.index(indexName)).map(index => {
              const {
                name,
                unique,
                multiEntry,
                keyPath
              } = index;
              const compound = isArray(keyPath);
              const result = {
                name,
                compound,
                keyPath,
                unique,
                multiEntry,
                extractKey: getKeyExtractor(keyPath)
              };
              indexByKeyPath[getKeyPathAlias(keyPath)] = result;
              return result;
            }),
            getIndexByKeyPath: keyPath => indexByKeyPath[getKeyPathAlias(keyPath)]
          };
          indexByKeyPath[":id"] = result.primaryKey;

          if (keyPath != null) {
            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;
          }

          return result;
        })
      },
      hasGetAll: tables.length > 0 && 'getAll' in trans.objectStore(tables[0]) && !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
    };
  }

  function makeIDBKeyRange(range) {
    if (range.type === 3) return null;
    if (range.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
    const {
      lower,
      upper,
      lowerOpen,
      upperOpen
    } = range;
    const idbRange = lower === undefined ? upper === undefined ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === undefined ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
    return idbRange;
  }

  function createDbCoreTable(tableSchema) {
    const tableName = tableSchema.name;

    function mutate(_ref8) {
      let {
        trans,
        type,
        keys,
        values,
        range
      } = _ref8;
      return new Promise((resolve, reject) => {
        resolve = wrap(resolve);
        const store = trans.objectStore(tableName);
        const outbound = store.keyPath == null;
        const isAddOrPut = type === "put" || type === "add";
        if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange') throw new Error("Invalid operation type: " + type);
        const {
          length
        } = keys || values || {
          length: 1
        };

        if (keys && values && keys.length !== values.length) {
          throw new Error("Given keys array must have same length as given values array.");
        }

        if (length === 0) return resolve({
          numFailures: 0,
          failures: {},
          results: [],
          lastResult: undefined
        });
        let req;
        const reqs = [];
        const failures = [];
        let numFailures = 0;

        const errorHandler = event => {
          ++numFailures;
          preventDefault(event);
        };

        if (type === 'deleteRange') {
          if (range.type === 4) return resolve({
            numFailures,
            failures,
            results: [],
            lastResult: undefined
          });
          if (range.type === 3) reqs.push(req = store.clear());else reqs.push(req = store.delete(makeIDBKeyRange(range)));
        } else {
          const [args1, args2] = isAddOrPut ? outbound ? [values, keys] : [values, null] : [keys, null];

          if (isAddOrPut) {
            for (let i = 0; i < length; ++i) {
              reqs.push(req = args2 && args2[i] !== undefined ? store[type](args1[i], args2[i]) : store[type](args1[i]));
              req.onerror = errorHandler;
            }
          } else {
            for (let i = 0; i < length; ++i) {
              reqs.push(req = store[type](args1[i]));
              req.onerror = errorHandler;
            }
          }
        }

        const done = event => {
          const lastResult = event.target.result;
          reqs.forEach((req, i) => req.error != null && (failures[i] = req.error));
          resolve({
            numFailures,
            failures,
            results: type === "delete" ? keys : reqs.map(req => req.result),
            lastResult
          });
        };

        req.onerror = event => {
          errorHandler(event);
          done(event);
        };

        req.onsuccess = done;
      });
    }

    function openCursor(_ref9) {
      let {
        trans,
        values,
        query,
        reverse,
        unique
      } = _ref9;
      return new Promise((resolve, reject) => {
        resolve = wrap(resolve);
        const {
          index,
          range
        } = query;
        const store = trans.objectStore(tableName);
        const source = index.isPrimaryKey ? store : store.index(index.name);
        const direction = reverse ? unique ? "prevunique" : "prev" : unique ? "nextunique" : "next";
        const req = values || !('openKeyCursor' in source) ? source.openCursor(makeIDBKeyRange(range), direction) : source.openKeyCursor(makeIDBKeyRange(range), direction);
        req.onerror = eventRejectHandler(reject);
        req.onsuccess = wrap(ev => {
          const cursor = req.result;

          if (!cursor) {
            resolve(null);
            return;
          }

          cursor.___id = ++_id_counter;
          cursor.done = false;

          const _cursorContinue = cursor.continue.bind(cursor);

          let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;
          if (_cursorContinuePrimaryKey) _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);

          const _cursorAdvance = cursor.advance.bind(cursor);

          const doThrowCursorIsNotStarted = () => {
            throw new Error("Cursor not started");
          };

          const doThrowCursorIsStopped = () => {
            throw new Error("Cursor not stopped");
          };

          cursor.trans = trans;
          cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;
          cursor.fail = wrap(reject);

          cursor.next = function () {
            let gotOne = 1;
            return this.start(() => gotOne-- ? this.continue() : this.stop()).then(() => this);
          };

          cursor.start = callback => {
            const iterationPromise = new Promise((resolveIteration, rejectIteration) => {
              resolveIteration = wrap(resolveIteration);
              req.onerror = eventRejectHandler(rejectIteration);
              cursor.fail = rejectIteration;

              cursor.stop = value => {
                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;
                resolveIteration(value);
              };
            });

            const guardedCallback = () => {
              if (req.result) {
                try {
                  callback();
                } catch (err) {
                  cursor.fail(err);
                }
              } else {
                cursor.done = true;

                cursor.start = () => {
                  throw new Error("Cursor behind last entry");
                };

                cursor.stop();
              }
            };

            req.onsuccess = wrap(ev => {
              req.onsuccess = guardedCallback;
              guardedCallback();
            });
            cursor.continue = _cursorContinue;
            cursor.continuePrimaryKey = _cursorContinuePrimaryKey;
            cursor.advance = _cursorAdvance;
            guardedCallback();
            return iterationPromise;
          };

          resolve(cursor);
        }, reject);
      });
    }

    function query(hasGetAll) {
      return request => {
        return new Promise((resolve, reject) => {
          resolve = wrap(resolve);
          const {
            trans,
            values,
            limit,
            query
          } = request;
          const nonInfinitLimit = limit === Infinity ? undefined : limit;
          const {
            index,
            range
          } = query;
          const store = trans.objectStore(tableName);
          const source = index.isPrimaryKey ? store : store.index(index.name);
          const idbKeyRange = makeIDBKeyRange(range);
          if (limit === 0) return resolve({
            result: []
          });

          if (hasGetAll) {
            const req = values ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);

            req.onsuccess = event => resolve({
              result: event.target.result
            });

            req.onerror = eventRejectHandler(reject);
          } else {
            let count = 0;
            const req = values || !('openKeyCursor' in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);
            const result = [];

            req.onsuccess = event => {
              const cursor = req.result;
              if (!cursor) return resolve({
                result
              });
              result.push(values ? cursor.value : cursor.primaryKey);
              if (++count === limit) return resolve({
                result
              });
              cursor.continue();
            };

            req.onerror = eventRejectHandler(reject);
          }
        });
      };
    }

    return {
      name: tableName,
      schema: tableSchema,
      mutate,

      getMany(_ref10) {
        let {
          trans,
          keys
        } = _ref10;
        return new Promise((resolve, reject) => {
          resolve = wrap(resolve);
          const store = trans.objectStore(tableName);
          const length = keys.length;
          const result = new Array(length);
          let keyCount = 0;
          let callbackCount = 0;
          let req;

          const successHandler = event => {
            const req = event.target;
            if ((result[req._pos] = req.result) != null) ;
            if (++callbackCount === keyCount) resolve(result);
          };

          const errorHandler = eventRejectHandler(reject);

          for (let i = 0; i < length; ++i) {
            const key = keys[i];

            if (key != null) {
              req = store.get(keys[i]);
              req._pos = i;
              req.onsuccess = successHandler;
              req.onerror = errorHandler;
              ++keyCount;
            }
          }

          if (keyCount === 0) resolve(result);
        });
      },

      get(_ref11) {
        let {
          trans,
          key
        } = _ref11;
        return new Promise((resolve, reject) => {
          resolve = wrap(resolve);
          const store = trans.objectStore(tableName);
          const req = store.get(key);

          req.onsuccess = event => resolve(event.target.result);

          req.onerror = eventRejectHandler(reject);
        });
      },

      query: query(hasGetAll),
      openCursor,

      count(_ref12) {
        let {
          query,
          trans
        } = _ref12;
        const {
          index,
          range
        } = query;
        return new Promise((resolve, reject) => {
          const store = trans.objectStore(tableName);
          const source = index.isPrimaryKey ? store : store.index(index.name);
          const idbKeyRange = makeIDBKeyRange(range);
          const req = idbKeyRange ? source.count(idbKeyRange) : source.count();
          req.onsuccess = wrap(ev => resolve(ev.target.result));
          req.onerror = eventRejectHandler(reject);
        });
      }

    };
  }

  const {
    schema,
    hasGetAll
  } = extractSchema(db, tmpTrans);
  const tables = schema.tables.map(tableSchema => createDbCoreTable(tableSchema));
  const tableMap = {};
  tables.forEach(table => tableMap[table.name] = table);
  return {
    stack: "dbcore",
    transaction: db.transaction.bind(db),

    table(name) {
      const result = tableMap[name];
      if (!result) throw new Error("Table '".concat(name, "' not found"));
      return tableMap[name];
    },

    MIN_KEY: -Infinity,
    MAX_KEY: getMaxKey(IdbKeyRange),
    schema
  };
}

function createMiddlewareStack(stackImpl, middlewares) {
  return middlewares.reduce((down, _ref13) => {
    let {
      create
    } = _ref13;
    return _objectSpread(_objectSpread({}, down), create(down));
  }, stackImpl);
}

function createMiddlewareStacks(middlewares, idbdb, _ref14, tmpTrans) {
  let {
    IDBKeyRange,
    indexedDB
  } = _ref14;
  const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);
  return {
    dbcore
  };
}

function generateMiddlewareStacks(_ref15, tmpTrans) {
  let {
    _novip: db
  } = _ref15;
  const idbdb = tmpTrans.db;
  const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);
  db.core = stacks.dbcore;
  db.tables.forEach(table => {
    const tableName = table.name;

    if (db.core.schema.tables.some(tbl => tbl.name === tableName)) {
      table.core = db.core.table(tableName);

      if (db[tableName] instanceof db.Table) {
        db[tableName].core = table.core;
      }
    }
  });
}

function setApiOnPlace(_ref16, objs, tableNames, dbschema) {
  let {
    _novip: db
  } = _ref16;
  tableNames.forEach(tableName => {
    const schema = dbschema[tableName];
    objs.forEach(obj => {
      const propDesc = getPropertyDescriptor(obj, tableName);

      if (!propDesc || "value" in propDesc && propDesc.value === undefined) {
        if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {
          setProp(obj, tableName, {
            get() {
              return this.table(tableName);
            },

            set(value) {
              defineProperty(this, tableName, {
                value,
                writable: true,
                configurable: true,
                enumerable: true
              });
            }

          });
        } else {
          obj[tableName] = new db.Table(tableName, schema);
        }
      }
    });
  });
}

function removeTablesApi(_ref17, objs) {
  let {
    _novip: db
  } = _ref17;
  objs.forEach(obj => {
    for (let key in obj) {
      if (obj[key] instanceof db.Table) delete obj[key];
    }
  });
}

function lowerVersionFirst(a, b) {
  return a._cfg.version - b._cfg.version;
}

function runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {
  const globalSchema = db._dbSchema;

  const trans = db._createTransaction('readwrite', db._storeNames, globalSchema);

  trans.create(idbUpgradeTrans);

  trans._completion.catch(reject);

  const rejectTransaction = trans._reject.bind(trans);

  const transless = PSD.transless || PSD;
  newScope(() => {
    PSD.trans = trans;
    PSD.transless = transless;

    if (oldVersion === 0) {
      keys(globalSchema).forEach(tableName => {
        createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
      });
      generateMiddlewareStacks(db, idbUpgradeTrans);
      DexiePromise.follow(() => db.on.populate.fire(trans)).catch(rejectTransaction);
    } else updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);
  });
}

function updateTablesAndIndexes(_ref18, oldVersion, trans, idbUpgradeTrans) {
  let {
    _novip: db
  } = _ref18;
  const queue = [];
  const versions = db._versions;
  let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);
  let anyContentUpgraderHasRun = false;
  const versToRun = versions.filter(v => v._cfg.version >= oldVersion);
  versToRun.forEach(version => {
    queue.push(() => {
      const oldSchema = globalSchema;
      const newSchema = version._cfg.dbschema;
      adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);
      adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);
      globalSchema = db._dbSchema = newSchema;
      const diff = getSchemaDiff(oldSchema, newSchema);
      diff.add.forEach(tuple => {
        createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
      });
      diff.change.forEach(change => {
        if (change.recreate) {
          throw new exceptions.Upgrade("Not yet support for changing primary key");
        } else {
          const store = idbUpgradeTrans.objectStore(change.name);
          change.add.forEach(idx => addIndex(store, idx));
          change.change.forEach(idx => {
            store.deleteIndex(idx.name);
            addIndex(store, idx);
          });
          change.del.forEach(idxName => store.deleteIndex(idxName));
        }
      });
      const contentUpgrade = version._cfg.contentUpgrade;

      if (contentUpgrade && version._cfg.version > oldVersion) {
        generateMiddlewareStacks(db, idbUpgradeTrans);
        trans._memoizedTables = {};
        anyContentUpgraderHasRun = true;
        let upgradeSchema = shallowClone(newSchema);
        diff.del.forEach(table => {
          upgradeSchema[table] = oldSchema[table];
        });
        removeTablesApi(db, [db.Transaction.prototype]);
        setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema), upgradeSchema);
        trans.schema = upgradeSchema;
        const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);

        if (contentUpgradeIsAsync) {
          incrementExpectedAwaits();
        }

        let returnValue;
        const promiseFollowed = DexiePromise.follow(() => {
          returnValue = contentUpgrade(trans);

          if (returnValue) {
            if (contentUpgradeIsAsync) {
              var decrementor = decrementExpectedAwaits.bind(null, null);
              returnValue.then(decrementor, decrementor);
            }
          }
        });
        return returnValue && typeof returnValue.then === 'function' ? DexiePromise.resolve(returnValue) : promiseFollowed.then(() => returnValue);
      }
    });
    queue.push(idbtrans => {
      if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {
        const newSchema = version._cfg.dbschema;
        deleteRemovedTables(newSchema, idbtrans);
      }

      removeTablesApi(db, [db.Transaction.prototype]);
      setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);
      trans.schema = db._dbSchema;
    });
  });

  function runQueue() {
    return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();
  }

  return runQueue().then(() => {
    createMissingTables(globalSchema, idbUpgradeTrans);
  });
}

function getSchemaDiff(oldSchema, newSchema) {
  const diff = {
    del: [],
    add: [],
    change: []
  };
  let table;

  for (table in oldSchema) {
    if (!newSchema[table]) diff.del.push(table);
  }

  for (table in newSchema) {
    const oldDef = oldSchema[table],
          newDef = newSchema[table];

    if (!oldDef) {
      diff.add.push([table, newDef]);
    } else {
      const change = {
        name: table,
        def: newDef,
        recreate: false,
        del: [],
        add: [],
        change: []
      };

      if ('' + (oldDef.primKey.keyPath || '') !== '' + (newDef.primKey.keyPath || '') || oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge) {
        change.recreate = true;
        diff.change.push(change);
      } else {
        const oldIndexes = oldDef.idxByName;
        const newIndexes = newDef.idxByName;
        let idxName;

        for (idxName in oldIndexes) {
          if (!newIndexes[idxName]) change.del.push(idxName);
        }

        for (idxName in newIndexes) {
          const oldIdx = oldIndexes[idxName],
                newIdx = newIndexes[idxName];
          if (!oldIdx) change.add.push(newIdx);else if (oldIdx.src !== newIdx.src) change.change.push(newIdx);
        }

        if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
          diff.change.push(change);
        }
      }
    }
  }

  return diff;
}

function createTable(idbtrans, tableName, primKey, indexes) {
  const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? {
    keyPath: primKey.keyPath,
    autoIncrement: primKey.auto
  } : {
    autoIncrement: primKey.auto
  });
  indexes.forEach(idx => addIndex(store, idx));
  return store;
}

function createMissingTables(newSchema, idbtrans) {
  keys(newSchema).forEach(tableName => {
    if (!idbtrans.db.objectStoreNames.contains(tableName)) {
      createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
    }
  });
}

function deleteRemovedTables(newSchema, idbtrans) {
  [].slice.call(idbtrans.db.objectStoreNames).forEach(storeName => newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));
}

function addIndex(store, idx) {
  store.createIndex(idx.name, idx.keyPath, {
    unique: idx.unique,
    multiEntry: idx.multi
  });
}

function buildGlobalSchema(db, idbdb, tmpTrans) {
  const globalSchema = {};
  const dbStoreNames = slice(idbdb.objectStoreNames, 0);
  dbStoreNames.forEach(storeName => {
    const store = tmpTrans.objectStore(storeName);
    let keyPath = store.keyPath;
    const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
    const indexes = [];

    for (let j = 0; j < store.indexNames.length; ++j) {
      const idbindex = store.index(store.indexNames[j]);
      keyPath = idbindex.keyPath;
      var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
      indexes.push(index);
    }

    globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
  });
  return globalSchema;
}

function readGlobalSchema(_ref19, idbdb, tmpTrans) {
  let {
    _novip: db
  } = _ref19;
  db.verno = idbdb.version / 10;
  const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);
  db._storeNames = slice(idbdb.objectStoreNames, 0);
  setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);
}

function verifyInstalledSchema(db, tmpTrans) {
  const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);
  const diff = getSchemaDiff(installedSchema, db._dbSchema);
  return !(diff.add.length || diff.change.some(ch => ch.add.length || ch.change.length));
}

function adjustToExistingIndexNames(_ref20, schema, idbtrans) {
  let {
    _novip: db
  } = _ref20;
  const storeNames = idbtrans.db.objectStoreNames;

  for (let i = 0; i < storeNames.length; ++i) {
    const storeName = storeNames[i];
    const store = idbtrans.objectStore(storeName);
    db._hasGetAll = 'getAll' in store;

    for (let j = 0; j < store.indexNames.length; ++j) {
      const indexName = store.indexNames[j];
      const keyPath = store.index(indexName).keyPath;
      const dexieName = typeof keyPath === 'string' ? keyPath : "[" + slice(keyPath).join('+') + "]";

      if (schema[storeName]) {
        const indexSpec = schema[storeName].idxByName[dexieName];

        if (indexSpec) {
          indexSpec.name = indexName;
          delete schema[storeName].idxByName[dexieName];
          schema[storeName].idxByName[indexName] = indexSpec;
        }
      }
    }
  }

  if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
    db._hasGetAll = false;
  }
}

function parseIndexSyntax(primKeyAndIndexes) {
  return primKeyAndIndexes.split(',').map((index, indexNum) => {
    index = index.trim();
    const name = index.replace(/([&*]|\+\+)/g, "");
    const keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split('+') : name;
    return createIndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray(keyPath), indexNum === 0);
  });
}

let Version = /*#__PURE__*/function () {
  function Version() {
    _classCallCheck(this, Version);
  }

  _createClass(Version, [{
    key: "_parseStoresSpec",
    value: function _parseStoresSpec(stores, outSchema) {
      keys(stores).forEach(tableName => {
        if (stores[tableName] !== null) {
          var indexes = parseIndexSyntax(stores[tableName]);
          var primKey = indexes.shift();
          if (primKey.multi) throw new exceptions.Schema("Primary key cannot be multi-valued");
          indexes.forEach(idx => {
            if (idx.auto) throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
            if (!idx.keyPath) throw new exceptions.Schema("Index must have a name and cannot be an empty string");
          });
          outSchema[tableName] = createTableSchema(tableName, primKey, indexes);
        }
      });
    }
  }, {
    key: "stores",
    value: function stores(_stores) {
      const db = this.db;
      this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, _stores) : _stores;
      const versions = db._versions;
      const storesSpec = {};
      let dbschema = {};
      versions.forEach(version => {
        extend(storesSpec, version._cfg.storesSource);
        dbschema = version._cfg.dbschema = {};

        version._parseStoresSpec(storesSpec, dbschema);
      });
      db._dbSchema = dbschema;
      removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);
      setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);
      db._storeNames = keys(dbschema);
      return this;
    }
  }, {
    key: "upgrade",
    value: function upgrade(upgradeFunction) {
      this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);
      return this;
    }
  }]);

  return Version;
}();

function createVersionConstructor(db) {
  return makeClassConstructor(Version.prototype, function Version(versionNumber) {
    this.db = db;
    this._cfg = {
      version: versionNumber,
      storesSource: null,
      dbschema: {},
      tables: {},
      contentUpgrade: null
    };
  });
}

function getDbNamesTable(indexedDB, IDBKeyRange) {
  let dbNamesDB = indexedDB["_dbNamesDB"];

  if (!dbNamesDB) {
    dbNamesDB = indexedDB["_dbNamesDB"] = new Dexie$1(DBNAMES_DB, {
      addons: [],
      indexedDB,
      IDBKeyRange
    });
    dbNamesDB.version(1).stores({
      dbnames: "name"
    });
  }

  return dbNamesDB.table("dbnames");
}

function hasDatabasesNative(indexedDB) {
  return indexedDB && typeof indexedDB.databases === "function";
}

function getDatabaseNames(_ref21) {
  let {
    indexedDB,
    IDBKeyRange
  } = _ref21;
  return hasDatabasesNative(indexedDB) ? Promise.resolve(indexedDB.databases()).then(infos => infos.map(info => info.name).filter(name => name !== DBNAMES_DB)) : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();
}

function _onDatabaseCreated(_ref22, name) {
  let {
    indexedDB,
    IDBKeyRange
  } = _ref22;
  !hasDatabasesNative(indexedDB) && name !== DBNAMES_DB && getDbNamesTable(indexedDB, IDBKeyRange).put({
    name
  }).catch(nop);
}

function _onDatabaseDeleted(_ref23, name) {
  let {
    indexedDB,
    IDBKeyRange
  } = _ref23;
  !hasDatabasesNative(indexedDB) && name !== DBNAMES_DB && getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);
}

function vip(fn) {
  return newScope(function () {
    PSD.letThrough = true;
    return fn();
  });
}

function idbReady() {
  var isSafari = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent);
  if (!isSafari || !indexedDB.databases) return Promise.resolve();
  var intervalId;
  return new Promise(function (resolve) {
    var tryIdb = function () {
      return indexedDB.databases().finally(resolve);
    };

    intervalId = setInterval(tryIdb, 100);
    tryIdb();
  }).finally(function () {
    return clearInterval(intervalId);
  });
}

function dexieOpen(db) {
  const state = db._state;
  const {
    indexedDB
  } = db._deps;
  if (state.isBeingOpened || db.idbdb) return state.dbReadyPromise.then(() => state.dbOpenError ? rejection(state.dbOpenError) : db);
  debug && (state.openCanceller._stackHolder = getErrorWithStack());
  state.isBeingOpened = true;
  state.dbOpenError = null;
  state.openComplete = false;
  const openCanceller = state.openCanceller;

  function throwIfCancelled() {
    if (state.openCanceller !== openCanceller) throw new exceptions.DatabaseClosed('db.open() was cancelled');
  }

  let resolveDbReady = state.dbReadyResolve,
      upgradeTransaction = null,
      wasCreated = false;
  return DexiePromise.race([openCanceller, (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(() => new DexiePromise((resolve, reject) => {
    throwIfCancelled();
    if (!indexedDB) throw new exceptions.MissingAPI();
    const dbName = db.name;
    const req = state.autoSchema ? indexedDB.open(dbName) : indexedDB.open(dbName, Math.round(db.verno * 10));
    if (!req) throw new exceptions.MissingAPI();
    req.onerror = eventRejectHandler(reject);
    req.onblocked = wrap(db._fireOnBlocked);
    req.onupgradeneeded = wrap(e => {
      upgradeTransaction = req.transaction;

      if (state.autoSchema && !db._options.allowEmptyDB) {
        req.onerror = preventDefault;
        upgradeTransaction.abort();
        req.result.close();
        const delreq = indexedDB.deleteDatabase(dbName);
        delreq.onsuccess = delreq.onerror = wrap(() => {
          reject(new exceptions.NoSuchDatabase("Database ".concat(dbName, " doesnt exist")));
        });
      } else {
        upgradeTransaction.onerror = eventRejectHandler(reject);
        var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;
        wasCreated = oldVer < 1;
        db._novip.idbdb = req.result;
        runUpgraders(db, oldVer / 10, upgradeTransaction, reject);
      }
    }, reject);
    req.onsuccess = wrap(() => {
      upgradeTransaction = null;
      const idbdb = db._novip.idbdb = req.result;
      const objectStoreNames = slice(idbdb.objectStoreNames);
      if (objectStoreNames.length > 0) try {
        const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');
        if (state.autoSchema) readGlobalSchema(db, idbdb, tmpTrans);else {
          adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);

          if (!verifyInstalledSchema(db, tmpTrans)) {
            console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.");
          }
        }
        generateMiddlewareStacks(db, tmpTrans);
      } catch (e) {}
      connections.push(db);
      idbdb.onversionchange = wrap(ev => {
        state.vcFired = true;
        db.on("versionchange").fire(ev);
      });
      idbdb.onclose = wrap(ev => {
        db.on("close").fire(ev);
      });
      if (wasCreated) _onDatabaseCreated(db._deps, dbName);
      resolve();
    }, reject);
  }))]).then(() => {
    throwIfCancelled();
    state.onReadyBeingFired = [];
    return DexiePromise.resolve(vip(() => db.on.ready.fire(db.vip))).then(function fireRemainders() {
      if (state.onReadyBeingFired.length > 0) {
        let remainders = state.onReadyBeingFired.reduce(promisableChain, nop);
        state.onReadyBeingFired = [];
        return DexiePromise.resolve(vip(() => remainders(db.vip))).then(fireRemainders);
      }
    });
  }).finally(() => {
    state.onReadyBeingFired = null;
    state.isBeingOpened = false;
  }).then(() => {
    return db;
  }).catch(err => {
    state.dbOpenError = err;

    try {
      upgradeTransaction && upgradeTransaction.abort();
    } catch (_a) {}

    if (openCanceller === state.openCanceller) {
      db._close();
    }

    return rejection(err);
  }).finally(() => {
    state.openComplete = true;
    resolveDbReady();
  });
}

function awaitIterator(iterator) {
  var callNext = result => iterator.next(result),
      doThrow = error => iterator.throw(error),
      onSuccess = step(callNext),
      onError = step(doThrow);

  function step(getNext) {
    return val => {
      var next = getNext(val),
          value = next.value;
      return next.done ? value : !value || typeof value.then !== 'function' ? isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);
    };
  }

  return step(callNext)();
}

function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
  var i = arguments.length;
  if (i < 2) throw new exceptions.InvalidArgument("Too few arguments");
  var args = new Array(i - 1);

  while (--i) args[i - 1] = arguments[i];

  scopeFunc = args.pop();
  var tables = flatten(args);
  return [mode, tables, scopeFunc];
}

function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {
  return DexiePromise.resolve().then(() => {
    const transless = PSD.transless || PSD;

    const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);

    const zoneProps = {
      trans: trans,
      transless: transless
    };

    if (parentTransaction) {
      trans.idbtrans = parentTransaction.idbtrans;
    } else {
      try {
        trans.create();
        db._state.PR1398_maxLoop = 3;
      } catch (ex) {
        if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
          console.warn('Dexie: Need to reopen db');

          db._close();

          return db.open().then(() => enterTransactionScope(db, mode, storeNames, null, scopeFunc));
        }

        return rejection(ex);
      }
    }

    const scopeFuncIsAsync = isAsyncFunction(scopeFunc);

    if (scopeFuncIsAsync) {
      incrementExpectedAwaits();
    }

    let returnValue;
    const promiseFollowed = DexiePromise.follow(() => {
      returnValue = scopeFunc.call(trans, trans);

      if (returnValue) {
        if (scopeFuncIsAsync) {
          var decrementor = decrementExpectedAwaits.bind(null, null);
          returnValue.then(decrementor, decrementor);
        } else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {
          returnValue = awaitIterator(returnValue);
        }
      }
    }, zoneProps);
    return (returnValue && typeof returnValue.then === 'function' ? DexiePromise.resolve(returnValue).then(x => trans.active ? x : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"))) : promiseFollowed.then(() => returnValue)).then(x => {
      if (parentTransaction) trans._resolve();
      return trans._completion.then(() => x);
    }).catch(e => {
      trans._reject(e);

      return rejection(e);
    });
  });
}

function pad(a, value, count) {
  const result = isArray(a) ? a.slice() : [a];

  for (let i = 0; i < count; ++i) result.push(value);

  return result;
}

function createVirtualIndexMiddleware(down) {
  return _objectSpread(_objectSpread({}, down), {}, {
    table(tableName) {
      const table = down.table(tableName);
      const {
        schema
      } = table;
      const indexLookup = {};
      const allVirtualIndexes = [];

      function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
        const keyPathAlias = getKeyPathAlias(keyPath);
        const indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];
        const keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;
        const isVirtual = keyTail > 0;

        const virtualIndex = _objectSpread(_objectSpread({}, lowLevelIndex), {}, {
          isVirtual,
          keyTail,
          keyLength,
          extractKey: getKeyExtractor(keyPath),
          unique: !isVirtual && lowLevelIndex.unique
        });

        indexList.push(virtualIndex);

        if (!virtualIndex.isPrimaryKey) {
          allVirtualIndexes.push(virtualIndex);
        }

        if (keyLength > 1) {
          const virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);
          addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
        }

        indexList.sort((a, b) => a.keyTail - b.keyTail);
        return virtualIndex;
      }

      const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
      indexLookup[":id"] = [primaryKey];

      for (const index of schema.indexes) {
        addVirtualIndexes(index.keyPath, 0, index);
      }

      function findBestIndex(keyPath) {
        const result = indexLookup[getKeyPathAlias(keyPath)];
        return result && result[0];
      }

      function translateRange(range, keyTail) {
        return {
          type: range.type === 1 ? 2 : range.type,
          lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
          lowerOpen: true,
          upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
          upperOpen: true
        };
      }

      function translateRequest(req) {
        const index = req.query.index;
        return index.isVirtual ? _objectSpread(_objectSpread({}, req), {}, {
          query: {
            index,
            range: translateRange(req.query.range, index.keyTail)
          }
        }) : req;
      }

      const result = _objectSpread(_objectSpread({}, table), {}, {
        schema: _objectSpread(_objectSpread({}, schema), {}, {
          primaryKey,
          indexes: allVirtualIndexes,
          getIndexByKeyPath: findBestIndex
        }),

        count(req) {
          return table.count(translateRequest(req));
        },

        query(req) {
          return table.query(translateRequest(req));
        },

        openCursor(req) {
          const {
            keyTail,
            isVirtual,
            keyLength
          } = req.query.index;
          if (!isVirtual) return table.openCursor(req);

          function createVirtualCursor(cursor) {
            function _continue(key) {
              key != null ? cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor.continue(cursor.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor.continue();
            }

            const virtualCursor = Object.create(cursor, {
              continue: {
                value: _continue
              },
              continuePrimaryKey: {
                value(key, primaryKey) {
                  cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);
                }

              },
              primaryKey: {
                get() {
                  return cursor.primaryKey;
                }

              },
              key: {
                get() {
                  const key = cursor.key;
                  return keyLength === 1 ? key[0] : key.slice(0, keyLength);
                }

              },
              value: {
                get() {
                  return cursor.value;
                }

              }
            });
            return virtualCursor;
          }

          return table.openCursor(translateRequest(req)).then(cursor => cursor && createVirtualCursor(cursor));
        }

      });

      return result;
    }

  });
}

const virtualIndexMiddleware = {
  stack: "dbcore",
  name: "VirtualIndexMiddleware",
  level: 1,
  create: createVirtualIndexMiddleware
};

function getObjectDiff(a, b, rv, prfx) {
  rv = rv || {};
  prfx = prfx || '';
  keys(a).forEach(prop => {
    if (!hasOwn(b, prop)) {
      rv[prfx + prop] = undefined;
    } else {
      var ap = a[prop],
          bp = b[prop];

      if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {
        const apTypeName = toStringTag(ap);
        const bpTypeName = toStringTag(bp);

        if (apTypeName !== bpTypeName) {
          rv[prfx + prop] = b[prop];
        } else if (apTypeName === 'Object') {
          getObjectDiff(ap, bp, rv, prfx + prop + '.');
        } else if (ap !== bp) {
          rv[prfx + prop] = b[prop];
        }
      } else if (ap !== bp) rv[prfx + prop] = b[prop];
    }
  });
  keys(b).forEach(prop => {
    if (!hasOwn(a, prop)) {
      rv[prfx + prop] = b[prop];
    }
  });
  return rv;
}

function getEffectiveKeys(primaryKey, req) {
  if (req.type === 'delete') return req.keys;
  return req.keys || req.values.map(primaryKey.extractKey);
}

const hooksMiddleware = {
  stack: "dbcore",
  name: "HooksMiddleware",
  level: 2,
  create: downCore => _objectSpread(_objectSpread({}, downCore), {}, {
    table(tableName) {
      const downTable = downCore.table(tableName);
      const {
        primaryKey
      } = downTable.schema;

      const tableMiddleware = _objectSpread(_objectSpread({}, downTable), {}, {
        mutate(req) {
          const dxTrans = PSD.trans;
          const {
            deleting,
            creating,
            updating
          } = dxTrans.table(tableName).hook;

          switch (req.type) {
            case 'add':
              if (creating.fire === nop) break;
              return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);

            case 'put':
              if (creating.fire === nop && updating.fire === nop) break;
              return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);

            case 'delete':
              if (deleting.fire === nop) break;
              return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);

            case 'deleteRange':
              if (deleting.fire === nop) break;
              return dxTrans._promise('readwrite', () => deleteRange(req), true);
          }

          return downTable.mutate(req);

          function addPutOrDelete(req) {
            const dxTrans = PSD.trans;
            const keys = req.keys || getEffectiveKeys(primaryKey, req);
            if (!keys) throw new Error("Keys missing");
            req = req.type === 'add' || req.type === 'put' ? _objectSpread(_objectSpread({}, req), {}, {
              keys
            }) : _objectSpread({}, req);
            if (req.type !== 'delete') req.values = _toConsumableArray(req.values);
            if (req.keys) req.keys = _toConsumableArray(req.keys);
            return getExistingValues(downTable, req, keys).then(existingValues => {
              const contexts = keys.map((key, i) => {
                const existingValue = existingValues[i];
                const ctx = {
                  onerror: null,
                  onsuccess: null
                };

                if (req.type === 'delete') {
                  deleting.fire.call(ctx, key, existingValue, dxTrans);
                } else if (req.type === 'add' || existingValue === undefined) {
                  const generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);

                  if (key == null && generatedPrimaryKey != null) {
                    key = generatedPrimaryKey;
                    req.keys[i] = key;

                    if (!primaryKey.outbound) {
                      setByKeyPath(req.values[i], primaryKey.keyPath, key);
                    }
                  }
                } else {
                  const objectDiff = getObjectDiff(existingValue, req.values[i]);
                  const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);

                  if (additionalChanges) {
                    const requestedValue = req.values[i];
                    Object.keys(additionalChanges).forEach(keyPath => {
                      if (hasOwn(requestedValue, keyPath)) {
                        requestedValue[keyPath] = additionalChanges[keyPath];
                      } else {
                        setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);
                      }
                    });
                  }
                }

                return ctx;
              });
              return downTable.mutate(req).then(_ref24 => {
                let {
                  failures,
                  results,
                  numFailures,
                  lastResult
                } = _ref24;

                for (let i = 0; i < keys.length; ++i) {
                  const primKey = results ? results[i] : keys[i];
                  const ctx = contexts[i];

                  if (primKey == null) {
                    ctx.onerror && ctx.onerror(failures[i]);
                  } else {
                    ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ? req.values[i] : primKey);
                  }
                }

                return {
                  failures,
                  results,
                  numFailures,
                  lastResult
                };
              }).catch(error => {
                contexts.forEach(ctx => ctx.onerror && ctx.onerror(error));
                return Promise.reject(error);
              });
            });
          }

          function deleteRange(req) {
            return deleteNextChunk(req.trans, req.range, 10000);
          }

          function deleteNextChunk(trans, range, limit) {
            return downTable.query({
              trans,
              values: false,
              query: {
                index: primaryKey,
                range
              },
              limit
            }).then(_ref25 => {
              let {
                result
              } = _ref25;
              return addPutOrDelete({
                type: 'delete',
                keys: result,
                trans
              }).then(res => {
                if (res.numFailures > 0) return Promise.reject(res.failures[0]);

                if (result.length < limit) {
                  return {
                    failures: [],
                    numFailures: 0,
                    lastResult: undefined
                  };
                } else {
                  return deleteNextChunk(trans, _objectSpread(_objectSpread({}, range), {}, {
                    lower: result[result.length - 1],
                    lowerOpen: true
                  }), limit);
                }
              });
            });
          }
        }

      });

      return tableMiddleware;
    }

  })
};

function getExistingValues(table, req, effectiveKeys) {
  return req.type === "add" ? Promise.resolve([]) : table.getMany({
    trans: req.trans,
    keys: effectiveKeys,
    cache: "immutable"
  });
}

function getFromTransactionCache(keys, cache, clone) {
  try {
    if (!cache) return null;
    if (cache.keys.length < keys.length) return null;
    const result = [];

    for (let i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {
      if (cmp(cache.keys[i], keys[j]) !== 0) continue;
      result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);
      ++j;
    }

    return result.length === keys.length ? result : null;
  } catch (_a) {
    return null;
  }
}

const cacheExistingValuesMiddleware = {
  stack: "dbcore",
  level: -1,
  create: core => {
    return {
      table: tableName => {
        const table = core.table(tableName);
        return _objectSpread(_objectSpread({}, table), {}, {
          getMany: req => {
            if (!req.cache) {
              return table.getMany(req);
            }

            const cachedResult = getFromTransactionCache(req.keys, req.trans["_cache"], req.cache === "clone");

            if (cachedResult) {
              return DexiePromise.resolve(cachedResult);
            }

            return table.getMany(req).then(res => {
              req.trans["_cache"] = {
                keys: req.keys,
                values: req.cache === "clone" ? deepClone(res) : res
              };
              return res;
            });
          },
          mutate: req => {
            if (req.type !== "add") req.trans["_cache"] = null;
            return table.mutate(req);
          }
        });
      }
    };
  }
};

function isEmptyRange(node) {
  return !("from" in node);
}

const RangeSet = function (fromOrTree, to) {
  if (this) {
    extend(this, arguments.length ? {
      d: 1,
      from: fromOrTree,
      to: arguments.length > 1 ? to : fromOrTree
    } : {
      d: 0
    });
  } else {
    const rv = new RangeSet();

    if (fromOrTree && "d" in fromOrTree) {
      extend(rv, fromOrTree);
    }

    return rv;
  }
};

props(RangeSet.prototype, {
  add(rangeSet) {
    mergeRanges(this, rangeSet);
    return this;
  },

  addKey(key) {
    addRange(this, key, key);
    return this;
  },

  addKeys(keys) {
    keys.forEach(key => addRange(this, key, key));
    return this;
  },

  [iteratorSymbol]() {
    return getRangeSetIterator(this);
  }

});

function addRange(target, from, to) {
  const diff = cmp(from, to);
  if (isNaN(diff)) return;
  if (diff > 0) throw RangeError();
  if (isEmptyRange(target)) return extend(target, {
    from,
    to,
    d: 1
  });
  const left = target.l;
  const right = target.r;

  if (cmp(to, target.from) < 0) {
    left ? addRange(left, from, to) : target.l = {
      from,
      to,
      d: 1,
      l: null,
      r: null
    };
    return rebalance(target);
  }

  if (cmp(from, target.to) > 0) {
    right ? addRange(right, from, to) : target.r = {
      from,
      to,
      d: 1,
      l: null,
      r: null
    };
    return rebalance(target);
  }

  if (cmp(from, target.from) < 0) {
    target.from = from;
    target.l = null;
    target.d = right ? right.d + 1 : 1;
  }

  if (cmp(to, target.to) > 0) {
    target.to = to;
    target.r = null;
    target.d = target.l ? target.l.d + 1 : 1;
  }

  const rightWasCutOff = !target.r;

  if (left && !target.l) {
    mergeRanges(target, left);
  }

  if (right && rightWasCutOff) {
    mergeRanges(target, right);
  }
}

function mergeRanges(target, newSet) {
  function _addRangeSet(target, _ref26) {
    let {
      from,
      to,
      l,
      r
    } = _ref26;
    addRange(target, from, to);
    if (l) _addRangeSet(target, l);
    if (r) _addRangeSet(target, r);
  }

  if (!isEmptyRange(newSet)) _addRangeSet(target, newSet);
}

function rangesOverlap(rangeSet1, rangeSet2) {
  const i1 = getRangeSetIterator(rangeSet2);
  let nextResult1 = i1.next();
  if (nextResult1.done) return false;
  let a = nextResult1.value;
  const i2 = getRangeSetIterator(rangeSet1);
  let nextResult2 = i2.next(a.from);
  let b = nextResult2.value;

  while (!nextResult1.done && !nextResult2.done) {
    if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0) return true;
    cmp(a.from, b.from) < 0 ? a = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a.from)).value;
  }

  return false;
}

function getRangeSetIterator(node) {
  let state = isEmptyRange(node) ? null : {
    s: 0,
    n: node
  };
  return {
    next(key) {
      const keyProvided = arguments.length > 0;

      while (state) {
        switch (state.s) {
          case 0:
            state.s = 1;

            if (keyProvided) {
              while (state.n.l && cmp(key, state.n.from) < 0) state = {
                up: state,
                n: state.n.l,
                s: 1
              };
            } else {
              while (state.n.l) state = {
                up: state,
                n: state.n.l,
                s: 1
              };
            }

          case 1:
            state.s = 2;
            if (!keyProvided || cmp(key, state.n.to) <= 0) return {
              value: state.n,
              done: false
            };

          case 2:
            if (state.n.r) {
              state.s = 3;
              state = {
                up: state,
                n: state.n.r,
                s: 0
              };
              continue;
            }

          case 3:
            state = state.up;
        }
      }

      return {
        done: true
      };
    }

  };
}

function rebalance(target) {
  var _a, _b;

  const diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);
  const r = diff > 1 ? "r" : diff < -1 ? "l" : "";

  if (r) {
    const l = r === "r" ? "l" : "r";

    const rootClone = _objectSpread({}, target);

    const oldRootRight = target[r];
    target.from = oldRootRight.from;
    target.to = oldRootRight.to;
    target[r] = oldRootRight[r];
    rootClone[r] = oldRootRight[l];
    target[l] = rootClone;
    rootClone.d = computeDepth(rootClone);
  }

  target.d = computeDepth(target);
}

function computeDepth(_ref27) {
  let {
    r,
    l
  } = _ref27;
  return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;
}

const observabilityMiddleware = {
  stack: "dbcore",
  level: 0,
  create: core => {
    const dbName = core.schema.name;
    const FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);
    return _objectSpread(_objectSpread({}, core), {}, {
      table: tableName => {
        const table = core.table(tableName);
        const {
          schema
        } = table;
        const {
          primaryKey
        } = schema;
        const {
          extractKey,
          outbound
        } = primaryKey;

        const tableClone = _objectSpread(_objectSpread({}, table), {}, {
          mutate: req => {
            const trans = req.trans;
            const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});

            const getRangeSet = indexName => {
              const part = "idb://".concat(dbName, "/").concat(tableName, "/").concat(indexName);
              return mutatedParts[part] || (mutatedParts[part] = new RangeSet());
            };

            const pkRangeSet = getRangeSet("");
            const delsRangeSet = getRangeSet(":dels");
            const {
              type
            } = req;
            let [keys, newObjs] = req.type === "deleteRange" ? [req.range] : req.type === "delete" ? [req.keys] : req.values.length < 50 ? [[], req.values] : [];
            const oldCache = req.trans["_cache"];
            return table.mutate(req).then(res => {
              if (isArray(keys)) {
                if (type !== "delete") keys = res.results;
                pkRangeSet.addKeys(keys);
                const oldObjs = getFromTransactionCache(keys, oldCache);

                if (!oldObjs && type !== "add") {
                  delsRangeSet.addKeys(keys);
                }

                if (oldObjs || newObjs) {
                  trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);
                }
              } else if (keys) {
                const range = {
                  from: keys.lower,
                  to: keys.upper
                };
                delsRangeSet.add(range);
                pkRangeSet.add(range);
              } else {
                pkRangeSet.add(FULL_RANGE);
                delsRangeSet.add(FULL_RANGE);
                schema.indexes.forEach(idx => getRangeSet(idx.name).add(FULL_RANGE));
              }

              return res;
            });
          }
        });

        const getRange = _ref28 => {
          let {
            query: {
              index,
              range
            }
          } = _ref28;

          var _a, _b;

          return [index, new RangeSet((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY)];
        };

        const readSubscribers = {
          get: req => [primaryKey, new RangeSet(req.key)],
          getMany: req => [primaryKey, new RangeSet().addKeys(req.keys)],
          count: getRange,
          query: getRange,
          openCursor: getRange
        };
        keys(readSubscribers).forEach(method => {
          tableClone[method] = function (req) {
            const {
              subscr
            } = PSD;

            if (subscr) {
              const getRangeSet = indexName => {
                const part = "idb://".concat(dbName, "/").concat(tableName, "/").concat(indexName);
                return subscr[part] || (subscr[part] = new RangeSet());
              };

              const pkRangeSet = getRangeSet("");
              const delsRangeSet = getRangeSet(":dels");
              const [queriedIndex, queriedRanges] = readSubscribers[method](req);
              getRangeSet(queriedIndex.name || "").add(queriedRanges);

              if (!queriedIndex.isPrimaryKey) {
                if (method === "count") {
                  delsRangeSet.add(FULL_RANGE);
                } else {
                  const keysPromise = method === "query" && outbound && req.values && table.query(_objectSpread(_objectSpread({}, req), {}, {
                    values: false
                  }));
                  return table[method].apply(this, arguments).then(res => {
                    if (method === "query") {
                      if (outbound && req.values) {
                        return keysPromise.then(_ref29 => {
                          let {
                            result: resultingKeys
                          } = _ref29;
                          pkRangeSet.addKeys(resultingKeys);
                          return res;
                        });
                      }

                      const pKeys = req.values ? res.result.map(extractKey) : res.result;

                      if (req.values) {
                        pkRangeSet.addKeys(pKeys);
                      } else {
                        delsRangeSet.addKeys(pKeys);
                      }
                    } else if (method === "openCursor") {
                      const cursor = res;
                      const wantValues = req.values;
                      return cursor && Object.create(cursor, {
                        key: {
                          get() {
                            delsRangeSet.addKey(cursor.primaryKey);
                            return cursor.key;
                          }

                        },
                        primaryKey: {
                          get() {
                            const pkey = cursor.primaryKey;
                            delsRangeSet.addKey(pkey);
                            return pkey;
                          }

                        },
                        value: {
                          get() {
                            wantValues && pkRangeSet.addKey(cursor.primaryKey);
                            return cursor.value;
                          }

                        }
                      });
                    }

                    return res;
                  });
                }
              }
            }

            return table[method].apply(this, arguments);
          };
        });
        return tableClone;
      }
    });
  }
};

function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {
  function addAffectedIndex(ix) {
    const rangeSet = getRangeSet(ix.name || "");

    function extractKey(obj) {
      return obj != null ? ix.extractKey(obj) : null;
    }

    const addKeyOrKeys = key => ix.multiEntry && isArray(key) ? key.forEach(key => rangeSet.addKey(key)) : rangeSet.addKey(key);

    (oldObjs || newObjs).forEach((_, i) => {
      const oldKey = oldObjs && extractKey(oldObjs[i]);
      const newKey = newObjs && extractKey(newObjs[i]);

      if (cmp(oldKey, newKey) !== 0) {
        if (oldKey != null) addKeyOrKeys(oldKey);
        if (newKey != null) addKeyOrKeys(newKey);
      }
    });
  }

  schema.indexes.forEach(addAffectedIndex);
}

let Dexie$1 = /*#__PURE__*/function () {
  function Dexie$1(name, options) {
    _classCallCheck(this, Dexie$1);

    this._middlewares = {};
    this.verno = 0;
    const deps = Dexie$1.dependencies;
    this._options = options = _objectSpread({
      addons: Dexie$1.addons,
      autoOpen: true,
      indexedDB: deps.indexedDB,
      IDBKeyRange: deps.IDBKeyRange
    }, options);
    this._deps = {
      indexedDB: options.indexedDB,
      IDBKeyRange: options.IDBKeyRange
    };
    const {
      addons
    } = options;
    this._dbSchema = {};
    this._versions = [];
    this._storeNames = [];
    this._allTables = {};
    this.idbdb = null;
    this._novip = this;
    const state = {
      dbOpenError: null,
      isBeingOpened: false,
      onReadyBeingFired: null,
      openComplete: false,
      dbReadyResolve: nop,
      dbReadyPromise: null,
      cancelOpen: nop,
      openCanceller: null,
      autoSchema: true,
      PR1398_maxLoop: 3
    };
    state.dbReadyPromise = new DexiePromise(resolve => {
      state.dbReadyResolve = resolve;
    });
    state.openCanceller = new DexiePromise((_, reject) => {
      state.cancelOpen = reject;
    });
    this._state = state;
    this.name = name;
    this.on = Events(this, "populate", "blocked", "versionchange", "close", {
      ready: [promisableChain, nop]
    });
    this.on.ready.subscribe = override(this.on.ready.subscribe, subscribe => {
      return (subscriber, bSticky) => {
        Dexie$1.vip(() => {
          const state = this._state;

          if (state.openComplete) {
            if (!state.dbOpenError) DexiePromise.resolve().then(subscriber);
            if (bSticky) subscribe(subscriber);
          } else if (state.onReadyBeingFired) {
            state.onReadyBeingFired.push(subscriber);
            if (bSticky) subscribe(subscriber);
          } else {
            subscribe(subscriber);
            const db = this;
            if (!bSticky) subscribe(function unsubscribe() {
              db.on.ready.unsubscribe(subscriber);
              db.on.ready.unsubscribe(unsubscribe);
            });
          }
        });
      };
    });
    this.Collection = createCollectionConstructor(this);
    this.Table = createTableConstructor(this);
    this.Transaction = createTransactionConstructor(this);
    this.Version = createVersionConstructor(this);
    this.WhereClause = createWhereClauseConstructor(this);
    this.on("versionchange", ev => {
      if (ev.newVersion > 0) console.warn("Another connection wants to upgrade database '".concat(this.name, "'. Closing db now to resume the upgrade."));else console.warn("Another connection wants to delete database '".concat(this.name, "'. Closing db now to resume the delete request."));
      this.close();
    });
    this.on("blocked", ev => {
      if (!ev.newVersion || ev.newVersion < ev.oldVersion) console.warn("Dexie.delete('".concat(this.name, "') was blocked"));else console.warn("Upgrade '".concat(this.name, "' blocked by other connection holding version ").concat(ev.oldVersion / 10));
    });
    this._maxKey = getMaxKey(options.IDBKeyRange);

    this._createTransaction = (mode, storeNames, dbschema, parentTransaction) => new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);

    this._fireOnBlocked = ev => {
      this.on("blocked").fire(ev);
      connections.filter(c => c.name === this.name && c !== this && !c._state.vcFired).map(c => c.on("versionchange").fire(ev));
    };

    this.use(virtualIndexMiddleware);
    this.use(hooksMiddleware);
    this.use(observabilityMiddleware);
    this.use(cacheExistingValuesMiddleware);
    this.vip = Object.create(this, {
      _vip: {
        value: true
      }
    });
    addons.forEach(addon => addon(this));
  }

  _createClass(Dexie$1, [{
    key: "version",
    value: function version(versionNumber) {
      if (isNaN(versionNumber) || versionNumber < 0.1) throw new exceptions.Type("Given version is not a positive number");
      versionNumber = Math.round(versionNumber * 10) / 10;
      if (this.idbdb || this._state.isBeingOpened) throw new exceptions.Schema("Cannot add version when database is open");
      this.verno = Math.max(this.verno, versionNumber);
      const versions = this._versions;
      var versionInstance = versions.filter(v => v._cfg.version === versionNumber)[0];
      if (versionInstance) return versionInstance;
      versionInstance = new this.Version(versionNumber);
      versions.push(versionInstance);
      versions.sort(lowerVersionFirst);
      versionInstance.stores({});
      this._state.autoSchema = false;
      return versionInstance;
    }
  }, {
    key: "_whenReady",
    value: function _whenReady(fn) {
      return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn() : new DexiePromise((resolve, reject) => {
        if (this._state.openComplete) {
          return reject(new exceptions.DatabaseClosed(this._state.dbOpenError));
        }

        if (!this._state.isBeingOpened) {
          if (!this._options.autoOpen) {
            reject(new exceptions.DatabaseClosed());
            return;
          }

          this.open().catch(nop);
        }

        this._state.dbReadyPromise.then(resolve, reject);
      }).then(fn);
    }
  }, {
    key: "use",
    value: function use(_ref30) {
      let {
        stack,
        create,
        level,
        name
      } = _ref30;
      if (name) this.unuse({
        stack,
        name
      });
      const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);
      middlewares.push({
        stack,
        create,
        level: level == null ? 10 : level,
        name
      });
      middlewares.sort((a, b) => a.level - b.level);
      return this;
    }
  }, {
    key: "unuse",
    value: function unuse(_ref31) {
      let {
        stack,
        name,
        create
      } = _ref31;

      if (stack && this._middlewares[stack]) {
        this._middlewares[stack] = this._middlewares[stack].filter(mw => create ? mw.create !== create : name ? mw.name !== name : false);
      }

      return this;
    }
  }, {
    key: "open",
    value: function open() {
      return dexieOpen(this);
    }
  }, {
    key: "_close",
    value: function _close() {
      const state = this._state;
      const idx = connections.indexOf(this);
      if (idx >= 0) connections.splice(idx, 1);

      if (this.idbdb) {
        try {
          this.idbdb.close();
        } catch (e) {}

        this._novip.idbdb = null;
      }

      state.dbReadyPromise = new DexiePromise(resolve => {
        state.dbReadyResolve = resolve;
      });
      state.openCanceller = new DexiePromise((_, reject) => {
        state.cancelOpen = reject;
      });
    }
  }, {
    key: "close",
    value: function close() {
      this._close();

      const state = this._state;
      this._options.autoOpen = false;
      state.dbOpenError = new exceptions.DatabaseClosed();
      if (state.isBeingOpened) state.cancelOpen(state.dbOpenError);
    }
  }, {
    key: "delete",
    value: function _delete() {
      const hasArguments = arguments.length > 0;
      const state = this._state;
      return new DexiePromise((resolve, reject) => {
        const doDelete = () => {
          this.close();

          var req = this._deps.indexedDB.deleteDatabase(this.name);

          req.onsuccess = wrap(() => {
            _onDatabaseDeleted(this._deps, this.name);

            resolve();
          });
          req.onerror = eventRejectHandler(reject);
          req.onblocked = this._fireOnBlocked;
        };

        if (hasArguments) throw new exceptions.InvalidArgument("Arguments not allowed in db.delete()");

        if (state.isBeingOpened) {
          state.dbReadyPromise.then(doDelete);
        } else {
          doDelete();
        }
      });
    }
  }, {
    key: "backendDB",
    value: function backendDB() {
      return this.idbdb;
    }
  }, {
    key: "isOpen",
    value: function isOpen() {
      return this.idbdb !== null;
    }
  }, {
    key: "hasBeenClosed",
    value: function hasBeenClosed() {
      const dbOpenError = this._state.dbOpenError;
      return dbOpenError && dbOpenError.name === 'DatabaseClosed';
    }
  }, {
    key: "hasFailed",
    value: function hasFailed() {
      return this._state.dbOpenError !== null;
    }
  }, {
    key: "dynamicallyOpened",
    value: function dynamicallyOpened() {
      return this._state.autoSchema;
    }
  }, {
    key: "tables",
    get: function () {
      return keys(this._allTables).map(name => this._allTables[name]);
    }
  }, {
    key: "transaction",
    value: function transaction() {
      const args = extractTransactionArgs.apply(this, arguments);
      return this._transaction.apply(this, args);
    }
  }, {
    key: "_transaction",
    value: function _transaction(mode, tables, scopeFunc) {
      let parentTransaction = PSD.trans;
      if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1) parentTransaction = null;
      const onlyIfCompatible = mode.indexOf('?') !== -1;
      mode = mode.replace('!', '').replace('?', '');
      let idbMode, storeNames;

      try {
        storeNames = tables.map(table => {
          var storeName = table instanceof this.Table ? table.name : table;
          if (typeof storeName !== 'string') throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
          return storeName;
        });
        if (mode == "r" || mode === READONLY) idbMode = READONLY;else if (mode == "rw" || mode == READWRITE) idbMode = READWRITE;else throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);

        if (parentTransaction) {
          if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
            if (onlyIfCompatible) {
              parentTransaction = null;
            } else throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
          }

          if (parentTransaction) {
            storeNames.forEach(storeName => {
              if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
                if (onlyIfCompatible) {
                  parentTransaction = null;
                } else throw new exceptions.SubTransaction("Table " + storeName + " not included in parent transaction.");
              }
            });
          }

          if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
            parentTransaction = null;
          }
        }
      } catch (e) {
        return parentTransaction ? parentTransaction._promise(null, (_, reject) => {
          reject(e);
        }) : rejection(e);
      }

      const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
      return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, "lock") : PSD.trans ? usePSD(PSD.transless, () => this._whenReady(enterTransaction)) : this._whenReady(enterTransaction);
    }
  }, {
    key: "table",
    value: function table(tableName) {
      if (!hasOwn(this._allTables, tableName)) {
        throw new exceptions.InvalidTable("Table ".concat(tableName, " does not exist"));
      }

      return this._allTables[tableName];
    }
  }]);

  return Dexie$1;
}();

const symbolObservable = typeof Symbol !== "undefined" && "observable" in Symbol ? Symbol.observable : "@@observable";

let Observable = /*#__PURE__*/function () {
  function Observable(subscribe) {
    _classCallCheck(this, Observable);

    this._subscribe = subscribe;
  }

  _createClass(Observable, [{
    key: "subscribe",
    value: function subscribe(x, error, complete) {
      return this._subscribe(!x || typeof x === "function" ? {
        next: x,
        error,
        complete
      } : x);
    }
  }, {
    key: symbolObservable,
    value: function () {
      return this;
    }
  }]);

  return Observable;
}();

function extendObservabilitySet(target, newSet) {
  keys(newSet).forEach(part => {
    const rangeSet = target[part] || (target[part] = new RangeSet());
    mergeRanges(rangeSet, newSet[part]);
  });
  return target;
}

function liveQuery(querier) {
  return new Observable(observer => {
    const scopeFuncIsAsync = isAsyncFunction(querier);

    function execute(subscr) {
      if (scopeFuncIsAsync) {
        incrementExpectedAwaits();
      }

      const exec = () => newScope(querier, {
        subscr,
        trans: null
      });

      const rv = PSD.trans ? usePSD(PSD.transless, exec) : exec();

      if (scopeFuncIsAsync) {
        rv.then(decrementExpectedAwaits, decrementExpectedAwaits);
      }

      return rv;
    }

    let closed = false;
    let accumMuts = {};
    let currentObs = {};
    const subscription = {
      get closed() {
        return closed;
      },

      unsubscribe: () => {
        closed = true;
        globalEvents.storagemutated.unsubscribe(mutationListener);
      }
    };
    observer.start && observer.start(subscription);
    let querying = false,
        startedListening = false;

    function shouldNotify() {
      return keys(currentObs).some(key => accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));
    }

    const mutationListener = parts => {
      extendObservabilitySet(accumMuts, parts);

      if (shouldNotify()) {
        doQuery();
      }
    };

    const doQuery = () => {
      if (querying || closed) return;
      accumMuts = {};
      const subscr = {};
      const ret = execute(subscr);

      if (!startedListening) {
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);
        startedListening = true;
      }

      querying = true;
      Promise.resolve(ret).then(result => {
        querying = false;
        if (closed) return;

        if (shouldNotify()) {
          doQuery();
        } else {
          accumMuts = {};
          currentObs = subscr;
          observer.next && observer.next(result);
        }
      }, err => {
        querying = false;
        observer.error && observer.error(err);
        subscription.unsubscribe();
      });
    };

    doQuery();
    return subscription;
  });
}

let domDeps;

try {
  domDeps = {
    indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
    IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange
  };
} catch (e) {
  domDeps = {
    indexedDB: null,
    IDBKeyRange: null
  };
}

const Dexie = Dexie$1;
props(Dexie, _objectSpread(_objectSpread({}, fullNameExceptions), {}, {
  delete(databaseName) {
    const db = new Dexie(databaseName, {
      addons: []
    });
    return db.delete();
  },

  exists(name) {
    return new Dexie(name, {
      addons: []
    }).open().then(db => {
      db.close();
      return true;
    }).catch('NoSuchDatabaseError', () => false);
  },

  getDatabaseNames(cb) {
    try {
      return getDatabaseNames(Dexie.dependencies).then(cb);
    } catch (_a) {
      return rejection(new exceptions.MissingAPI());
    }
  },

  defineClass() {
    function Class(content) {
      extend(this, content);
    }

    return Class;
  },

  ignoreTransaction(scopeFunc) {
    return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();
  },

  vip,
  async: function (generatorFn) {
    return function () {
      try {
        var rv = awaitIterator(generatorFn.apply(this, arguments));
        if (!rv || typeof rv.then !== 'function') return DexiePromise.resolve(rv);
        return rv;
      } catch (e) {
        return rejection(e);
      }
    };
  },
  spawn: function (generatorFn, args, thiz) {
    try {
      var rv = awaitIterator(generatorFn.apply(thiz, args || []));
      if (!rv || typeof rv.then !== 'function') return DexiePromise.resolve(rv);
      return rv;
    } catch (e) {
      return rejection(e);
    }
  },
  currentTransaction: {
    get: () => PSD.trans || null
  },
  waitFor: function (promiseOrFunction, optionalTimeout) {
    const promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ? Dexie.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 60000);
    return PSD.trans ? PSD.trans.waitFor(promise) : promise;
  },
  Promise: DexiePromise,
  debug: {
    get: () => debug,
    set: value => {
      setDebug(value, value === 'dexie' ? () => true : dexieStackFrameFilter);
    }
  },
  derive: derive,
  extend: extend,
  props: props,
  override: override,
  Events: Events,
  on: globalEvents,
  liveQuery,
  extendObservabilitySet,
  getByKeyPath: getByKeyPath,
  setByKeyPath: setByKeyPath,
  delByKeyPath: delByKeyPath,
  shallowClone: shallowClone,
  deepClone: deepClone,
  getObjectDiff: getObjectDiff,
  cmp,
  asap: asap$1,
  minKey: minKey,
  addons: [],
  connections: connections,
  errnames: errnames,
  dependencies: domDeps,
  semVer: DEXIE_VERSION,
  version: DEXIE_VERSION.split('.').map(n => parseInt(n)).reduce((p, c, i) => p + c / Math.pow(10, i * 2))
}));
Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);

if (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {
  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, updatedParts => {
    if (!propagatingLocally) {
      let event;

      if (isIEOrEdge) {
        event = document.createEvent('CustomEvent');
        event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);
      } else {
        event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {
          detail: updatedParts
        });
      }

      propagatingLocally = true;
      dispatchEvent(event);
      propagatingLocally = false;
    }
  });
  addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, _ref32 => {
    let {
      detail
    } = _ref32;

    if (!propagatingLocally) {
      propagateLocally(detail);
    }
  });
}

function propagateLocally(updateParts) {
  let wasMe = propagatingLocally;

  try {
    propagatingLocally = true;
    globalEvents.storagemutated.fire(updateParts);
  } finally {
    propagatingLocally = wasMe;
  }
}

let propagatingLocally = false;

if (typeof BroadcastChannel !== 'undefined') {
  const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);
  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, changedParts => {
    if (!propagatingLocally) {
      bc.postMessage(changedParts);
    }
  });

  bc.onmessage = ev => {
    if (ev.data) propagateLocally(ev.data);
  };
} else if (typeof self !== 'undefined' && typeof navigator !== 'undefined') {
  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, changedParts => {
    try {
      if (!propagatingLocally) {
        if (typeof localStorage !== 'undefined') {
          localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({
            trig: Math.random(),
            changedParts
          }));
        }

        if (typeof self['clients'] === 'object') {
          _toConsumableArray(self['clients'].matchAll({
            includeUncontrolled: true
          })).forEach(client => client.postMessage({
            type: STORAGE_MUTATED_DOM_EVENT_NAME,
            changedParts
          }));
        }
      }
    } catch (_a) {}
  });

  if (typeof addEventListener !== 'undefined') {
    addEventListener('storage', ev => {
      if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {
        const data = JSON.parse(ev.newValue);
        if (data) propagateLocally(data.changedParts);
      }
    });
  }

  const swContainer = self.document && navigator.serviceWorker;

  if (swContainer) {
    swContainer.addEventListener('message', propagateMessageLocally);
  }
}

function propagateMessageLocally(_ref33) {
  let {
    data
  } = _ref33;

  if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {
    propagateLocally(data.changedParts);
  }
}

DexiePromise.rejectionMapper = mapError;
setDebug(debug, dexieStackFrameFilter);


/***/ }),

/***/ "./node_modules/render-media/lib/mime.json":
/*!*************************************************!*\
  !*** ./node_modules/render-media/lib/mime.json ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{".3gp":"video/3gpp",".aac":"audio/aac",".aif":"audio/x-aiff",".aiff":"audio/x-aiff",".atom":"application/atom+xml",".avi":"video/x-msvideo",".bmp":"image/bmp",".bz2":"application/x-bzip2",".conf":"text/plain",".css":"text/css",".csv":"text/plain",".diff":"text/x-diff",".doc":"application/msword",".flv":"video/x-flv",".gif":"image/gif",".gz":"application/x-gzip",".htm":"text/html",".html":"text/html",".ico":"image/vnd.microsoft.icon",".ics":"text/calendar",".iso":"application/octet-stream",".jar":"application/java-archive",".jpeg":"image/jpeg",".jpg":"image/jpeg",".js":"application/javascript",".json":"application/json",".less":"text/css",".log":"text/plain",".m3u":"audio/x-mpegurl",".m4a":"audio/x-m4a",".m4b":"audio/mp4",".m4p":"audio/mp4",".m4v":"video/x-m4v",".manifest":"text/cache-manifest",".markdown":"text/x-markdown",".mathml":"application/mathml+xml",".md":"text/x-markdown",".mid":"audio/midi",".midi":"audio/midi",".mov":"video/quicktime",".mp3":"audio/mpeg",".mp4":"video/mp4",".mp4v":"video/mp4",".mpeg":"video/mpeg",".mpg":"video/mpeg",".odp":"application/vnd.oasis.opendocument.presentation",".ods":"application/vnd.oasis.opendocument.spreadsheet",".odt":"application/vnd.oasis.opendocument.text",".oga":"audio/ogg",".ogg":"application/ogg",".pdf":"application/pdf",".png":"image/png",".pps":"application/vnd.ms-powerpoint",".ppt":"application/vnd.ms-powerpoint",".ps":"application/postscript",".psd":"image/vnd.adobe.photoshop",".qt":"video/quicktime",".rar":"application/x-rar-compressed",".rdf":"application/rdf+xml",".rss":"application/rss+xml",".rtf":"application/rtf",".svg":"image/svg+xml",".svgz":"image/svg+xml",".swf":"application/x-shockwave-flash",".tar":"application/x-tar",".tbz":"application/x-bzip-compressed-tar",".text":"text/plain",".tif":"image/tiff",".tiff":"image/tiff",".torrent":"application/x-bittorrent",".ttf":"application/x-font-ttf",".txt":"text/plain",".wav":"audio/wav",".webm":"video/webm",".wma":"audio/x-ms-wma",".wmv":"video/x-ms-wmv",".xls":"application/vnd.ms-excel",".xml":"application/xml",".yaml":"text/yaml",".yml":"text/yaml",".zip":"application/zip"}');

/***/ }),

/***/ "./node_modules/webtorrent/package.json":
/*!**********************************************!*\
  !*** ./node_modules/webtorrent/package.json ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"webtorrent","description":"Streaming torrent client","version":"1.8.26","author":{"name":"WebTorrent LLC","email":"feross@webtorrent.io","url":"https://webtorrent.io"},"browser":{"./lib/server.js":false,"./lib/conn-pool.js":false,"./lib/utp.js":false,"bittorrent-dht/client":false,"fs":false,"fs-chunk-store":"memory-chunk-store","load-ip-set":false,"net":false,"os":false,"ut_pex":false},"browserify":{"transform":["package-json-versionify"]},"bugs":{"url":"https://github.com/webtorrent/webtorrent/issues"},"chromeapp":{"./lib/utp.js":false,"fs-chunk-store":"memory-chunk-store","http":"@webtorrent/http-node","load-ip-set":false,"net":"chrome-net","os":false},"dependencies":{"@webtorrent/http-node":"^1.3.0","addr-to-ip-port":"^1.5.4","bitfield":"^4.1.0","bittorrent-dht":"^10.0.4","bittorrent-protocol":"^3.5.5","cache-chunk-store":"^3.2.2","chrome-net":"^3.3.4","chunk-store-stream":"^4.3.0","cpus":"^1.0.3","create-torrent":"^5.0.4","debug":"^4.3.4","end-of-stream":"^1.4.4","escape-html":"^1.0.3","fs-chunk-store":"^2.0.5","immediate-chunk-store":"^2.2.0","load-ip-set":"^2.2.1","lt_donthave":"^1.0.1","memory-chunk-store":"^1.3.5","mime":"^3.0.0","multistream":"^4.1.0","package-json-versionify":"^1.0.4","parse-torrent":"^9.1.5","pump":"^3.0.0","queue-microtask":"^1.2.3","random-iterate":"^1.0.1","randombytes":"^2.1.0","range-parser":"^1.2.1","render-media":"^4.1.0","run-parallel":"^1.2.0","run-parallel-limit":"^1.1.0","simple-concat":"^1.0.1","simple-get":"^4.0.1","simple-peer":"^9.11.1","simple-sha1":"^3.1.0","speed-limiter":"^1.0.2","stream-to-blob":"^2.0.1","stream-to-blob-url":"^3.0.2","stream-with-known-length-to-buffer":"^1.0.4","throughput":"^1.0.1","torrent-discovery":"^9.4.13","torrent-piece":"^2.0.1","unordered-array-remove":"^1.0.2","ut_metadata":"^3.5.2","ut_pex":"^3.0.2"},"devDependencies":{"@webtorrent/semantic-release-config":"1.0.7","airtap":"4.0.4","airtap-manual":"1.0.0","airtap-sauce":"1.1.2","babel-minify":"0.5.2","bittorrent-tracker":"9.19.0","browserify":"17.0.0","disc":"1.3.3","finalhandler":"1.2.0","network-address":"1.1.2","run-series":"1.1.9","semantic-release":"19.0.3","serve-static":"1.15.0","standard":"*","tape":"5.5.3","webtorrent-fixtures":"1.7.5"},"optionalDependencies":{"utp-native":"^2.5.3"},"engines":{"node":">=12"},"funding":[{"type":"github","url":"https://github.com/sponsors/feross"},{"type":"patreon","url":"https://www.patreon.com/feross"},{"type":"consulting","url":"https://feross.org/support"}],"homepage":"https://webtorrent.io","keywords":["bittorrent","bittorrent client","download","mad science","p2p","peer-to-peer","peers","streaming","swarm","torrent","web torrent","webrtc","webrtc data","webtorrent"],"license":"MIT","main":"index.js","repository":{"type":"git","url":"git://github.com/webtorrent/webtorrent.git"},"scripts":{"build":"npm run build-js && npm run build-js-worker && npm run build-chromeapp","build-chromeapp":"browserify --browser-field=chromeapp --standalone WebTorrent . | minify --mangle=false > webtorrent.chromeapp.js","build-chromeapp-debug":"browserify --browser-field=chromeapp --standalone WebTorrent . > webtorrent.chromeapp.js","build-js":"browserify --standalone WebTorrent . | minify --mangle=false > webtorrent.min.js","build-js-worker":"browserify ./lib/worker.js | minify --mangle=false > sw.min.js","build-js-debug":"browserify --standalone WebTorrent . > webtorrent.debug.js","build-js-worker-debug":"browserify ./lib/worker.js > sw.debug.js","prepublishOnly":"npm run build && npm run update-authors","preversion":"npm run build && npm run update-authors","size":"npm run size-js && npm run size-disc","size-disc":"browserify --full-paths . | discify --open","size-js":"npm run build && cat webtorrent.min.js | gzip | wc -c","test":"standard && npm run test-node && npm run test-browser","test-browser":"airtap --concurrency 1 -- test/*.js test/browser/*.js","test-browser-local":"airtap --preset local -- test/*.js test/browser/*.js","test-node":"tape test/*.js test/node/*.js","update-authors":"./scripts/update-authors.sh"},"standard":{"ignore":["webtorrent.min.js","sw.min.js","webtorrent.chromeapp.js"]},"renovate":{"extends":["github>webtorrent/renovate-config"],"rangeStrategy":"bump"},"release":{"extends":"@webtorrent/semantic-release-config"}}');

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_https-browserify_index_js-node_modules_stream-browserify_index_js-node_m-974c59.chunk.js.map