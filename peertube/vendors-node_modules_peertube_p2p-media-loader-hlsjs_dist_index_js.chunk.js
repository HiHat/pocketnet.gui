(globalThis["webpackChunkpeertube_client"] = globalThis["webpackChunkpeertube_client"] || []).push([["vendors-node_modules_peertube_p2p-media-loader-hlsjs_dist_index_js"],{

/***/ "./node_modules/@peertube/p2p-media-loader-core/dist/bandwidth-approximator.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@peertube/p2p-media-loader-core/dist/bandwidth-approximator.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2018 Novage LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BandwidthApproximator = void 0;

const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));

const debug = (0, debug_1.default)("p2pml:bandwidth-approximator");
const SMOOTH_INTERVAL = 2 * 1000;
const MEASURE_INTERVAL = 40 * 1000;

let NumberWithTime = /*#__PURE__*/_createClass(function NumberWithTime(value, timeStamp) {
  _classCallCheck(this, NumberWithTime);

  this.value = value;
  this.timeStamp = timeStamp;
});

let BandwidthApproximator = /*#__PURE__*/_createClass(function BandwidthApproximator() {
  _classCallCheck(this, BandwidthApproximator);

  this.lastBytes = [];
  this.currentBytesSum = 0;
  this.lastBandwidth = [];

  this.addBytes = (bytes, timeStamp) => {
    debug("Add %d bytes.", bytes);
    this.lastBytes.push(new NumberWithTime(bytes, timeStamp));
    this.currentBytesSum += bytes;

    while (timeStamp - this.lastBytes[0].timeStamp > SMOOTH_INTERVAL) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      this.currentBytesSum -= this.lastBytes.shift().value;
    }

    const interval = Math.min(SMOOTH_INTERVAL, timeStamp);
    this.lastBandwidth.push(new NumberWithTime(this.currentBytesSum / interval, timeStamp));
  }; // in bytes per millisecond


  this.getBandwidth = timeStamp => {
    while (this.lastBandwidth.length !== 0 && timeStamp - this.lastBandwidth[0].timeStamp > MEASURE_INTERVAL) {
      this.lastBandwidth.shift();
    }

    let maxBandwidth = 0;

    for (const bandwidth of this.lastBandwidth) {
      if (bandwidth.value > maxBandwidth) {
        maxBandwidth = bandwidth.value;
      }
    }

    debug("Max bandwidth: %d.", maxBandwidth);
    return maxBandwidth;
  };

  this.getSmoothInterval = () => {
    return SMOOTH_INTERVAL;
  };

  this.getMeasureInterval = () => {
    return MEASURE_INTERVAL;
  };
});

exports.BandwidthApproximator = BandwidthApproximator;

/***/ }),

/***/ "./node_modules/@peertube/p2p-media-loader-core/dist/http-media-manager.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@peertube/p2p-media-loader-core/dist/http-media-manager.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2018 Novage LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.HttpMediaManager = void 0;

const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));

const stringly_typed_event_emitter_1 = __webpack_require__(/*! ./stringly-typed-event-emitter */ "./node_modules/@peertube/p2p-media-loader-core/dist/stringly-typed-event-emitter.js");

let FilteredEmitter = /*#__PURE__*/function (_stringly_typed_event) {
  _inherits(FilteredEmitter, _stringly_typed_event);

  var _super = _createSuper(FilteredEmitter);

  function FilteredEmitter() {
    _classCallCheck(this, FilteredEmitter);

    return _super.apply(this, arguments);
  }

  return _createClass(FilteredEmitter);
}(stringly_typed_event_emitter_1.STEEmitter);

let HttpMediaManager = /*#__PURE__*/function (_FilteredEmitter) {
  _inherits(HttpMediaManager, _FilteredEmitter);

  var _super2 = _createSuper(HttpMediaManager);

  function HttpMediaManager(settings) {
    var _this;

    _classCallCheck(this, HttpMediaManager);

    _this = _super2.call(this);
    _this.settings = settings;
    _this.xhrRequests = new Map();
    _this.failedSegments = new Map();
    _this.debug = (0, debug_1.default)("p2pml:http-media-manager");

    _this.download = (segment, downloadedPieces) => {
      if (_this.isDownloading(segment)) {
        return;
      }

      _this.cleanTimedOutFailedSegments();

      _this.emit("segment-start-load", segment);

      const segmentUrl = segment.priority <= _this.settings.skipSegmentBuilderPriority ? segment.url : _this.buildSegmentUrl(segment);

      _this.debug("http segment download", segmentUrl);

      segment.requestUrl = segmentUrl;
      const xhr = new XMLHttpRequest();
      xhr.open("GET", segmentUrl, true);
      xhr.responseType = "arraybuffer";

      if (segment.range) {
        xhr.setRequestHeader("Range", segment.range);
        downloadedPieces = undefined; // TODO: process downloadedPieces for segments with range headers too
      } else if (downloadedPieces !== undefined && _this.settings.httpUseRanges) {
        let bytesDownloaded = 0;

        for (const piece of downloadedPieces) {
          bytesDownloaded += piece.byteLength;
        }

        xhr.setRequestHeader("Range", "bytes=".concat(bytesDownloaded, "-"));

        _this.debug("continue download from", bytesDownloaded);
      } else {
        downloadedPieces = undefined;
      }

      _this.setupXhrEvents(xhr, segment, downloadedPieces);

      if (_this.settings.xhrSetup) {
        _this.settings.xhrSetup(xhr, segmentUrl);
      }

      _this.xhrRequests.set(segment.id, {
        xhr,
        segment,
        initialPriority: segment.priority,
        segmentUrl
      });

      xhr.send();
    };

    _this.updatePriority = segment => {
      const request = _this.xhrRequests.get(segment.id);

      if (!request) {
        throw new Error("Cannot update priority of not downloaded segment " + segment.id);
      } // Segment is now in high priority
      // If the segment URL changed, retry the request with the new URL


      if (segment.priority <= _this.settings.skipSegmentBuilderPriority && request.initialPriority > _this.settings.skipSegmentBuilderPriority && request.segmentUrl !== segment.url) {
        _this.debug("aborting http segment because the segment is now in a high priority", segment.id);

        _this.abort(segment);

        _this.download(segment);
      }
    };

    _this.abort = segment => {
      const request = _this.xhrRequests.get(segment.id);

      if (request) {
        request.xhr.abort();

        _this.xhrRequests.delete(segment.id);

        _this.debug("http segment abort", segment.id);
      }
    };

    _this.isDownloading = segment => {
      return _this.xhrRequests.has(segment.id);
    };

    _this.isFailed = segment => {
      const time = _this.failedSegments.get(segment.id);

      return time !== undefined && time > _this.now();
    };

    _this.getActiveDownloads = () => {
      return _this.xhrRequests;
    };

    _this.getActiveDownloadsCount = () => {
      return _this.xhrRequests.size;
    };

    _this.destroy = () => {
      _this.xhrRequests.forEach(request => request.xhr.abort());

      _this.xhrRequests.clear();
    };

    _this.setupXhrEvents = (xhr, segment, downloadedPieces) => {
      let prevBytesLoaded = 0;
      xhr.addEventListener("progress", event => {
        const bytesLoaded = event.loaded - prevBytesLoaded;

        _this.emit("bytes-downloaded", segment, bytesLoaded);

        prevBytesLoaded = event.loaded;

        if (event.lengthComputable) {
          _this.emit("segment-size", segment, event.total);
        }
      });
      xhr.addEventListener("load", async event => {
        if (xhr.status < 200 || xhr.status >= 300) {
          _this.segmentFailure(segment, event, xhr);

          return;
        }

        let data = xhr.response;

        if (downloadedPieces !== undefined && xhr.status === 206) {
          let bytesDownloaded = 0;

          for (const piece of downloadedPieces) {
            bytesDownloaded += piece.byteLength;
          }

          const segmentData = new Uint8Array(bytesDownloaded + data.byteLength);
          let offset = 0;

          for (const piece of downloadedPieces) {
            segmentData.set(new Uint8Array(piece), offset);
            offset += piece.byteLength;
          }

          segmentData.set(new Uint8Array(data), offset);
          data = segmentData.buffer;
        }

        await _this.segmentDownloadFinished(segment, data, xhr);
      });
      xhr.addEventListener("error", event => {
        _this.segmentFailure(segment, event, xhr);
      });
      xhr.addEventListener("timeout", event => {
        _this.segmentFailure(segment, event, xhr);
      });
    };

    _this.segmentDownloadFinished = async (segment, data, xhr) => {
      segment.responseUrl = xhr.responseURL === null ? undefined : xhr.responseURL;

      if (_this.settings.segmentValidator) {
        try {
          await _this.settings.segmentValidator(Object.assign(Object.assign({}, segment), {
            data: data
          }), "http");
        } catch (error) {
          _this.debug("segment validator failed", error);

          _this.segmentFailure(segment, error, xhr);

          return;
        }
      }

      _this.xhrRequests.delete(segment.id);

      _this.emit("segment-loaded", segment, data);
    };

    _this.segmentFailure = (segment, error, xhr) => {
      segment.responseUrl = xhr.responseURL === null ? undefined : xhr.responseURL;

      _this.xhrRequests.delete(segment.id);

      _this.failedSegments.set(segment.id, _this.now() + _this.settings.httpFailedSegmentTimeout);

      _this.emit("segment-error", segment, error);
    };

    _this.cleanTimedOutFailedSegments = () => {
      const now = _this.now();

      const candidates = [];

      _this.failedSegments.forEach((time, id) => {
        if (time < now) {
          candidates.push(id);
        }
      });

      candidates.forEach(id => _this.failedSegments.delete(id));
    };

    _this.now = () => performance.now();

    return _this;
  }

  _createClass(HttpMediaManager, [{
    key: "buildSegmentUrl",
    value: function buildSegmentUrl(segment) {
      if (this.settings.segmentUrlBuilder) {
        return this.settings.segmentUrlBuilder(segment);
      }

      return segment.url;
    }
  }]);

  return HttpMediaManager;
}(FilteredEmitter);

exports.HttpMediaManager = HttpMediaManager;

/***/ }),

/***/ "./node_modules/@peertube/p2p-media-loader-core/dist/hybrid-loader.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@peertube/p2p-media-loader-core/dist/hybrid-loader.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2018 Novage LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.HybridLoader = void 0;

const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));

const events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");

const simple_peer_1 = __importDefault(__webpack_require__(/*! simple-peer */ "./node_modules/simple-peer/index.js"));

const loader_interface_1 = __webpack_require__(/*! ./loader-interface */ "./node_modules/@peertube/p2p-media-loader-core/dist/loader-interface.js");

const http_media_manager_1 = __webpack_require__(/*! ./http-media-manager */ "./node_modules/@peertube/p2p-media-loader-core/dist/http-media-manager.js");

const p2p_media_manager_1 = __webpack_require__(/*! ./p2p-media-manager */ "./node_modules/@peertube/p2p-media-loader-core/dist/p2p-media-manager.js");

const media_peer_1 = __webpack_require__(/*! ./media-peer */ "./node_modules/@peertube/p2p-media-loader-core/dist/media-peer.js");

const bandwidth_approximator_1 = __webpack_require__(/*! ./bandwidth-approximator */ "./node_modules/@peertube/p2p-media-loader-core/dist/bandwidth-approximator.js");

const segments_memory_storage_1 = __webpack_require__(/*! ./segments-memory-storage */ "./node_modules/@peertube/p2p-media-loader-core/dist/segments-memory-storage.js");

const defaultSettings = {
  cachedSegmentExpiration: 5 * 60 * 1000,
  cachedSegmentsCount: 30,
  useP2P: true,
  consumeOnly: false,
  requiredSegmentsPriority: 1,
  skipSegmentBuilderPriority: 1,
  simultaneousHttpDownloads: 2,
  httpDownloadProbability: 0.1,
  httpDownloadProbabilityInterval: 1000,
  httpDownloadProbabilitySkipIfNoPeers: false,
  httpFailedSegmentTimeout: 10000,
  httpDownloadMaxPriority: 20,
  httpDownloadInitialTimeout: 0,
  httpDownloadInitialTimeoutPerSegment: 4000,
  httpUseRanges: false,
  simultaneousP2PDownloads: 3,
  p2pDownloadMaxPriority: 20,
  p2pSegmentDownloadTimeout: 60000,
  webRtcMaxMessageSize: 64 * 1024 - 1,
  trackerAnnounce: ["wss://tracker.novage.com.ua", "wss://tracker.openwebtorrent.com"],
  peerRequestsPerAnnounce: 10,
  rtcConfig: simple_peer_1.default.config
};

let HybridLoader = /*#__PURE__*/function (_events_1$EventEmitte) {
  _inherits(HybridLoader, _events_1$EventEmitte);

  var _super = _createSuper(HybridLoader);

  function HybridLoader() {
    var _this;

    let settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, HybridLoader);

    _this = _super.call(this);
    _this.debug = (0, debug_1.default)("p2pml:hybrid-loader");
    _this.debugSegments = (0, debug_1.default)("p2pml:hybrid-loader-segments");
    _this.segmentsQueue = [];
    _this.bandwidthApproximator = new bandwidth_approximator_1.BandwidthApproximator();
    _this.httpDownloadInitialTimeoutTimestamp = -Infinity;

    _this.createHttpManager = () => {
      return new http_media_manager_1.HttpMediaManager(_this.settings);
    };

    _this.createP2PManager = () => {
      return new p2p_media_manager_1.P2PMediaManager(_this.segmentsStorage, _this.settings);
    };

    _this.load = async (segments, streamSwarmId) => {
      _this.initRandomDownloadIntervalIfNeeded();

      if (segments.length > 0) {
        _this.masterSwarmId = segments[0].masterSwarmId;
      }

      if (_this.masterSwarmId !== undefined) {
        _this.p2pManager.setStreamSwarmId(streamSwarmId, _this.masterSwarmId);
      }

      _this.debug("load segments"); // stop all http requests and p2p downloads for segments that are not in the new load


      let updateSegmentsMap = _this.abortUnknownSegments(segments);

      if (_this.debug.enabled) {
        for (const segment of segments) {
          if (!_this.segmentsQueue.find(f => f.id === segment.id)) {
            _this.debug("add segment", segment.id);
          }
        }
      }

      _this.segmentsQueue = segments;

      if (_this.masterSwarmId === undefined) {
        return;
      }

      let storageSegments = await _this.segmentsStorage.getSegmentsMap(_this.masterSwarmId);
      updateSegmentsMap = _this.processSegmentsQueue(storageSegments) || updateSegmentsMap;

      if (await _this.cleanSegmentsStorage()) {
        storageSegments = await _this.segmentsStorage.getSegmentsMap(_this.masterSwarmId);
        updateSegmentsMap = true;
      }

      if (updateSegmentsMap && !_this.settings.consumeOnly) {
        _this.p2pManager.sendSegmentsMapToAll(_this.createSegmentsMap(storageSegments));
      }
    };

    _this.getSegment = async id => {
      return _this.masterSwarmId === undefined ? undefined : _this.segmentsStorage.getSegment(id, _this.masterSwarmId);
    };

    _this.getSettings = () => {
      return _this.settings;
    };

    _this.getDetails = () => {
      return {
        peerId: _this.p2pManager.getPeerId()
      };
    };

    _this.getBandwidthEstimate = () => {
      return _this.bandwidthApproximator.getBandwidth(_this.now());
    };

    _this.destroy = async () => {
      if (_this.httpRandomDownloadInterval !== undefined) {
        clearInterval(_this.httpRandomDownloadInterval);
        _this.httpRandomDownloadInterval = undefined;
      }

      _this.httpDownloadInitialTimeoutTimestamp = -Infinity;
      _this.segmentsQueue = [];

      _this.httpManager.destroy();

      _this.p2pManager.destroy();

      _this.masterSwarmId = undefined;
      await _this.segmentsStorage.destroy();
    };

    _this.processInitialSegmentTimeout = async () => {
      if (_this.httpRandomDownloadInterval === undefined) {
        return; // Instance destroyed
      }

      if (_this.masterSwarmId !== undefined) {
        const storageSegments = await _this.segmentsStorage.getSegmentsMap(_this.masterSwarmId);

        if (_this.processSegmentsQueue(storageSegments) && !_this.settings.consumeOnly) {
          _this.p2pManager.sendSegmentsMapToAll(_this.createSegmentsMap(storageSegments));
        }
      }

      if (_this.httpDownloadInitialTimeoutTimestamp !== -Infinity) {
        // Set one more timeout for a next segment
        setTimeout(_this.processInitialSegmentTimeout, _this.settings.httpDownloadInitialTimeoutPerSegment);
      }
    };

    _this.processSegmentsQueue = storageSegments => {
      const currentPriority = _this.segmentsQueue.length > 0 ? _this.segmentsQueue[0].priority : 0;

      _this.debugSegments("process segments queue. priority: ".concat(currentPriority, ", queue length: ").concat(_this.segmentsQueue.length));

      if (_this.masterSwarmId === undefined || _this.segmentsQueue.length === 0) {
        return false;
      }

      let updateSegmentsMap = false;
      let segmentsMap;
      let httpAllowed = true;

      if (_this.httpDownloadInitialTimeoutTimestamp !== -Infinity) {
        let firstNotDownloadePriority;

        for (const segment of _this.segmentsQueue) {
          if (!storageSegments.has(segment.id)) {
            firstNotDownloadePriority = segment.priority;
            break;
          }
        }

        const httpTimeout = _this.now() - _this.httpDownloadInitialTimeoutTimestamp;

        httpAllowed = httpTimeout >= _this.settings.httpDownloadInitialTimeout || firstNotDownloadePriority !== undefined && httpTimeout > _this.settings.httpDownloadInitialTimeoutPerSegment && firstNotDownloadePriority <= 0;

        if (httpAllowed) {
          _this.debugSegments("cancel initial HTTP download timeout - timed out");

          _this.httpDownloadInitialTimeoutTimestamp = -Infinity;
        }
      }

      let scheduleNewProcessQueue = false;

      for (let index = 0; index < _this.segmentsQueue.length; index++) {
        const segment = _this.segmentsQueue[index];

        if (storageSegments.has(segment.id)) {
          continue;
        } // Segment priority changed, notify http manager


        if (_this.httpManager.isDownloading(segment)) {
          _this.httpManager.updatePriority(segment);

          continue;
        }

        const tryHTTP = httpAllowed && segment.priority <= _this.settings.requiredSegmentsPriority;

        if (tryHTTP && !_this.httpManager.isFailed(segment)) {
          // Download required segments over HTTP
          if (_this.httpManager.getActiveDownloadsCount() >= _this.settings.simultaneousHttpDownloads) {
            // Not enough HTTP download resources. Abort one of the HTTP downloads.
            for (let i = _this.segmentsQueue.length - 1; i > index; i--) {
              const segmentToAbort = _this.segmentsQueue[i];

              if (_this.httpManager.isDownloading(segmentToAbort)) {
                _this.debugSegments("cancel HTTP download", segmentToAbort.priority, segmentToAbort.id);

                _this.httpManager.abort(segmentToAbort);

                break;
              }
            }
          }

          if (_this.httpManager.getActiveDownloadsCount() < _this.settings.simultaneousHttpDownloads) {
            // Abort P2P download of the required segment if any and force HTTP download
            const downloadedPieces = _this.p2pManager.abort(segment);

            _this.httpManager.download(segment, downloadedPieces);

            _this.debugSegments("HTTP download (priority)", segment.priority, segment.id);

            updateSegmentsMap = true;
            continue;
          }
        } // We wanted to download a failed segment through HTTP, but we could not because of the timeout.
        // Then we need to schedule another processing queue task


        if (tryHTTP && _this.httpManager.isFailed(segment)) {
          scheduleNewProcessQueue = true;
        }

        if (_this.p2pManager.isDownloading(segment)) {
          continue;
        }

        if (segment.priority <= _this.settings.requiredSegmentsPriority) {
          // Download required segments over P2P
          segmentsMap = segmentsMap ? segmentsMap : _this.p2pManager.getOverallSegmentsMap();

          if (segmentsMap.get(segment.id) !== media_peer_1.MediaPeerSegmentStatus.Loaded) {
            continue;
          }

          if (_this.p2pManager.getActiveDownloadsCount() >= _this.settings.simultaneousP2PDownloads) {
            // Not enough P2P download resources. Abort one of the P2P downloads.
            for (let i = _this.segmentsQueue.length - 1; i > index; i--) {
              const segmentToAbort = _this.segmentsQueue[i];

              if (_this.p2pManager.isDownloading(segmentToAbort)) {
                _this.debugSegments("cancel P2P download", segmentToAbort.priority, segmentToAbort.id);

                _this.p2pManager.abort(segmentToAbort);

                break;
              }
            }
          }

          if (_this.p2pManager.getActiveDownloadsCount() < _this.settings.simultaneousP2PDownloads) {
            if (_this.p2pManager.download(segment)) {
              _this.debugSegments("P2P download (priority)", segment.priority, segment.id);

              continue;
            }
          }

          continue;
        }

        if (_this.p2pManager.getActiveDownloadsCount() < _this.settings.simultaneousP2PDownloads && segment.priority <= _this.settings.p2pDownloadMaxPriority) {
          if (_this.p2pManager.download(segment)) {
            _this.debugSegments("P2P download", segment.priority, segment.id);
          }
        }
      }

      if (scheduleNewProcessQueue) {
        setTimeout(async () => {
          if (_this.masterSwarmId === undefined) return;
          const storageSegments = await _this.segmentsStorage.getSegmentsMap(_this.masterSwarmId);

          _this.processSegmentsQueue(storageSegments);
        }, _this.settings.httpFailedSegmentTimeout);
      }

      return updateSegmentsMap;
    };

    _this.downloadRandomSegmentOverHttp = async () => {
      if (_this.masterSwarmId === undefined || _this.httpRandomDownloadInterval === undefined || _this.httpDownloadInitialTimeoutTimestamp !== -Infinity || _this.httpManager.getActiveDownloadsCount() >= _this.settings.simultaneousHttpDownloads || _this.settings.httpDownloadProbabilitySkipIfNoPeers && _this.p2pManager.getPeers().size === 0 || _this.settings.consumeOnly) {
        return;
      }

      const storageSegments = await _this.segmentsStorage.getSegmentsMap(_this.masterSwarmId);

      const segmentsMap = _this.p2pManager.getOverallSegmentsMap();

      const pendingQueue = _this.segmentsQueue.filter(s => !_this.p2pManager.isDownloading(s) && !_this.httpManager.isDownloading(s) && !segmentsMap.has(s.id) && !_this.httpManager.isFailed(s) && s.priority <= _this.settings.httpDownloadMaxPriority && !storageSegments.has(s.id));

      if (pendingQueue.length === 0) {
        return;
      }

      if (Math.random() > _this.settings.httpDownloadProbability * pendingQueue.length) {
        return;
      }

      const segment = pendingQueue[Math.floor(Math.random() * pendingQueue.length)];

      _this.debugSegments("HTTP download (random)", segment.priority, segment.id);

      _this.httpManager.download(segment);

      _this.p2pManager.sendSegmentsMapToAll(_this.createSegmentsMap(storageSegments));
    };

    _this.onSegmentStartLoad = (method, segment) => {
      _this.emit(loader_interface_1.Events.SegmentStartLoad, method, segment);
    };

    _this.onPieceBytesDownloaded = (method, segment, bytes, peerId) => {
      _this.bandwidthApproximator.addBytes(bytes, _this.now());

      _this.emit(loader_interface_1.Events.PieceBytesDownloaded, method, segment, bytes, peerId);
    };

    _this.onPieceBytesUploaded = (method, segment, bytes, peerId) => {
      _this.emit(loader_interface_1.Events.PieceBytesUploaded, method, segment, bytes, peerId);
    };

    _this.onSegmentLoaded = async (segment, data, peerId) => {
      _this.debugSegments("segment loaded", segment.id, segment.id);

      if (_this.masterSwarmId === undefined) {
        return;
      }

      segment.data = data;
      segment.downloadBandwidth = _this.bandwidthApproximator.getBandwidth(_this.now());
      await _this.segmentsStorage.storeSegment(segment);

      _this.emit(loader_interface_1.Events.SegmentLoaded, segment, peerId);

      const storageSegments = await _this.segmentsStorage.getSegmentsMap(_this.masterSwarmId);

      _this.processSegmentsQueue(storageSegments);

      if (!_this.settings.consumeOnly) {
        _this.p2pManager.sendSegmentsMapToAll(_this.createSegmentsMap(storageSegments));
      }
    };

    _this.onSegmentError = async (segment, details, peerId) => {
      _this.debugSegments("segment error", segment.id, segment.id, peerId, details);

      _this.emit(loader_interface_1.Events.SegmentError, segment, details, peerId);

      if (_this.masterSwarmId !== undefined) {
        const storageSegments = await _this.segmentsStorage.getSegmentsMap(_this.masterSwarmId);

        if (_this.processSegmentsQueue(storageSegments) && !_this.settings.consumeOnly) {
          _this.p2pManager.sendSegmentsMapToAll(_this.createSegmentsMap(storageSegments));
        }
      }
    };

    _this.onSegmentSize = async (segment, size) => {
      _this.debugSegments("segment size", segment.id, size);

      _this.emit(loader_interface_1.Events.SegmentSize, segment, size);
    };

    _this.getStreamSwarmId = segment => {
      return segment.streamId === undefined ? segment.masterSwarmId : "".concat(segment.masterSwarmId, "+").concat(segment.streamId);
    };

    _this.createSegmentsMap = storageSegments => {
      const segmentsMap = {};

      const addSegmentToMap = (segment, status) => {
        const streamSwarmId = _this.getStreamSwarmId(segment);

        const segmentId = segment.sequence;
        let segmentsIdsAndStatuses = segmentsMap[streamSwarmId];

        if (segmentsIdsAndStatuses === undefined) {
          segmentsIdsAndStatuses = ["", []];
          segmentsMap[streamSwarmId] = segmentsIdsAndStatuses;
        }

        const segmentsStatuses = segmentsIdsAndStatuses[1];
        segmentsIdsAndStatuses[0] += segmentsStatuses.length === 0 ? segmentId : "|".concat(segmentId);
        segmentsStatuses.push(status);
      };

      for (const storageSegment of storageSegments.values()) {
        addSegmentToMap(storageSegment.segment, media_peer_1.MediaPeerSegmentStatus.Loaded);
      }

      for (const download of _this.httpManager.getActiveDownloads().values()) {
        addSegmentToMap(download.segment, media_peer_1.MediaPeerSegmentStatus.LoadingByHttp);
      }

      return segmentsMap;
    };

    _this.onPeerConnect = async peer => {
      _this.emit(loader_interface_1.Events.PeerConnect, peer);

      if (!_this.settings.consumeOnly && _this.masterSwarmId !== undefined) {
        _this.p2pManager.sendSegmentsMap(peer.id, _this.createSegmentsMap(await _this.segmentsStorage.getSegmentsMap(_this.masterSwarmId)));
      }
    };

    _this.onPeerClose = peerId => {
      _this.emit(loader_interface_1.Events.PeerClose, peerId);
    };

    _this.onTrackerUpdate = async data => {
      if (_this.httpDownloadInitialTimeoutTimestamp !== -Infinity && data.incomplete !== undefined && data.incomplete <= 1) {
        _this.debugSegments("cancel initial HTTP download timeout - no peers");

        _this.httpDownloadInitialTimeoutTimestamp = -Infinity;

        if (_this.masterSwarmId !== undefined) {
          const storageSegments = await _this.segmentsStorage.getSegmentsMap(_this.masterSwarmId);

          if (_this.processSegmentsQueue(storageSegments) && !_this.settings.consumeOnly) {
            _this.p2pManager.sendSegmentsMapToAll(_this.createSegmentsMap(storageSegments));
          }
        }
      }
    };

    _this.cleanSegmentsStorage = async () => {
      if (_this.masterSwarmId === undefined) {
        return false;
      }

      return _this.segmentsStorage.clean(_this.masterSwarmId, id => _this.segmentsQueue.find(queueSegment => queueSegment.id === id) !== undefined);
    };

    _this.now = () => {
      return performance.now();
    };

    _this.initRandomDownloadIntervalIfNeeded = () => {
      if (_this.httpRandomDownloadInterval !== undefined) return; // Do once on first call

      _this.httpRandomDownloadInterval = setInterval(_this.downloadRandomSegmentOverHttp, _this.settings.httpDownloadProbabilityInterval);

      if (_this.settings.httpDownloadInitialTimeout > 0 && _this.settings.httpDownloadInitialTimeoutPerSegment > 0) {
        // Initialize initial HTTP download timeout (i.e. download initial segments over P2P)
        _this.debugSegments("enable initial HTTP download timeout", _this.settings.httpDownloadInitialTimeout, "per segment", _this.settings.httpDownloadInitialTimeoutPerSegment);

        _this.httpDownloadInitialTimeoutTimestamp = _this.now();
        setTimeout(_this.processInitialSegmentTimeout, _this.settings.httpDownloadInitialTimeoutPerSegment + 100);
      }
    };

    _this.abortUnknownSegments = segments => {
      let updateSegmentsMap = false;

      for (const segment of _this.segmentsQueue) {
        if (!segments.find(f => f.id === segment.id)) {
          _this.debug("remove segment", segment.id);

          if (_this.httpManager.isDownloading(segment)) {
            updateSegmentsMap = true;

            _this.httpManager.abort(segment);
          } else {
            _this.p2pManager.abort(segment);
          }

          _this.emit(loader_interface_1.Events.SegmentAbort, segment);
        }
      }

      return updateSegmentsMap;
    };

    _this.settings = Object.assign(Object.assign({}, defaultSettings), settings);
    const {
      bufferedSegmentsCount
    } = settings;

    if (typeof bufferedSegmentsCount === "number") {
      if (settings.p2pDownloadMaxPriority === undefined) {
        _this.settings.p2pDownloadMaxPriority = bufferedSegmentsCount;
      }

      if (settings.httpDownloadMaxPriority === undefined) {
        _this.settings.p2pDownloadMaxPriority = bufferedSegmentsCount;
      }
    }

    _this.segmentsStorage = _this.settings.segmentsStorage === undefined ? new segments_memory_storage_1.SegmentsMemoryStorage(_this.settings) : _this.settings.segmentsStorage;

    _this.debug("loader settings", _this.settings);

    _this.httpManager = _this.createHttpManager();

    _this.httpManager.on("segment-start-load", segment => _this.onSegmentStartLoad("http", segment));

    _this.httpManager.on("segment-loaded", _this.onSegmentLoaded);

    _this.httpManager.on("segment-error", _this.onSegmentError);

    _this.httpManager.on("segment-size", _this.onSegmentSize);

    _this.httpManager.on("bytes-downloaded", (segment, bytes) => {
      _this.onPieceBytesDownloaded("http", segment, bytes);
    });

    _this.p2pManager = _this.createP2PManager();

    _this.p2pManager.on("segment-start-load", segment => _this.onSegmentStartLoad("p2p", segment));

    _this.p2pManager.on("segment-loaded", _this.onSegmentLoaded);

    _this.p2pManager.on("segment-error", _this.onSegmentError);

    _this.p2pManager.on("segment-size", _this.onSegmentSize);

    _this.p2pManager.on("peer-data-updated", async () => {
      if (_this.masterSwarmId === undefined) {
        return;
      }

      const storageSegments = await _this.segmentsStorage.getSegmentsMap(_this.masterSwarmId);

      if (_this.processSegmentsQueue(storageSegments) && !_this.settings.consumeOnly) {
        _this.p2pManager.sendSegmentsMapToAll(_this.createSegmentsMap(storageSegments));
      }
    });

    _this.p2pManager.on("bytes-downloaded", (segment, bytes, peerId) => _this.onPieceBytesDownloaded("p2p", segment, bytes, peerId));

    _this.p2pManager.on("bytes-uploaded", (segment, bytes, peerId) => _this.onPieceBytesUploaded("p2p", segment, bytes, peerId));

    _this.p2pManager.on("peer-connected", _this.onPeerConnect);

    _this.p2pManager.on("peer-closed", _this.onPeerClose);

    _this.p2pManager.on("tracker-update", _this.onTrackerUpdate);

    return _this;
  }

  return _createClass(HybridLoader);
}(events_1.EventEmitter);

exports.HybridLoader = HybridLoader;

HybridLoader.isSupported = () => {
  return window.RTCPeerConnection.prototype.createDataChannel !== undefined;
};

/***/ }),

/***/ "./node_modules/@peertube/p2p-media-loader-core/dist/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@peertube/p2p-media-loader-core/dist/index.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * @license Apache-2.0
 * Copyright 2018 Novage LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function () {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.version = void 0;
exports.version = "0.6.2";

__exportStar(__webpack_require__(/*! ./loader-interface */ "./node_modules/@peertube/p2p-media-loader-core/dist/loader-interface.js"), exports);

__exportStar(__webpack_require__(/*! ./hybrid-loader */ "./node_modules/@peertube/p2p-media-loader-core/dist/hybrid-loader.js"), exports);

/***/ }),

/***/ "./node_modules/@peertube/p2p-media-loader-core/dist/loader-interface.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@peertube/p2p-media-loader-core/dist/loader-interface.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2018 Novage LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Events = void 0;
var Events;

(function (Events) {
  /**
   * Emitted when segment has been downloaded.
   * Args: segment
   */
  Events["SegmentLoaded"] = "segment_loaded";
  /**
   * Emitted when an error occurred while loading the segment.
   * Args: segment, error
   */

  Events["SegmentError"] = "segment_error";
  /**
   * Emitter when we the segment size is known
   * Args: segment, size
   */

  Events["SegmentSize"] = "segment_size";
  /**
   * Emitted for each segment that does not hit into a new segments queue when the load() method is called.
   * Args: segment
   */

  Events["SegmentAbort"] = "segment_abort";
  /**
   * Emitted when the loader started to load a segment
   * Args: method, segment
   */

  Events["SegmentStartLoad"] = "segment_start_load";
  /**
   * Emitted when a peer is connected.
   * Args: peer
   */

  Events["PeerConnect"] = "peer_connect";
  /**
   * Emitted when a peer is disconnected.
   * Args: peerId
   */

  Events["PeerClose"] = "peer_close";
  /**
   * Emitted when a segment piece has been downloaded.
   * Args: method (can be "http" or "p2p" only), bytes
   */

  Events["PieceBytesDownloaded"] = "piece_bytes_downloaded";
  /**
   * Emitted when a segment piece has been uploaded.
   * Args: method (can be "p2p" only), bytes
   */

  Events["PieceBytesUploaded"] = "piece_bytes_uploaded";
})(Events = exports.Events || (exports.Events = {}));

/***/ }),

/***/ "./node_modules/@peertube/p2p-media-loader-core/dist/media-peer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@peertube/p2p-media-loader-core/dist/media-peer.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2018 Novage LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MediaPeer = exports.MediaPeerSegmentStatus = void 0;
/* eslint-disable @typescript-eslint/no-unsafe-call */

/* eslint-disable @typescript-eslint/no-unsafe-member-access */

/* eslint-disable @typescript-eslint/no-unsafe-assignment */

const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));

const buffer_1 = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");

const stringly_typed_event_emitter_1 = __webpack_require__(/*! ./stringly-typed-event-emitter */ "./node_modules/@peertube/p2p-media-loader-core/dist/stringly-typed-event-emitter.js");

var MediaPeerCommands;

(function (MediaPeerCommands) {
  MediaPeerCommands[MediaPeerCommands["SegmentData"] = 0] = "SegmentData";
  MediaPeerCommands[MediaPeerCommands["SegmentAbsent"] = 1] = "SegmentAbsent";
  MediaPeerCommands[MediaPeerCommands["SegmentsMap"] = 2] = "SegmentsMap";
  MediaPeerCommands[MediaPeerCommands["SegmentRequest"] = 3] = "SegmentRequest";
  MediaPeerCommands[MediaPeerCommands["CancelSegmentRequest"] = 4] = "CancelSegmentRequest";
})(MediaPeerCommands || (MediaPeerCommands = {}));

var MediaPeerSegmentStatus;

(function (MediaPeerSegmentStatus) {
  MediaPeerSegmentStatus[MediaPeerSegmentStatus["Loaded"] = 0] = "Loaded";
  MediaPeerSegmentStatus[MediaPeerSegmentStatus["LoadingByHttp"] = 1] = "LoadingByHttp";
})(MediaPeerSegmentStatus = exports.MediaPeerSegmentStatus || (exports.MediaPeerSegmentStatus = {}));

let DownloadingSegment = /*#__PURE__*/_createClass(function DownloadingSegment(id, size) {
  _classCallCheck(this, DownloadingSegment);

  this.id = id;
  this.size = size;
  this.bytesDownloaded = 0;
  this.pieces = [];
});

let MediaPeer = /*#__PURE__*/function (_stringly_typed_event) {
  _inherits(MediaPeer, _stringly_typed_event);

  var _super = _createSuper(MediaPeer);

  function MediaPeer( // eslint-disable-next-line
  peer, settings) {
    var _this;

    _classCallCheck(this, MediaPeer);

    _this = _super.call(this);
    _this.peer = peer;
    _this.settings = settings;
    _this.remoteAddress = "";
    _this.downloadingSegmentId = null;
    _this.downloadingSegment = null;
    _this.segmentsMap = new Map();
    _this.debug = (0, debug_1.default)("p2pml:media-peer");
    _this.timer = null;

    _this.onPeerConnect = () => {
      _this.debug("peer connect", _this.id, _assertThisInitialized(_this));

      _this.remoteAddress = _this.peer.remoteAddress;

      _this.emit("connect", _assertThisInitialized(_this));
    };

    _this.onPeerClose = () => {
      _this.debug("peer close", _this.id, _assertThisInitialized(_this));

      _this.terminateSegmentRequest();

      _this.emit("close", _assertThisInitialized(_this));
    };

    _this.onPeerError = error => {
      _this.debug("peer error", _this.id, error, _assertThisInitialized(_this));
    };

    _this.receiveSegmentPiece = data => {
      if (!_this.downloadingSegment) {
        // The segment was not requested or canceled
        _this.debug("peer segment not requested", _this.id, _assertThisInitialized(_this));

        return;
      }

      _this.downloadingSegment.bytesDownloaded += data.byteLength;

      _this.downloadingSegment.pieces.push(data);

      const segmentId = _this.downloadingSegment.id;

      _this.emit("bytes-downloaded", _assertThisInitialized(_this), segmentId, data.byteLength);

      if (_this.downloadingSegment.bytesDownloaded === _this.downloadingSegment.size) {
        const segmentData = new Uint8Array(_this.downloadingSegment.size);
        let offset = 0;

        for (const piece of _this.downloadingSegment.pieces) {
          segmentData.set(new Uint8Array(piece), offset);
          offset += piece.byteLength;
        }

        _this.debug("peer segment download done", _this.id, segmentId, _assertThisInitialized(_this));

        _this.terminateSegmentRequest();

        _this.emit("segment-loaded", _assertThisInitialized(_this), segmentId, segmentData.buffer);
      } else if (_this.downloadingSegment.bytesDownloaded > _this.downloadingSegment.size) {
        _this.debug("peer segment download bytes mismatch", _this.id, segmentId, _assertThisInitialized(_this));

        _this.terminateSegmentRequest();

        _this.emit("segment-error", _assertThisInitialized(_this), segmentId, "Too many bytes received for segment");
      }
    };

    _this.getJsonCommand = data => {
      const bytes = new Uint8Array(data); // Serialized JSON string check by first, second and last characters: '{" .... }'

      if (bytes[0] === 123 && bytes[1] === 34 && bytes[data.byteLength - 1] === 125) {
        try {
          return JSON.parse(new TextDecoder().decode(data));
        } catch (_a) {
          return null;
        }
      }

      return null;
    };

    _this.onPeerData = data => {
      const command = _this.getJsonCommand(data);

      if (command === null) {
        _this.receiveSegmentPiece(data);

        return;
      }

      if (_this.downloadingSegment) {
        _this.debug("peer segment download is interrupted by a command", _this.id, _assertThisInitialized(_this));

        const segmentId = _this.downloadingSegment.id;

        _this.terminateSegmentRequest();

        _this.emit("segment-error", _assertThisInitialized(_this), segmentId, "Segment download is interrupted by a command");

        return;
      }

      _this.debug("peer receive command", _this.id, command, _assertThisInitialized(_this));

      switch (command.c) {
        case MediaPeerCommands.SegmentsMap:
          _this.segmentsMap = _this.createSegmentsMap(command.m);

          _this.emit("data-updated");

          break;

        case MediaPeerCommands.SegmentRequest:
          _this.emit("segment-request", _assertThisInitialized(_this), command.i);

          break;

        case MediaPeerCommands.SegmentData:
          if (_this.downloadingSegmentId && _this.downloadingSegmentId === command.i && typeof command.s === "number" && command.s >= 0) {
            _this.downloadingSegment = new DownloadingSegment(command.i, command.s);

            _this.emit("segment-start-load", _this.downloadingSegment.id);

            _this.emit("segment-size", _this.downloadingSegment.id, _this.downloadingSegment.size);

            _this.cancelResponseTimeoutTimer();
          }

          break;

        case MediaPeerCommands.SegmentAbsent:
          if (_this.downloadingSegmentId && _this.downloadingSegmentId === command.i) {
            _this.terminateSegmentRequest();

            _this.segmentsMap.delete(command.i);

            _this.emit("segment-absent", _assertThisInitialized(_this), command.i);
          }

          break;

        case MediaPeerCommands.CancelSegmentRequest:
          // TODO: peer stop sending buffer
          break;

        default:
          break;
      }
    };

    _this.createSegmentsMap = segments => {
      if (!(segments instanceof Object)) {
        return new Map();
      }

      const segmentsMap = new Map();

      for (const streamSwarmId of Object.keys(segments)) {
        const swarmData = segments[streamSwarmId];

        if (!(swarmData instanceof Array) || swarmData.length !== 2 || typeof swarmData[0] !== "string" || !(swarmData[1] instanceof Array)) {
          return new Map();
        }

        const segmentsIds = swarmData[0].split("|");
        const segmentsStatuses = swarmData[1];

        if (segmentsIds.length !== segmentsStatuses.length) {
          return new Map();
        }

        for (let i = 0; i < segmentsIds.length; i++) {
          const segmentStatus = segmentsStatuses[i];

          if (typeof segmentStatus !== "number" || MediaPeerSegmentStatus[segmentStatus] === undefined) {
            return new Map();
          }

          segmentsMap.set("".concat(streamSwarmId, "+").concat(segmentsIds[i]), segmentStatus);
        }
      }

      return segmentsMap;
    };

    _this.sendCommand = command => {
      _this.debug("peer send command", _this.id, command, _assertThisInitialized(_this));

      _this.peer.write(JSON.stringify(command));
    };

    _this.destroy = () => {
      _this.debug("peer destroy", _this.id, _assertThisInitialized(_this));

      _this.terminateSegmentRequest();

      _this.peer.destroy();
    };

    _this.getDownloadingSegmentId = () => {
      return _this.downloadingSegmentId;
    };

    _this.getSegmentsMap = () => {
      return _this.segmentsMap;
    };

    _this.sendSegmentsMap = segmentsMap => {
      _this.sendCommand({
        c: MediaPeerCommands.SegmentsMap,
        m: segmentsMap
      });
    };

    _this.sendSegmentData = (segmentId, data) => {
      _this.sendCommand({
        c: MediaPeerCommands.SegmentData,
        i: segmentId,
        s: data.byteLength
      });

      let bytesLeft = data.byteLength;

      while (bytesLeft > 0) {
        const bytesToSend = bytesLeft >= _this.settings.webRtcMaxMessageSize ? _this.settings.webRtcMaxMessageSize : bytesLeft;
        const buffer = buffer_1.Buffer.from(data, data.byteLength - bytesLeft, bytesToSend);

        _this.peer.write(buffer);

        bytesLeft -= bytesToSend;
      }

      _this.emit("bytes-uploaded", _assertThisInitialized(_this), segmentId, data.byteLength);
    };

    _this.sendSegmentAbsent = segmentId => {
      _this.sendCommand({
        c: MediaPeerCommands.SegmentAbsent,
        i: segmentId
      });
    };

    _this.requestSegment = segmentId => {
      if (_this.downloadingSegmentId) {
        throw new Error("A segment is already downloading: " + _this.downloadingSegmentId);
      }

      _this.sendCommand({
        c: MediaPeerCommands.SegmentRequest,
        i: segmentId
      });

      _this.downloadingSegmentId = segmentId;

      _this.runResponseTimeoutTimer();
    };

    _this.cancelSegmentRequest = () => {
      let downloadingSegment;

      if (_this.downloadingSegmentId) {
        const segmentId = _this.downloadingSegmentId;
        downloadingSegment = _this.downloadingSegment ? _this.downloadingSegment.pieces : undefined;

        _this.terminateSegmentRequest();

        _this.sendCommand({
          c: MediaPeerCommands.CancelSegmentRequest,
          i: segmentId
        });
      }

      return downloadingSegment;
    };

    _this.runResponseTimeoutTimer = () => {
      _this.timer = setTimeout(() => {
        _this.timer = null;

        if (!_this.downloadingSegmentId) {
          return;
        }

        const segmentId = _this.downloadingSegmentId;

        _this.cancelSegmentRequest();

        _this.emit("segment-timeout", _assertThisInitialized(_this), segmentId); // TODO: send peer not responding event

      }, _this.settings.p2pSegmentDownloadTimeout);
    };

    _this.cancelResponseTimeoutTimer = () => {
      if (_this.timer) {
        clearTimeout(_this.timer);
        _this.timer = null;
      }
    };

    _this.terminateSegmentRequest = () => {
      _this.downloadingSegmentId = null;
      _this.downloadingSegment = null;

      _this.cancelResponseTimeoutTimer();
    };

    _this.peer.on("connect", _this.onPeerConnect);

    _this.peer.on("close", _this.onPeerClose);

    _this.peer.on("error", _this.onPeerError);

    _this.peer.on("data", _this.onPeerData);

    _this.id = peer.id;
    return _this;
  }

  return _createClass(MediaPeer);
}(stringly_typed_event_emitter_1.STEEmitter);

exports.MediaPeer = MediaPeer;

/***/ }),

/***/ "./node_modules/@peertube/p2p-media-loader-core/dist/p2p-media-manager.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@peertube/p2p-media-loader-core/dist/p2p-media-manager.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2018 Novage LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.P2PMediaManager = void 0;
/* eslint-disable @typescript-eslint/no-unsafe-assignment */

/* eslint-disable @typescript-eslint/no-unsafe-call */

/* eslint-disable @typescript-eslint/no-unsafe-member-access */

const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));

const client_1 = __importDefault(__webpack_require__(/*! bittorrent-tracker/client */ "./node_modules/bittorrent-tracker/client.js"));

const buffer_1 = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");

const sha1_1 = __importDefault(__webpack_require__(/*! sha.js/sha1 */ "./node_modules/sha.js/sha1.js"));

const stringly_typed_event_emitter_1 = __webpack_require__(/*! ./stringly-typed-event-emitter */ "./node_modules/@peertube/p2p-media-loader-core/dist/stringly-typed-event-emitter.js");

const media_peer_1 = __webpack_require__(/*! ./media-peer */ "./node_modules/@peertube/p2p-media-loader-core/dist/media-peer.js");

const index_1 = __webpack_require__(/*! ./index */ "./node_modules/@peertube/p2p-media-loader-core/dist/index.js");

const PEER_PROTOCOL_VERSION = 2;
const PEER_ID_VERSION_STRING = index_1.version.replace(/\d*./g, v => "0".concat(parseInt(v, 10) % 100).slice(-2)).slice(0, 4);
const PEER_ID_VERSION_PREFIX = "-WW".concat(PEER_ID_VERSION_STRING, "-"); // Using WebTorrent client ID in order to not be banned by websocket trackers

let PeerSegmentRequest = /*#__PURE__*/_createClass(function PeerSegmentRequest(peerId, segment) {
  _classCallCheck(this, PeerSegmentRequest);

  this.peerId = peerId;
  this.segment = segment;
});

function generatePeerId() {
  const PEER_ID_SYMBOLS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const PEER_ID_LENGTH = 20;
  let peerId = PEER_ID_VERSION_PREFIX;

  for (let i = 0; i < PEER_ID_LENGTH - PEER_ID_VERSION_PREFIX.length; i++) {
    peerId += PEER_ID_SYMBOLS.charAt(Math.floor(Math.random() * PEER_ID_SYMBOLS.length));
  }

  return new TextEncoder().encode(peerId).buffer;
}

let P2PMediaManager = /*#__PURE__*/function (_stringly_typed_event) {
  _inherits(P2PMediaManager, _stringly_typed_event);

  var _super = _createSuper(P2PMediaManager);

  function P2PMediaManager(segmentsStorage, settings) {
    var _this;

    _classCallCheck(this, P2PMediaManager);

    _this = _super.call(this);
    _this.segmentsStorage = segmentsStorage;
    _this.settings = settings; // eslint-disable-next-line @typescript-eslint/no-explicit-any

    _this.trackerClient = null;
    _this.peers = new Map();
    _this.peerCandidates = new Map();
    _this.peerSegmentRequests = new Map();
    _this.streamSwarmId = null;
    _this.debug = (0, debug_1.default)("p2pml:p2p-media-manager");
    _this.pendingTrackerClient = null;

    _this.getPeers = () => {
      return _this.peers;
    };

    _this.getPeerId = () => {
      return buffer_1.Buffer.from(_this.peerId).toString("hex");
    };

    _this.setStreamSwarmId = (streamSwarmId, masterSwarmId) => {
      if (_this.streamSwarmId === streamSwarmId) {
        return;
      }

      _this.destroy(true);

      _this.streamSwarmId = streamSwarmId;
      _this.masterSwarmId = masterSwarmId;

      _this.debug("stream swarm ID", _this.streamSwarmId);

      _this.pendingTrackerClient = {
        isDestroyed: false
      };
      const pendingTrackerClient = _this.pendingTrackerClient; // TODO: native browser 'crypto.subtle' implementation doesn't work in Chrome in insecure pages
      // TODO: Edge doesn't support SHA-1. Change to SHA-256 once Edge support is required.
      // const infoHash = await crypto.subtle.digest("SHA-1", new TextEncoder().encode(PEER_PROTOCOL_VERSION + this.streamSwarmId));

      const infoHash = new sha1_1.default().update("".concat(PEER_PROTOCOL_VERSION).concat(_this.streamSwarmId)).digest(); // destroy may be called while waiting for the hash to be calculated

      if (!pendingTrackerClient.isDestroyed) {
        _this.pendingTrackerClient = null;

        _this.createClient(infoHash);
      } else if (_this.trackerClient !== null) {
        _this.trackerClient.destroy();

        _this.trackerClient = null;
      }
    };

    _this.createClient = infoHash => {
      if (!_this.settings.useP2P) {
        return;
      }

      const clientOptions = {
        infoHash: buffer_1.Buffer.from(infoHash, 0, 20),
        peerId: buffer_1.Buffer.from(_this.peerId, 0, 20),
        announce: _this.settings.trackerAnnounce,
        rtcConfig: _this.settings.rtcConfig,
        port: 6881,
        getAnnounceOpts: () => {
          return {
            numwant: _this.settings.peerRequestsPerAnnounce
          };
        }
      };
      let oldTrackerClient = _this.trackerClient;
      _this.trackerClient = new client_1.default(clientOptions);

      _this.trackerClient.on("error", _this.onTrackerError);

      _this.trackerClient.on("warning", _this.onTrackerWarning);

      _this.trackerClient.on("update", _this.onTrackerUpdate);

      _this.trackerClient.on("peer", _this.onTrackerPeer);

      _this.trackerClient.start();

      if (oldTrackerClient !== null) {
        oldTrackerClient.destroy();
        oldTrackerClient = null;
      }
    };

    _this.onTrackerError = error => {
      _this.debug("tracker error", error);
    };

    _this.onTrackerWarning = warning => {
      _this.debug("tracker warning", warning);
    };

    _this.onTrackerUpdate = data => {
      _this.debug("tracker update", data);

      _this.emit("tracker-update", data);
    }; // eslint-disable-next-line @typescript-eslint/no-explicit-any


    _this.onTrackerPeer = trackerPeer => {
      _this.debug("tracker peer", trackerPeer.id, trackerPeer); // eslint-disable-next-line @typescript-eslint/no-unsafe-argument


      if (_this.peers.has(trackerPeer.id)) {
        _this.debug("tracker peer already connected", trackerPeer.id, trackerPeer);

        trackerPeer.destroy();
        return;
      }

      const peer = new media_peer_1.MediaPeer(trackerPeer, _this.settings);
      peer.on("connect", _this.onPeerConnect);
      peer.on("close", _this.onPeerClose);
      peer.on("data-updated", _this.onPeerDataUpdated);
      peer.on("segment-request", _this.onSegmentRequest);
      peer.on("segment-loaded", _this.onSegmentLoaded);
      peer.on("segment-absent", _this.onSegmentAbsent);
      peer.on("segment-error", _this.onSegmentError);
      peer.on("segment-size", _this.onSegmentSize);
      peer.on("segment-start-load", _this.onSegmentStartLoad);
      peer.on("segment-timeout", _this.onSegmentTimeout);
      peer.on("bytes-downloaded", _this.onPieceBytesDownloaded);
      peer.on("bytes-uploaded", _this.onPieceBytesUploaded);

      let peerCandidatesById = _this.peerCandidates.get(peer.id);

      if (!peerCandidatesById) {
        peerCandidatesById = [];

        _this.peerCandidates.set(peer.id, peerCandidatesById);
      }

      peerCandidatesById.push(peer);
    };

    _this.download = segment => {
      if (_this.isDownloading(segment)) {
        return false;
      }

      const candidates = [];

      for (const peer of _this.peers.values()) {
        if (peer.getDownloadingSegmentId() === null && peer.getSegmentsMap().get(segment.id) === media_peer_1.MediaPeerSegmentStatus.Loaded) {
          candidates.push(peer);
        }
      }

      if (candidates.length === 0) {
        return false;
      }

      const peer = candidates[Math.floor(Math.random() * candidates.length)];
      peer.requestSegment(segment.id);

      _this.peerSegmentRequests.set(segment.id, new PeerSegmentRequest(peer.id, segment));

      return true;
    };

    _this.abort = segment => {
      let downloadingSegment;

      const peerSegmentRequest = _this.peerSegmentRequests.get(segment.id);

      if (peerSegmentRequest) {
        const peer = _this.peers.get(peerSegmentRequest.peerId);

        if (peer) {
          downloadingSegment = peer.cancelSegmentRequest();
        }

        _this.peerSegmentRequests.delete(segment.id);
      }

      return downloadingSegment;
    };

    _this.isDownloading = segment => {
      return _this.peerSegmentRequests.has(segment.id);
    };

    _this.getActiveDownloadsCount = () => {
      return _this.peerSegmentRequests.size;
    };

    _this.destroy = function () {
      let swarmChange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      _this.streamSwarmId = null;

      if (_this.trackerClient) {
        _this.trackerClient.stop();

        if (swarmChange) {
          // Don't destroy trackerClient to reuse its WebSocket connection to the tracker server
          _this.trackerClient.removeAllListeners("error");

          _this.trackerClient.removeAllListeners("warning");

          _this.trackerClient.removeAllListeners("update");

          _this.trackerClient.removeAllListeners("peer");
        } else {
          _this.trackerClient.destroy();

          _this.trackerClient = null;
        }
      }

      if (_this.pendingTrackerClient) {
        _this.pendingTrackerClient.isDestroyed = true;
        _this.pendingTrackerClient = null;
      }

      _this.peers.forEach(peer => peer.destroy());

      _this.peers.clear();

      _this.peerSegmentRequests.clear();

      for (const peerCandidateById of _this.peerCandidates.values()) {
        for (const peerCandidate of peerCandidateById) {
          peerCandidate.destroy();
        }
      }

      _this.peerCandidates.clear();
    };

    _this.sendSegmentsMapToAll = segmentsMap => {
      _this.peers.forEach(peer => peer.sendSegmentsMap(segmentsMap));
    };

    _this.sendSegmentsMap = (peerId, segmentsMap) => {
      const peer = _this.peers.get(peerId);

      if (peer) {
        peer.sendSegmentsMap(segmentsMap);
      }
    };

    _this.getOverallSegmentsMap = () => {
      const overallSegmentsMap = new Map();

      for (const peer of _this.peers.values()) {
        for (const [segmentId, segmentStatus] of peer.getSegmentsMap()) {
          if (segmentStatus === media_peer_1.MediaPeerSegmentStatus.Loaded) {
            overallSegmentsMap.set(segmentId, media_peer_1.MediaPeerSegmentStatus.Loaded);
          } else if (!overallSegmentsMap.get(segmentId)) {
            overallSegmentsMap.set(segmentId, media_peer_1.MediaPeerSegmentStatus.LoadingByHttp);
          }
        }
      }

      return overallSegmentsMap;
    };

    _this.onPieceBytesDownloaded = (peer, segmentId, bytes) => {
      const peerSegmentRequest = _this.peerSegmentRequests.get(segmentId);

      if (peerSegmentRequest) {
        _this.emit("bytes-downloaded", peerSegmentRequest.segment, bytes, peer.id);
      }
    };

    _this.onPieceBytesUploaded = async (peer, segmentId, bytes) => {
      if (_this.masterSwarmId === undefined) {
        return;
      }

      const segment = await _this.segmentsStorage.getSegment(segmentId, _this.masterSwarmId);

      if (segment) {
        _this.emit("bytes-uploaded", segment, bytes, peer.id);
      }
    };

    _this.onPeerConnect = peer => {
      const connectedPeer = _this.peers.get(peer.id);

      if (connectedPeer) {
        _this.debug("tracker peer already connected (in peer connect)", peer.id, peer);

        peer.destroy();
        return;
      } // First peer with the ID connected


      _this.peers.set(peer.id, peer); // Destroy all other peer candidates


      const peerCandidatesById = _this.peerCandidates.get(peer.id);

      if (peerCandidatesById) {
        for (const peerCandidate of peerCandidatesById) {
          if (peerCandidate !== peer) {
            peerCandidate.destroy();
          }
        }

        _this.peerCandidates.delete(peer.id);
      }

      _this.emit("peer-connected", {
        id: peer.id,
        remoteAddress: peer.remoteAddress
      });
    };

    _this.onPeerClose = peer => {
      if (_this.peers.get(peer.id) !== peer) {
        // Try to delete the peer candidate
        const peerCandidatesById = _this.peerCandidates.get(peer.id);

        if (!peerCandidatesById) {
          return;
        }

        const index = peerCandidatesById.indexOf(peer);

        if (index !== -1) {
          peerCandidatesById.splice(index, 1);
        }

        if (peerCandidatesById.length === 0) {
          _this.peerCandidates.delete(peer.id);
        }

        return;
      }

      for (const [key, value] of _this.peerSegmentRequests) {
        if (value.peerId === peer.id) {
          _this.peerSegmentRequests.delete(key);
        }
      }

      _this.peers.delete(peer.id);

      _this.emit("peer-data-updated");

      _this.emit("peer-closed", peer.id);
    };

    _this.onPeerDataUpdated = () => {
      _this.emit("peer-data-updated");
    };

    _this.onSegmentRequest = async (peer, segmentId) => {
      if (_this.masterSwarmId === undefined) {
        return;
      }

      const segment = await _this.segmentsStorage.getSegment(segmentId, _this.masterSwarmId);

      if (segment && segment.data) {
        peer.sendSegmentData(segmentId, segment.data);
      } else {
        peer.sendSegmentAbsent(segmentId);
      }
    };

    _this.onSegmentLoaded = async (peer, segmentId, data) => {
      const peerSegmentRequest = _this.peerSegmentRequests.get(segmentId);

      if (!peerSegmentRequest) {
        return;
      }

      const segment = peerSegmentRequest.segment;

      if (_this.settings.segmentValidator) {
        try {
          await _this.settings.segmentValidator(Object.assign(Object.assign({}, segment), {
            data: data
          }), "p2p", peer.id);
        } catch (error) {
          _this.debug("segment validator failed", error);

          _this.peerSegmentRequests.delete(segmentId);

          _this.emit("segment-error", segment, error, peer.id);

          _this.onPeerClose(peer);

          return;
        }
      }

      _this.peerSegmentRequests.delete(segmentId);

      _this.emit("segment-loaded", segment, data, peer.id);
    };

    _this.onSegmentAbsent = (peer, segmentId) => {
      _this.peerSegmentRequests.delete(segmentId);

      _this.emit("peer-data-updated");
    };

    _this.onSegmentError = (peer, segmentId, description) => {
      const peerSegmentRequest = _this.peerSegmentRequests.get(segmentId);

      if (peerSegmentRequest) {
        _this.peerSegmentRequests.delete(segmentId);

        _this.emit("segment-error", peerSegmentRequest.segment, description, peer.id);
      }
    };

    _this.onSegmentSize = (segmentId, size) => {
      const peerSegmentRequest = _this.peerSegmentRequests.get(segmentId);

      if (peerSegmentRequest) {
        _this.emit("segment-size", peerSegmentRequest.segment, size);
      }
    };

    _this.onSegmentStartLoad = (segmentId, size) => {
      const peerSegmentRequest = _this.peerSegmentRequests.get(segmentId);

      if (peerSegmentRequest) {
        _this.emit("segment-start-load", peerSegmentRequest.segment, size);
      }
    };

    _this.onSegmentTimeout = (peer, segmentId) => {
      const peerSegmentRequest = _this.peerSegmentRequests.get(segmentId);

      if (peerSegmentRequest) {
        _this.peerSegmentRequests.delete(segmentId);

        peer.destroy();

        if (_this.peers.delete(peerSegmentRequest.peerId)) {
          _this.emit("peer-data-updated");
        }
      }
    };

    _this.peerId = settings.useP2P ? generatePeerId() : new ArrayBuffer(0);

    if (_this.debug.enabled) {
      _this.debug("peer ID", _this.getPeerId(), new TextDecoder().decode(_this.peerId));
    }

    return _this;
  }

  return _createClass(P2PMediaManager);
}(stringly_typed_event_emitter_1.STEEmitter);

exports.P2PMediaManager = P2PMediaManager;

/***/ }),

/***/ "./node_modules/@peertube/p2p-media-loader-core/dist/segments-memory-storage.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@peertube/p2p-media-loader-core/dist/segments-memory-storage.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2019 Novage LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SegmentsMemoryStorage = void 0;

let SegmentsMemoryStorage = /*#__PURE__*/_createClass(function SegmentsMemoryStorage(settings) {
  _classCallCheck(this, SegmentsMemoryStorage);

  this.settings = settings;
  this.cache = new Map();

  this.storeSegment = async segment => {
    this.cache.set(segment.id, {
      segment,
      lastAccessed: performance.now()
    });
  };

  this.getSegmentsMap = async () => {
    return this.cache;
  };

  this.getSegment = async id => {
    const cacheItem = this.cache.get(id);

    if (cacheItem === undefined) {
      return undefined;
    }

    cacheItem.lastAccessed = performance.now();
    return cacheItem.segment;
  };

  this.hasSegment = async id => {
    return this.cache.has(id);
  };

  this.clean = async (masterSwarmId, lockedSegmentsFilter) => {
    const segmentsToDelete = [];
    const remainingSegments = []; // Delete old segments

    const now = performance.now();

    for (const cachedSegment of this.cache.values()) {
      if (now - cachedSegment.lastAccessed > this.settings.cachedSegmentExpiration) {
        segmentsToDelete.push(cachedSegment.segment.id);
      } else {
        remainingSegments.push(cachedSegment);
      }
    } // Delete segments over cached count


    let countOverhead = remainingSegments.length - this.settings.cachedSegmentsCount;

    if (countOverhead > 0) {
      remainingSegments.sort((a, b) => a.lastAccessed - b.lastAccessed);

      for (const cachedSegment of remainingSegments) {
        if (lockedSegmentsFilter === undefined || !lockedSegmentsFilter(cachedSegment.segment.id)) {
          segmentsToDelete.push(cachedSegment.segment.id);
          countOverhead--;

          if (countOverhead === 0) {
            break;
          }
        }
      }
    }

    segmentsToDelete.forEach(id => this.cache.delete(id));
    return segmentsToDelete.length > 0;
  };

  this.destroy = async () => {
    this.cache.clear();
  };
});

exports.SegmentsMemoryStorage = SegmentsMemoryStorage;

/***/ }),

/***/ "./node_modules/@peertube/p2p-media-loader-core/dist/stringly-typed-event-emitter.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@peertube/p2p-media-loader-core/dist/stringly-typed-event-emitter.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2018 Novage LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.STEEmitter = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */

const events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");

let STEEmitter = /*#__PURE__*/function (_events_1$EventEmitte) {
  _inherits(STEEmitter, _events_1$EventEmitte);

  var _super = _createSuper(STEEmitter);

  function STEEmitter() {
    var _thisSuper, _thisSuper2, _this;

    _classCallCheck(this, STEEmitter);

    _this = _super.apply(this, arguments);

    _this.on = (event, listener) => _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(STEEmitter.prototype)), "on", _thisSuper).call(_thisSuper, event, listener); // eslint-disable-next-line @typescript-eslint/no-unsafe-argument


    _this.emit = function (event) {
      var _get2;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return (_get2 = _get((_thisSuper2 = _assertThisInitialized(_this), _getPrototypeOf(STEEmitter.prototype)), "emit", _thisSuper2)).call.apply(_get2, [_thisSuper2, event].concat(args));
    };

    return _this;
  }

  return _createClass(STEEmitter);
}(events_1.EventEmitter);

exports.STEEmitter = STEEmitter;

/***/ }),

/***/ "./node_modules/@peertube/p2p-media-loader-hlsjs/dist/byte-range.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@peertube/p2p-media-loader-hlsjs/dist/byte-range.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.byteRangeToString = exports.compareByteRanges = exports.getByteRange = void 0;

function getByteRange(context) {
  return context.rangeEnd && context.rangeStart !== undefined ? {
    offset: context.rangeStart,
    length: context.rangeEnd - context.rangeStart
  } : undefined;
}

exports.getByteRange = getByteRange;

function compareByteRanges(b1, b2) {
  return b1 === undefined ? b2 === undefined : b2 !== undefined && b1.length === b2.length && b1.offset === b2.offset;
}

exports.compareByteRanges = compareByteRanges;

function byteRangeToString(byteRange) {
  if (byteRange === undefined) {
    return undefined;
  }

  const end = byteRange.offset + byteRange.length - 1;
  return "bytes=".concat(byteRange.offset, "-").concat(end);
}

exports.byteRangeToString = byteRangeToString;

/***/ }),

/***/ "./node_modules/@peertube/p2p-media-loader-hlsjs/dist/engine.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@peertube/p2p-media-loader-hlsjs/dist/engine.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2018 Novage LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Engine = void 0;

const events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");

const p2p_media_loader_core_1 = __webpack_require__(/*! @peertube/p2p-media-loader-core */ "./node_modules/@peertube/p2p-media-loader-core/dist/index.js");

const segment_manager_1 = __webpack_require__(/*! ./segment-manager */ "./node_modules/@peertube/p2p-media-loader-hlsjs/dist/segment-manager.js");

const hlsjs_loader_1 = __webpack_require__(/*! ./hlsjs-loader */ "./node_modules/@peertube/p2p-media-loader-hlsjs/dist/hlsjs-loader.js");

let Engine = /*#__PURE__*/function (_events_1$EventEmitte) {
  _inherits(Engine, _events_1$EventEmitte);

  var _super = _createSuper(Engine);

  function Engine() {
    var _this;

    let settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Engine);

    _this = _super.call(this);
    _this.loader = new p2p_media_loader_core_1.HybridLoader(settings.loader);
    _this.segmentManager = new segment_manager_1.SegmentManager(_this.loader, settings.segments);
    Object.keys(p2p_media_loader_core_1.Events).map(eventKey => p2p_media_loader_core_1.Events[eventKey]).forEach(event => _this.loader.on(event, function () {
      var _this2;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return (_this2 = _this).emit.apply(_this2, [event].concat(args));
    }));
    return _this;
  }

  _createClass(Engine, [{
    key: "createLoaderClass",
    value: function createLoaderClass() {
      var _a;

      const engine = this; // eslint-disable-line @typescript-eslint/no-this-alias

      const loader = (_a = /*#__PURE__*/_createClass(function _a() {
        _classCallCheck(this, _a);

        this.load = async (context, config, callbacks) => {
          this.context = context;
          this.callbacks = callbacks;
          await this.impl.load(context, config, callbacks);
        };

        this.abort = () => {
          if (this.context) {
            this.impl.abort(this.context, this.callbacks);
          }
        };

        this.destroy = () => {
          if (this.context) {
            this.impl.abort(this.context);
          }
        };

        this.getResponseHeader = () => undefined;

        this.impl = new hlsjs_loader_1.HlsJsLoader(engine.segmentManager);
        engine.setLatestLoaderImpl(this);
        this.stats = this.impl.stats;
      }), _a.getEngine = () => {
        return engine;
      }, _a);
      return loader;
    }
  }, {
    key: "destroy",
    value: async function destroy() {
      await this.segmentManager.destroy();
    }
  }, {
    key: "abortCurrentRequest",
    value: function abortCurrentRequest() {
      if (this.latestLoaderImpl) {
        this.latestLoaderImpl.abort();
        this.latestLoaderImpl = undefined;
      }
    }
  }, {
    key: "getSettings",
    value: function getSettings() {
      return {
        segments: this.segmentManager.getSettings(),
        loader: this.loader.getSettings()
      };
    }
  }, {
    key: "getDetails",
    value: function getDetails() {
      return {
        loader: this.loader.getDetails()
      };
    }
  }, {
    key: "setPlayingSegment",
    value: function setPlayingSegment(url, byteRange, start, duration) {
      this.segmentManager.setPlayingSegment(url, byteRange, start, duration);
    }
  }, {
    key: "setPlayingSegmentByCurrentTime",
    value: function setPlayingSegmentByCurrentTime(playheadPosition) {
      this.segmentManager.setPlayingSegmentByCurrentTime(playheadPosition);
    }
  }, {
    key: "setLatestLoaderImpl",
    value: function setLatestLoaderImpl(loader) {
      this.latestLoaderImpl = loader;
    }
  }], [{
    key: "isSupported",
    value: function isSupported() {
      return p2p_media_loader_core_1.HybridLoader.isSupported();
    }
  }]);

  return Engine;
}(events_1.EventEmitter);

exports.Engine = Engine;

/***/ }),

/***/ "./node_modules/@peertube/p2p-media-loader-hlsjs/dist/hlsjs-loader.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@peertube/p2p-media-loader-hlsjs/dist/hlsjs-loader.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2018 Novage LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.HlsJsLoader = void 0;

const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));

const p2p_media_loader_core_1 = __webpack_require__(/*! @peertube/p2p-media-loader-core */ "./node_modules/@peertube/p2p-media-loader-core/dist/index.js");

const byte_range_1 = __webpack_require__(/*! ./byte-range */ "./node_modules/@peertube/p2p-media-loader-hlsjs/dist/byte-range.js");

let HlsJsLoader = /*#__PURE__*/function () {
  function HlsJsLoader(segmentManager) {
    _classCallCheck(this, HlsJsLoader);

    this.segmentManager = segmentManager;
    this.debug = (0, debug_1.default)("p2pml:hlsjs-loader");
    this.stats = {
      loaded: 0,
      total: 0,
      aborted: false,
      retry: 0,
      chunkCount: 0,
      bwEstimate: 0,
      loading: {
        start: 0,
        end: 0,
        first: 0
      },
      parsing: {
        start: 0,
        end: 0
      },
      buffering: {
        start: 0,
        end: 0,
        first: 0
      }
    };
    this.boundOnSegmentAbort = this.onSegmentAbort.bind(this);
    this.boundOnUpdateSegmentSize = this.onUpdateSegmentSize.bind(this);
    this.boundOnUpdateLoaded = this.onUpdateLoaded.bind(this);
    this.boundOnSegmentStartLoad = this.onSegmentStartLoad.bind(this);
    this.debugId = "";
  }

  _createClass(HlsJsLoader, [{
    key: "load",
    value: async function load(context, _config, callbacks) {
      this.context = context;
      this.callbacks = callbacks;
      HlsJsLoader.updateStatsToStartLoading(this.stats);

      if (this.context.type) {
        this.debug("Loading playlist ".concat(this.context.url, "."));

        try {
          const result = await this.segmentManager.loadPlaylist(this.context.url);
          this.debug("Playlist ".concat(this.context.url, " loaded."));
          this.successPlaylist(result, this.context, this.callbacks);
        } catch (e) {
          this.error(e, this.context, this.callbacks);
        }
      } else if (this.context.frag) {
        this.loader = this.segmentManager.loader;
        this.byteRange = (0, byte_range_1.getByteRange)(this.context);
        this.debugId = this.byteRange ? "".concat(this.context.url, " / ").concat(this.byteRange.offset) : this.context.url;
        this.debug("Loading fragment ".concat(this.debugId, ".")); // We may be downloading the segment by P2P, so we don"t care about the stats sent to HLS ABR

        this.interval = setInterval(() => HlsJsLoader.updateStatsToStartLoading(this.stats), 200);
        this.loader.on(p2p_media_loader_core_1.Events.SegmentAbort, this.boundOnSegmentAbort);
        this.loader.on(p2p_media_loader_core_1.Events.SegmentSize, this.boundOnUpdateSegmentSize);
        this.loader.on(p2p_media_loader_core_1.Events.SegmentStartLoad, this.boundOnSegmentStartLoad);

        try {
          const result = await this.segmentManager.loadSegment(this.context.url, this.byteRange);
          const {
            content
          } = result;

          if (content) {
            this.successSegment(content, this.context, this.callbacks);
            this.debug("Loaded fragment ".concat(this.debugId, "."));
          } else {
            this.cleanup();
            this.debug("Loaded empty fragment ".concat(this.debugId, " (aborted?)."));
          }
        } catch (e) {
          setTimeout(() => this.error(e, this.context, this.callbacks), 0);
          this.debug("Error in fragment ".concat(this.debugId, " loading."), e);
        }
      } else {
        console.warn("Unknown load request", this.context);
      }
    }
  }, {
    key: "abort",
    value: function abort(context, callbacks) {
      if (this.stats.loaded || this.stats.aborted) return;
      this.debug("Aborting by hls.js fragment ".concat(this.debugId, " loading."));
      this.cleanup();
      this.segmentManager.abortSegment(context.url, (0, byte_range_1.getByteRange)(context));
      this.stats.aborted = true;
      const onAbort = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onAbort;

      if (onAbort) {
        onAbort(this.stats, context, undefined);
      }
    }
  }, {
    key: "successPlaylist",
    value: function successPlaylist(xhr, context, callbacks) {
      this.cleanup();
      const now = performance.now();
      this.stats.loading.end = now;
      this.stats.loaded = xhr.response.length;
      this.stats.total = xhr.response.length;
      callbacks.onSuccess({
        url: xhr.responseURL,
        data: xhr.response
      }, this.stats, context, undefined);
    }
  }, {
    key: "successSegment",
    value: function successSegment(content, context, callbacks) {
      this.cleanup();
      const now = performance.now();
      this.stats.loading.end = now;
      this.stats.loaded = content.byteLength;
      this.stats.total = content.byteLength;

      if (callbacks.onProgress) {
        callbacks.onProgress(this.stats, context, content, undefined);
      }

      callbacks.onSuccess({
        url: context.url,
        data: content
      }, this.stats, context, undefined);
    }
  }, {
    key: "error",
    value: function error(_error, context, callbacks) {
      this.cleanup();
      callbacks.onError(_error, context, undefined);
    }
  }, {
    key: "cleanup",
    value: function cleanup() {
      if (this.interval) {
        clearInterval(this.interval);
        this.interval = undefined;
      }

      if (this.loader) {
        this.loader.off(p2p_media_loader_core_1.Events.SegmentStartLoad, this.boundOnSegmentStartLoad);
        this.loader.off(p2p_media_loader_core_1.Events.SegmentSize, this.boundOnUpdateSegmentSize);
        this.loader.off(p2p_media_loader_core_1.Events.PieceBytesDownloaded, this.boundOnUpdateLoaded);
        this.loader.off(p2p_media_loader_core_1.Events.SegmentAbort, this.boundOnSegmentAbort);
      }
    }
  }, {
    key: "onSegmentAbort",
    value: function onSegmentAbort(segment) {
      var _a;

      if (!this.isSegment(segment)) return;
      this.debug("Aborting by p2p-media-loader fragment ".concat(this.debugId || "", "."));
      this.stats.aborted = true;
      const onAbort = (_a = this.callbacks) === null || _a === void 0 ? void 0 : _a.onAbort;

      if (onAbort) {
        onAbort(this.stats, this.context, undefined);
      }

      this.cleanup();
    }
  }, {
    key: "onUpdateSegmentSize",
    value: function onUpdateSegmentSize(segment, size) {
      if (!this.isSegment(segment)) return;
      this.stats.total = size;
    }
  }, {
    key: "onUpdateLoaded",
    value: function onUpdateLoaded(_type, segment, bytes) {
      if (!this.isSegment(segment)) return;
      this.stats.loaded += bytes;
    }
  }, {
    key: "onSegmentStartLoad",
    value: function onSegmentStartLoad(method, segment) {
      if (!this.interval || method !== "http" || !this.isSegment(segment)) return;
      clearInterval(this.interval);
      this.interval = undefined;
      HlsJsLoader.updateStatsToStartLoading(this.stats);
      this.loader.on(p2p_media_loader_core_1.Events.PieceBytesDownloaded, this.boundOnUpdateLoaded);
    }
  }, {
    key: "isSegment",
    value: function isSegment(segment) {
      return segment.url === this.context.url && segment.range === (0, byte_range_1.byteRangeToString)(this.byteRange);
    }
  }], [{
    key: "updateStatsToStartLoading",
    value: function updateStatsToStartLoading(stats) {
      if (stats.aborted) return;
      const start = performance.now();
      stats.loading.start = start;
      stats.loading.first = start;
    }
  }]);

  return HlsJsLoader;
}();

exports.HlsJsLoader = HlsJsLoader;

/***/ }),

/***/ "./node_modules/@peertube/p2p-media-loader-hlsjs/dist/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@peertube/p2p-media-loader-hlsjs/dist/index.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * @license Apache-2.0
 * Copyright 2018 Novage LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function () {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.initJwPlayer = exports.initMediaElementJsPlayer = exports.initVideoJsHlsJsPlugin = exports.initVideoJsContribHlsJsPlayer = exports.initFlowplayerHlsJsPlayer = exports.initClapprPlayer = exports.initHlsJsPlayer = exports.version = void 0;
/* eslint-disable */

exports.version = "0.6.2";

__exportStar(__webpack_require__(/*! ./engine */ "./node_modules/@peertube/p2p-media-loader-hlsjs/dist/engine.js"), exports);

__exportStar(__webpack_require__(/*! ./segment-manager */ "./node_modules/@peertube/p2p-media-loader-hlsjs/dist/segment-manager.js"), exports);

const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));

const debug = (0, debug_1.default)("p2pml:hlsjs-init");

function initHlsJsPlayer(player) {
  if (player && player.config && player.config.loader && typeof player.config.loader.getEngine === "function") {
    initHlsJsEvents(player, player.config.loader.getEngine());
  }
}

exports.initHlsJsPlayer = initHlsJsPlayer;

function initClapprPlayer(player) {
  player.on("play", () => {
    const playback = player.core.getCurrentPlayback();

    if (playback._hls && !playback._hls._p2pm_linitialized) {
      playback._hls._p2pm_linitialized = true;
      initHlsJsPlayer(player.core.getCurrentPlayback()._hls);
    }
  });
}

exports.initClapprPlayer = initClapprPlayer;

function initFlowplayerHlsJsPlayer(player) {
  player.on("ready", () => {
    var _a;

    return initHlsJsPlayer((_a = player.engine.hlsjs) !== null && _a !== void 0 ? _a : player.engine.hls);
  });
}

exports.initFlowplayerHlsJsPlayer = initFlowplayerHlsJsPlayer;

function initVideoJsContribHlsJsPlayer(player) {
  player.ready(() => {
    const options = player.tech_.options_;

    if (options && options.hlsjsConfig && options.hlsjsConfig.loader && typeof options.hlsjsConfig.loader.getEngine === "function") {
      initHlsJsEvents(player.tech_, options.hlsjsConfig.loader.getEngine());
    }
  });
}

exports.initVideoJsContribHlsJsPlayer = initVideoJsContribHlsJsPlayer;

function initVideoJsHlsJsPlugin() {
  if (videojs == undefined || videojs.Html5Hlsjs == undefined) {
    return;
  }

  videojs.Html5Hlsjs.addHook("beforeinitialize", (videojsPlayer, hlsjs) => {
    if (hlsjs.config && hlsjs.config.loader && typeof hlsjs.config.loader.getEngine === "function") {
      initHlsJsEvents(hlsjs, hlsjs.config.loader.getEngine());
    }
  });
}

exports.initVideoJsHlsJsPlugin = initVideoJsHlsJsPlugin;

function initMediaElementJsPlayer(mediaElement) {
  mediaElement.addEventListener("hlsFragChanged", event => {
    const hls = mediaElement.hlsPlayer;

    if (hls && hls.config && hls.config.loader && typeof hls.config.loader.getEngine === "function") {
      const engine = hls.config.loader.getEngine();

      if (event.data && event.data.length > 1) {
        const frag = event.data[1].frag;
        const byteRange = frag.byteRange.length !== 2 ? undefined : {
          offset: frag.byteRange[0],
          length: frag.byteRange[1] - frag.byteRange[0]
        };
        engine.setPlayingSegment(frag.url, byteRange, frag.start, frag.duration);
      }
    }
  });
  mediaElement.addEventListener("hlsDestroying", async () => {
    const hls = mediaElement.hlsPlayer;

    if (hls && hls.config && hls.config.loader && typeof hls.config.loader.getEngine === "function") {
      const engine = hls.config.loader.getEngine();
      await engine.destroy();
    }
  });
  mediaElement.addEventListener("hlsError", event => {
    const hls = mediaElement.hlsPlayer;

    if (hls && hls.config && hls.config.loader && typeof hls.config.loader.getEngine === "function") {
      if (event.data !== undefined && event.data.details === "bufferStalledError") {
        const engine = hls.config.loader.getEngine();
        engine.setPlayingSegmentByCurrentTime(hls.media.currentTime);
      }
    }
  });
}

exports.initMediaElementJsPlayer = initMediaElementJsPlayer;

function initJwPlayer(player, hlsjsConfig) {
  const iid = setInterval(() => {
    if (player.hls && player.hls.config) {
      clearInterval(iid);
      Object.assign(player.hls.config, hlsjsConfig);
      initHlsJsPlayer(player.hls);
    }
  }, 200);
}

exports.initJwPlayer = initJwPlayer;

function initHlsJsEvents(player, engine) {
  player.on("hlsFragChanged", (_event, data) => {
    debug("HLS Frag changed.", data);
    const frag = data.frag;
    const byteRange = frag.byteRange.length !== 2 ? undefined : {
      offset: frag.byteRange[0],
      length: frag.byteRange[1] - frag.byteRange[0]
    };
    engine.setPlayingSegment(frag.url, byteRange, frag.start, frag.duration);
  });
  player.on("hlsDestroying", async () => {
    await engine.destroy();
  });
  player.on("hlsError", (_event, errorData) => {
    if (errorData.details === "bufferStalledError") {
      const htmlMediaElement = player.media === undefined ? player.el_ // videojs-contrib-hlsjs
      : player.media; // all others

      if (htmlMediaElement) {
        engine.setPlayingSegmentByCurrentTime(htmlMediaElement.currentTime);
      }
    }
  });
  player.on('seeking', () => {
    debug("Player seeking."); // Abort current HTTP/P2P request so HLS is not stuck with a P2P request when moving current video player time
    // to a previously loaded fragment

    engine.abortCurrentRequest();
  });
}

/***/ }),

/***/ "./node_modules/@peertube/p2p-media-loader-hlsjs/dist/segment-manager.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@peertube/p2p-media-loader-hlsjs/dist/segment-manager.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2018 Novage LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SegmentManager = void 0;

const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));

const p2p_media_loader_core_1 = __webpack_require__(/*! @peertube/p2p-media-loader-core */ "./node_modules/@peertube/p2p-media-loader-core/dist/index.js");

const m3u8_parser_1 = __webpack_require__(/*! m3u8-parser */ "./node_modules/m3u8-parser/dist/m3u8-parser.es.js");

const byte_range_1 = __webpack_require__(/*! ./byte-range */ "./node_modules/@peertube/p2p-media-loader-hlsjs/dist/byte-range.js");

const defaultSettings = {
  forwardSegmentCount: 20,
  swarmId: undefined,
  assetsStorage: undefined
};

let SegmentManager = /*#__PURE__*/function () {
  function SegmentManager(loader) {
    let settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, SegmentManager);

    this.debug = (0, debug_1.default)("p2pml:segment-manager");
    this.masterPlaylist = null;
    this.variantPlaylists = new Map();
    this.segmentRequest = null;
    this.playQueue = [];

    this.onSegmentLoaded = segment => {
      if (this.segmentRequest && this.segmentRequest.segmentUrl === segment.url && (0, byte_range_1.byteRangeToString)(this.segmentRequest.segmentByteRange) === segment.range) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.segmentRequest.onSuccess(segment.data.slice(0), segment.downloadBandwidth);
        this.segmentRequest = null;
      }
    };

    this.onSegmentError = (segment, error) => {
      if (this.segmentRequest && this.segmentRequest.segmentUrl === segment.url && (0, byte_range_1.byteRangeToString)(this.segmentRequest.segmentByteRange) === segment.range) {
        this.segmentRequest.onError(error);
        this.segmentRequest = null;
      }
    };

    this.onSegmentAbort = segment => {
      if (this.segmentRequest && this.segmentRequest.segmentUrl === segment.url && (0, byte_range_1.byteRangeToString)(this.segmentRequest.segmentByteRange) === segment.range) {
        this.segmentRequest.onError("Loading aborted: internal abort");
        this.segmentRequest = null;
      }
    };

    this.settings = Object.assign(Object.assign({}, defaultSettings), settings);
    this.loader = loader;
    this.loader.on(p2p_media_loader_core_1.Events.SegmentLoaded, this.onSegmentLoaded);
    this.loader.on(p2p_media_loader_core_1.Events.SegmentError, this.onSegmentError);
    this.loader.on(p2p_media_loader_core_1.Events.SegmentAbort, this.onSegmentAbort);
  }

  _createClass(SegmentManager, [{
    key: "getSettings",
    value: function getSettings() {
      return this.settings;
    }
  }, {
    key: "processPlaylist",
    value: function processPlaylist(requestUrl, content, responseUrl) {
      const parser = new m3u8_parser_1.Parser();
      parser.push(content);
      parser.end();
      const playlist = new Playlist(requestUrl, responseUrl, parser.manifest);

      if (playlist.manifest.playlists) {
        this.masterPlaylist = playlist;

        for (const [key, variantPlaylist] of this.variantPlaylists) {
          const {
            streamSwarmId,
            found,
            index
          } = this.getStreamSwarmId(variantPlaylist.requestUrl);

          if (!found) {
            this.variantPlaylists.delete(key);
          } else {
            variantPlaylist.streamSwarmId = streamSwarmId;
            variantPlaylist.streamId = "V" + index.toString();
          }
        }
      } else {
        const {
          streamSwarmId,
          found,
          index
        } = this.getStreamSwarmId(requestUrl);

        if (found || this.masterPlaylist === null) {
          // do not add audio and subtitles to variants
          playlist.streamSwarmId = streamSwarmId;
          playlist.streamId = this.masterPlaylist === null ? undefined : "V" + index.toString();
          this.variantPlaylists.set(requestUrl, playlist);
          this.updateSegments();
        }
      }
    }
  }, {
    key: "loadPlaylist",
    value: async function loadPlaylist(url) {
      const assetsStorage = this.settings.assetsStorage;
      let xhr;

      if (assetsStorage !== undefined) {
        let masterSwarmId;
        masterSwarmId = this.getMasterSwarmId();

        if (masterSwarmId === undefined) {
          masterSwarmId = url.split("?")[0];
        }

        const asset = await assetsStorage.getAsset(url, undefined, masterSwarmId);

        if (asset !== undefined) {
          xhr = {
            responseURL: asset.responseUri,
            response: asset.data
          };
        } else {
          xhr = await this.loadContent(url, "text");
          void assetsStorage.storeAsset({
            masterManifestUri: this.masterPlaylist !== null ? this.masterPlaylist.requestUrl : url,
            masterSwarmId: masterSwarmId,
            requestUri: url,
            responseUri: xhr.responseURL,
            data: xhr.response
          });
        }
      } else {
        xhr = await this.loadContent(url, "text");
      }

      this.processPlaylist(url, xhr.response, xhr.responseURL);
      return xhr;
    }
  }, {
    key: "loadSegment",
    value: async function loadSegment(url, byteRange) {
      var _a;

      const segmentLocation = this.getSegmentLocation(url, byteRange);
      const byteRangeString = (0, byte_range_1.byteRangeToString)(byteRange);

      if (!segmentLocation) {
        let content; // Not a segment from variants; usually can be: init, audio or subtitles segment, encryption key etc.

        const assetsStorage = this.settings.assetsStorage;

        if (assetsStorage !== undefined) {
          let masterManifestUri = (_a = this.masterPlaylist) === null || _a === void 0 ? void 0 : _a.requestUrl;
          let masterSwarmId;
          masterSwarmId = this.getMasterSwarmId();

          if (masterSwarmId === undefined && this.variantPlaylists.size === 1) {
            const result = this.variantPlaylists.values().next();

            if (!result.done) {
              // always true
              masterSwarmId = result.value.requestUrl.split("?")[0];
            }
          }

          if (masterManifestUri === undefined && this.variantPlaylists.size === 1) {
            const result = this.variantPlaylists.values().next();

            if (!result.done) {
              // always true
              masterManifestUri = result.value.requestUrl;
            }
          }

          if (masterSwarmId !== undefined && masterManifestUri !== undefined) {
            const asset = await assetsStorage.getAsset(url, byteRangeString, masterSwarmId);

            if (asset !== undefined) {
              content = asset.data;
            } else {
              const xhr = await this.loadContent(url, "arraybuffer", byteRangeString);
              content = xhr.response;
              void assetsStorage.storeAsset({
                masterManifestUri: masterManifestUri,
                masterSwarmId: masterSwarmId,
                requestUri: url,
                requestRange: byteRangeString,
                responseUri: xhr.responseURL,
                data: content
              });
            }
          }
        }

        if (content === undefined) {
          const xhr = await this.loadContent(url, "arraybuffer", byteRangeString);
          content = xhr.response;
        }

        return {
          content,
          downloadBandwidth: 0
        };
      }

      const segmentSequence = (segmentLocation.playlist.manifest.mediaSequence ? segmentLocation.playlist.manifest.mediaSequence : 0) + segmentLocation.segmentIndex;

      if (this.playQueue.length > 0) {
        const previousSegment = this.playQueue[this.playQueue.length - 1];

        if (previousSegment.segmentSequence !== segmentSequence - 1) {
          // Reset play queue in case of segment loading out of sequence
          this.playQueue = [];
        }
      }

      if (this.segmentRequest) {
        this.segmentRequest.onError("Cancel segment request: simultaneous segment requests are not supported");
      }

      const promise = new Promise((resolve, reject) => {
        this.segmentRequest = new SegmentRequest(url, byteRange, segmentSequence, segmentLocation.playlist.requestUrl, (content, downloadBandwidth) => resolve({
          content,
          downloadBandwidth
        }), error => reject(error));
      });
      this.playQueue.push({
        segmentUrl: url,
        segmentByteRange: byteRange,
        segmentSequence: segmentSequence
      });
      void this.loadSegments(segmentLocation.playlist, segmentLocation.segmentIndex, true);
      return promise;
    }
  }, {
    key: "setPlayingSegment",
    value: function setPlayingSegment(url, byteRange, start, duration) {
      const urlIndex = this.playQueue.findIndex(segment => segment.segmentUrl === url && (0, byte_range_1.compareByteRanges)(segment.segmentByteRange, byteRange));
      this.debug("Set playing segment to index %d", urlIndex, this.playQueue);

      if (urlIndex >= 0) {
        this.playQueue = this.playQueue.slice(urlIndex);
        this.playQueue[0].playPosition = {
          start,
          duration
        };
        this.updateSegments();
      }
    }
  }, {
    key: "setPlayingSegmentByCurrentTime",
    value: function setPlayingSegmentByCurrentTime(playheadPosition) {
      if (this.playQueue.length === 0 || !this.playQueue[0].playPosition) {
        return;
      }

      const currentSegmentPosition = this.playQueue[0].playPosition;
      const segmentEndTime = currentSegmentPosition.start + currentSegmentPosition.duration;

      if (segmentEndTime - playheadPosition < 0.2) {
        // means that current segment is (almost) finished playing
        // remove it from queue
        this.playQueue = this.playQueue.slice(1);
        this.updateSegments();
      }
    }
  }, {
    key: "abortSegment",
    value: function abortSegment(url, byteRange) {
      if (this.segmentRequest && this.segmentRequest.segmentUrl === url && (0, byte_range_1.compareByteRanges)(this.segmentRequest.segmentByteRange, byteRange)) {
        this.segmentRequest.onSuccess(undefined, 0);
        this.segmentRequest = null;
      }
    }
  }, {
    key: "abortCurrentSegment",
    value: function abortCurrentSegment() {
      if (!this.segmentRequest) return;
      this.segmentRequest.onSuccess(undefined, 0);
      this.segmentRequest = null;
    }
  }, {
    key: "destroy",
    value: async function destroy() {
      if (this.segmentRequest) {
        this.segmentRequest.onError("Loading aborted: object destroyed");
        this.segmentRequest = null;
      }

      this.masterPlaylist = null;
      this.variantPlaylists.clear();
      this.playQueue = [];

      if (this.settings.assetsStorage !== undefined) {
        await this.settings.assetsStorage.destroy();
      }

      await this.loader.destroy();
    }
  }, {
    key: "updateSegments",
    value: function updateSegments() {
      if (!this.segmentRequest) {
        return;
      }

      const segmentLocation = this.getSegmentLocation(this.segmentRequest.segmentUrl, this.segmentRequest.segmentByteRange);
      this.debug("update segments", segmentLocation);

      if (segmentLocation) {
        void this.loadSegments(segmentLocation.playlist, segmentLocation.segmentIndex, false);
      }
    }
  }, {
    key: "getSegmentLocation",
    value: function getSegmentLocation(url, byteRange) {
      for (const playlist of this.variantPlaylists.values()) {
        const segmentIndex = playlist.getSegmentIndex(url, byteRange);

        if (segmentIndex >= 0) {
          return {
            playlist: playlist,
            segmentIndex: segmentIndex
          };
        }
      }

      return undefined;
    }
  }, {
    key: "loadSegments",
    value: async function loadSegments(playlist, segmentIndex, requestFirstSegment) {
      var _a;

      const segments = [];
      const playlistSegments = playlist.manifest.segments;
      const initialSequence = (_a = playlist.manifest.mediaSequence) !== null && _a !== void 0 ? _a : 0;
      let loadSegmentId = null;
      let priority = Math.max(0, this.playQueue.length - 1);
      const masterSwarmId = this.getMasterSwarmId();
      this.debug("load segments", priority, segmentIndex);

      for (let i = segmentIndex; i < playlistSegments.length && segments.length < this.settings.forwardSegmentCount; ++i) {
        const segment = playlist.manifest.segments[i];
        const url = playlist.getSegmentAbsoluteUrl(segment.uri);
        const byteRange = segment.byterange;
        const id = this.getSegmentId(playlist, initialSequence + i);
        segments.push({
          id: id,
          url: url,
          masterSwarmId: masterSwarmId !== undefined ? masterSwarmId : playlist.streamSwarmId,
          masterManifestUri: this.masterPlaylist !== null ? this.masterPlaylist.requestUrl : playlist.requestUrl,
          streamId: playlist.streamId,
          sequence: (initialSequence + i).toString(),
          range: (0, byte_range_1.byteRangeToString)(byteRange),
          priority: priority++
        });

        if (requestFirstSegment && !loadSegmentId) {
          loadSegmentId = id;
        }
      }

      this.loader.load(segments, playlist.streamSwarmId);

      if (loadSegmentId) {
        const segment = await this.loader.getSegment(loadSegmentId);

        if (segment) {
          // Segment already loaded by loader
          this.onSegmentLoaded(segment);
        }
      }
    }
  }, {
    key: "getSegmentId",
    value: function getSegmentId(playlist, segmentSequence) {
      return "".concat(playlist.streamSwarmId, "+").concat(segmentSequence);
    }
  }, {
    key: "getMasterSwarmId",
    value: function getMasterSwarmId() {
      const settingsSwarmId = this.settings.swarmId && this.settings.swarmId.length !== 0 ? this.settings.swarmId : undefined;

      if (settingsSwarmId !== undefined) {
        return settingsSwarmId;
      }

      return this.masterPlaylist !== null ? this.masterPlaylist.requestUrl.split("?")[0] : undefined;
    }
  }, {
    key: "getStreamSwarmId",
    value: function getStreamSwarmId(playlistUrl) {
      const masterSwarmId = this.getMasterSwarmId();

      if (this.masterPlaylist && this.masterPlaylist.manifest.playlists && masterSwarmId) {
        for (let i = 0; i < this.masterPlaylist.manifest.playlists.length; ++i) {
          const url = new URL(this.masterPlaylist.manifest.playlists[i].uri, this.masterPlaylist.responseUrl).toString();

          if (url === playlistUrl) {
            return {
              streamSwarmId: "".concat(masterSwarmId, "+V").concat(i),
              found: true,
              index: i
            };
          }
        }
      }

      return {
        streamSwarmId: masterSwarmId !== null && masterSwarmId !== void 0 ? masterSwarmId : playlistUrl.split("?")[0],
        found: false,
        index: -1
      };
    }
  }, {
    key: "loadContent",
    value: async function loadContent(url, responseType, range) {
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.responseType = responseType;

        if (range) {
          xhr.setRequestHeader("Range", range);
        }

        xhr.addEventListener("readystatechange", () => {
          if (xhr.readyState !== 4) return;

          if (xhr.status >= 200 && xhr.status < 300) {
            resolve(xhr);
          } else {
            reject(xhr.statusText);
          }
        });
        const xhrSetup = this.loader.getSettings().xhrSetup;

        if (xhrSetup) {
          xhrSetup(xhr, url);
        }

        xhr.send();
      });
    }
  }]);

  return SegmentManager;
}();

exports.SegmentManager = SegmentManager;

let Playlist = /*#__PURE__*/function () {
  function Playlist(requestUrl, responseUrl, manifest) {
    _classCallCheck(this, Playlist);

    this.requestUrl = requestUrl;
    this.responseUrl = responseUrl;
    this.manifest = manifest;
    this.streamSwarmId = "";
  }

  _createClass(Playlist, [{
    key: "getSegmentIndex",
    value: function getSegmentIndex(url, byteRange) {
      for (let i = 0; i < this.manifest.segments.length; ++i) {
        const segment = this.manifest.segments[i];
        const segmentUrl = this.getSegmentAbsoluteUrl(segment.uri);

        if (url === segmentUrl && (0, byte_range_1.compareByteRanges)(segment.byterange, byteRange)) {
          return i;
        }
      }

      return -1;
    }
  }, {
    key: "getSegmentAbsoluteUrl",
    value: function getSegmentAbsoluteUrl(segmentUrl) {
      return new URL(segmentUrl, this.responseUrl).toString();
    }
  }]);

  return Playlist;
}();

let SegmentRequest = /*#__PURE__*/_createClass(function SegmentRequest(segmentUrl, segmentByteRange, segmentSequence, playlistRequestUrl, onSuccess, onError) {
  _classCallCheck(this, SegmentRequest);

  this.segmentUrl = segmentUrl;
  this.segmentByteRange = segmentByteRange;
  this.segmentSequence = segmentSequence;
  this.playlistRequestUrl = playlistRequestUrl;
  this.onSuccess = onSuccess;
  this.onError = onError;
});

/***/ }),

/***/ "./node_modules/@videojs/vhs-utils/es/decode-b64-to-uint8-array.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/es/decode-b64-to-uint8-array.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ decodeB64ToUint8Array)
/* harmony export */ });
/* harmony import */ var global_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! global/window */ "./node_modules/global/window.js");
/* harmony import */ var global_window__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(global_window__WEBPACK_IMPORTED_MODULE_0__);
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];


var atob = function atob(s) {
  return (global_window__WEBPACK_IMPORTED_MODULE_0___default().atob) ? global_window__WEBPACK_IMPORTED_MODULE_0___default().atob(s) : Buffer.from(s, 'base64').toString('binary');
};

function decodeB64ToUint8Array(b64Text) {
  var decodedString = atob(b64Text);
  var array = new Uint8Array(decodedString.length);

  for (var i = 0; i < decodedString.length; i++) {
    array[i] = decodedString.charCodeAt(i);
  }

  return array;
}

/***/ }),

/***/ "./node_modules/@videojs/vhs-utils/es/stream.js":
/*!******************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/es/stream.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Stream)
/* harmony export */ });
/**
 * @file stream.js
 */

/**
 * A lightweight readable stream implemention that handles event dispatching.
 *
 * @class Stream
 */
var Stream = /*#__PURE__*/function () {
  function Stream() {
    this.listeners = {};
  }
  /**
   * Add a listener for a specified event type.
   *
   * @param {string} type the event name
   * @param {Function} listener the callback to be invoked when an event of
   * the specified type occurs
   */


  var _proto = Stream.prototype;

  _proto.on = function on(type, listener) {
    if (!this.listeners[type]) {
      this.listeners[type] = [];
    }

    this.listeners[type].push(listener);
  }
  /**
   * Remove a listener for a specified event type.
   *
   * @param {string} type the event name
   * @param {Function} listener  a function previously registered for this
   * type of event through `on`
   * @return {boolean} if we could turn it off or not
   */
  ;

  _proto.off = function off(type, listener) {
    if (!this.listeners[type]) {
      return false;
    }

    var index = this.listeners[type].indexOf(listener); // TODO: which is better?
    // In Video.js we slice listener functions
    // on trigger so that it does not mess up the order
    // while we loop through.
    //
    // Here we slice on off so that the loop in trigger
    // can continue using it's old reference to loop without
    // messing up the order.

    this.listeners[type] = this.listeners[type].slice(0);
    this.listeners[type].splice(index, 1);
    return index > -1;
  }
  /**
   * Trigger an event of the specified type on this stream. Any additional
   * arguments to this function are passed as parameters to event listeners.
   *
   * @param {string} type the event name
   */
  ;

  _proto.trigger = function trigger(type) {
    var callbacks = this.listeners[type];

    if (!callbacks) {
      return;
    } // Slicing the arguments on every invocation of this method
    // can add a significant amount of overhead. Avoid the
    // intermediate object creation for the common case of a
    // single callback argument


    if (arguments.length === 2) {
      var length = callbacks.length;

      for (var i = 0; i < length; ++i) {
        callbacks[i].call(this, arguments[1]);
      }
    } else {
      var args = Array.prototype.slice.call(arguments, 1);
      var _length = callbacks.length;

      for (var _i = 0; _i < _length; ++_i) {
        callbacks[_i].apply(this, args);
      }
    }
  }
  /**
   * Destroys the stream and cleans up.
   */
  ;

  _proto.dispose = function dispose() {
    this.listeners = {};
  }
  /**
   * Forwards all `data` events on this stream to the destination stream. The
   * destination stream should provide a method `push` to receive the data
   * events as they arrive.
   *
   * @param {Stream} destination the stream that will receive all `data` events
   * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options
   */
  ;

  _proto.pipe = function pipe(destination) {
    this.on('data', function (data) {
      destination.push(data);
    });
  };

  return Stream;
}();



/***/ }),

/***/ "./node_modules/m3u8-parser/dist/m3u8-parser.es.js":
/*!*********************************************************!*\
  !*** ./node_modules/m3u8-parser/dist/m3u8-parser.es.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LineStream": () => (/* binding */ LineStream),
/* harmony export */   "ParseStream": () => (/* binding */ ParseStream),
/* harmony export */   "Parser": () => (/* binding */ Parser)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/inheritsLoose */ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js");
/* harmony import */ var _videojs_vhs_utils_es_stream_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @videojs/vhs-utils/es/stream.js */ "./node_modules/@videojs/vhs-utils/es/stream.js");
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _videojs_vhs_utils_es_decode_b64_to_uint8_array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @videojs/vhs-utils/es/decode-b64-to-uint8-array.js */ "./node_modules/@videojs/vhs-utils/es/decode-b64-to-uint8-array.js");
/*! @name m3u8-parser @version 4.7.1 @license Apache-2.0 */





/**
 * A stream that buffers string input and generates a `data` event for each
 * line.
 *
 * @class LineStream
 * @extends Stream
 */

var LineStream = /*#__PURE__*/function (_Stream) {
  (0,_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(LineStream, _Stream);

  function LineStream() {
    var _this;

    _this = _Stream.call(this) || this;
    _this.buffer = '';
    return _this;
  }
  /**
   * Add new data to be parsed.
   *
   * @param {string} data the text to process
   */


  var _proto = LineStream.prototype;

  _proto.push = function push(data) {
    var nextNewline;
    this.buffer += data;
    nextNewline = this.buffer.indexOf('\n');

    for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\n')) {
      this.trigger('data', this.buffer.substring(0, nextNewline));
      this.buffer = this.buffer.substring(nextNewline + 1);
    }
  };

  return LineStream;
}(_videojs_vhs_utils_es_stream_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

var TAB = String.fromCharCode(0x09);

var parseByterange = function parseByterange(byterangeString) {
  // optionally match and capture 0+ digits before `@`
  // optionally match and capture 0+ digits after `@`
  var match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || '');
  var result = {};

  if (match[1]) {
    result.length = parseInt(match[1], 10);
  }

  if (match[2]) {
    result.offset = parseInt(match[2], 10);
  }

  return result;
};
/**
 * "forgiving" attribute list psuedo-grammar:
 * attributes -> keyvalue (',' keyvalue)*
 * keyvalue   -> key '=' value
 * key        -> [^=]*
 * value      -> '"' [^"]* '"' | [^,]*
 */


var attributeSeparator = function attributeSeparator() {
  var key = '[^=]*';
  var value = '"[^"]*"|[^,]*';
  var keyvalue = '(?:' + key + ')=(?:' + value + ')';
  return new RegExp('(?:^|,)(' + keyvalue + ')');
};
/**
 * Parse attributes from a line given the separator
 *
 * @param {string} attributes the attribute line to parse
 */


var parseAttributes = function parseAttributes(attributes) {
  // split the string using attributes as the separator
  var attrs = attributes.split(attributeSeparator());
  var result = {};
  var i = attrs.length;
  var attr;

  while (i--) {
    // filter out unmatched portions of the string
    if (attrs[i] === '') {
      continue;
    } // split the key and value


    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1); // trim whitespace and remove optional quotes around the value

    attr[0] = attr[0].replace(/^\s+|\s+$/g, '');
    attr[1] = attr[1].replace(/^\s+|\s+$/g, '');
    attr[1] = attr[1].replace(/^['"](.*)['"]$/g, '$1');
    result[attr[0]] = attr[1];
  }

  return result;
};
/**
 * A line-level M3U8 parser event stream. It expects to receive input one
 * line at a time and performs a context-free parse of its contents. A stream
 * interpretation of a manifest can be useful if the manifest is expected to
 * be too large to fit comfortably into memory or the entirety of the input
 * is not immediately available. Otherwise, it's probably much easier to work
 * with a regular `Parser` object.
 *
 * Produces `data` events with an object that captures the parser's
 * interpretation of the input. That object has a property `tag` that is one
 * of `uri`, `comment`, or `tag`. URIs only have a single additional
 * property, `line`, which captures the entirety of the input without
 * interpretation. Comments similarly have a single additional property
 * `text` which is the input without the leading `#`.
 *
 * Tags always have a property `tagType` which is the lower-cased version of
 * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,
 * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized
 * tags are given the tag type `unknown` and a single additional property
 * `data` with the remainder of the input.
 *
 * @class ParseStream
 * @extends Stream
 */


var ParseStream = /*#__PURE__*/function (_Stream) {
  (0,_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(ParseStream, _Stream);

  function ParseStream() {
    var _this;

    _this = _Stream.call(this) || this;
    _this.customParsers = [];
    _this.tagMappers = [];
    return _this;
  }
  /**
   * Parses an additional line of input.
   *
   * @param {string} line a single line of an M3U8 file to parse
   */


  var _proto = ParseStream.prototype;

  _proto.push = function push(line) {
    var _this2 = this;

    var match;
    var event; // strip whitespace

    line = line.trim();

    if (line.length === 0) {
      // ignore empty lines
      return;
    } // URIs


    if (line[0] !== '#') {
      this.trigger('data', {
        type: 'uri',
        uri: line
      });
      return;
    } // map tags


    var newLines = this.tagMappers.reduce(function (acc, mapper) {
      var mappedLine = mapper(line); // skip if unchanged

      if (mappedLine === line) {
        return acc;
      }

      return acc.concat([mappedLine]);
    }, [line]);
    newLines.forEach(function (newLine) {
      for (var i = 0; i < _this2.customParsers.length; i++) {
        if (_this2.customParsers[i].call(_this2, newLine)) {
          return;
        }
      } // Comments


      if (newLine.indexOf('#EXT') !== 0) {
        _this2.trigger('data', {
          type: 'comment',
          text: newLine.slice(1)
        });

        return;
      } // strip off any carriage returns here so the regex matching
      // doesn't have to account for them.


      newLine = newLine.replace('\r', ''); // Tags

      match = /^#EXTM3U/.exec(newLine);

      if (match) {
        _this2.trigger('data', {
          type: 'tag',
          tagType: 'm3u'
        });

        return;
      }

      match = /^#EXTINF:?([0-9\.]*)?,?(.*)?$/.exec(newLine);

      if (match) {
        event = {
          type: 'tag',
          tagType: 'inf'
        };

        if (match[1]) {
          event.duration = parseFloat(match[1]);
        }

        if (match[2]) {
          event.title = match[2];
        }

        _this2.trigger('data', event);

        return;
      }

      match = /^#EXT-X-TARGETDURATION:?([0-9.]*)?/.exec(newLine);

      if (match) {
        event = {
          type: 'tag',
          tagType: 'targetduration'
        };

        if (match[1]) {
          event.duration = parseInt(match[1], 10);
        }

        _this2.trigger('data', event);

        return;
      }

      match = /^#EXT-X-VERSION:?([0-9.]*)?/.exec(newLine);

      if (match) {
        event = {
          type: 'tag',
          tagType: 'version'
        };

        if (match[1]) {
          event.version = parseInt(match[1], 10);
        }

        _this2.trigger('data', event);

        return;
      }

      match = /^#EXT-X-MEDIA-SEQUENCE:?(\-?[0-9.]*)?/.exec(newLine);

      if (match) {
        event = {
          type: 'tag',
          tagType: 'media-sequence'
        };

        if (match[1]) {
          event.number = parseInt(match[1], 10);
        }

        _this2.trigger('data', event);

        return;
      }

      match = /^#EXT-X-DISCONTINUITY-SEQUENCE:?(\-?[0-9.]*)?/.exec(newLine);

      if (match) {
        event = {
          type: 'tag',
          tagType: 'discontinuity-sequence'
        };

        if (match[1]) {
          event.number = parseInt(match[1], 10);
        }

        _this2.trigger('data', event);

        return;
      }

      match = /^#EXT-X-PLAYLIST-TYPE:?(.*)?$/.exec(newLine);

      if (match) {
        event = {
          type: 'tag',
          tagType: 'playlist-type'
        };

        if (match[1]) {
          event.playlistType = match[1];
        }

        _this2.trigger('data', event);

        return;
      }

      match = /^#EXT-X-BYTERANGE:?(.*)?$/.exec(newLine);

      if (match) {
        event = (0,_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_2__["default"])(parseByterange(match[1]), {
          type: 'tag',
          tagType: 'byterange'
        });

        _this2.trigger('data', event);

        return;
      }

      match = /^#EXT-X-ALLOW-CACHE:?(YES|NO)?/.exec(newLine);

      if (match) {
        event = {
          type: 'tag',
          tagType: 'allow-cache'
        };

        if (match[1]) {
          event.allowed = !/NO/.test(match[1]);
        }

        _this2.trigger('data', event);

        return;
      }

      match = /^#EXT-X-MAP:?(.*)$/.exec(newLine);

      if (match) {
        event = {
          type: 'tag',
          tagType: 'map'
        };

        if (match[1]) {
          var attributes = parseAttributes(match[1]);

          if (attributes.URI) {
            event.uri = attributes.URI;
          }

          if (attributes.BYTERANGE) {
            event.byterange = parseByterange(attributes.BYTERANGE);
          }
        }

        _this2.trigger('data', event);

        return;
      }

      match = /^#EXT-X-STREAM-INF:?(.*)$/.exec(newLine);

      if (match) {
        event = {
          type: 'tag',
          tagType: 'stream-inf'
        };

        if (match[1]) {
          event.attributes = parseAttributes(match[1]);

          if (event.attributes.RESOLUTION) {
            var split = event.attributes.RESOLUTION.split('x');
            var resolution = {};

            if (split[0]) {
              resolution.width = parseInt(split[0], 10);
            }

            if (split[1]) {
              resolution.height = parseInt(split[1], 10);
            }

            event.attributes.RESOLUTION = resolution;
          }

          if (event.attributes.BANDWIDTH) {
            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);
          }

          if (event.attributes['PROGRAM-ID']) {
            event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);
          }
        }

        _this2.trigger('data', event);

        return;
      }

      match = /^#EXT-X-MEDIA:?(.*)$/.exec(newLine);

      if (match) {
        event = {
          type: 'tag',
          tagType: 'media'
        };

        if (match[1]) {
          event.attributes = parseAttributes(match[1]);
        }

        _this2.trigger('data', event);

        return;
      }

      match = /^#EXT-X-ENDLIST/.exec(newLine);

      if (match) {
        _this2.trigger('data', {
          type: 'tag',
          tagType: 'endlist'
        });

        return;
      }

      match = /^#EXT-X-DISCONTINUITY/.exec(newLine);

      if (match) {
        _this2.trigger('data', {
          type: 'tag',
          tagType: 'discontinuity'
        });

        return;
      }

      match = /^#EXT-X-PROGRAM-DATE-TIME:?(.*)$/.exec(newLine);

      if (match) {
        event = {
          type: 'tag',
          tagType: 'program-date-time'
        };

        if (match[1]) {
          event.dateTimeString = match[1];
          event.dateTimeObject = new Date(match[1]);
        }

        _this2.trigger('data', event);

        return;
      }

      match = /^#EXT-X-KEY:?(.*)$/.exec(newLine);

      if (match) {
        event = {
          type: 'tag',
          tagType: 'key'
        };

        if (match[1]) {
          event.attributes = parseAttributes(match[1]); // parse the IV string into a Uint32Array

          if (event.attributes.IV) {
            if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {
              event.attributes.IV = event.attributes.IV.substring(2);
            }

            event.attributes.IV = event.attributes.IV.match(/.{8}/g);
            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);
            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);
            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);
            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);
            event.attributes.IV = new Uint32Array(event.attributes.IV);
          }
        }

        _this2.trigger('data', event);

        return;
      }

      match = /^#EXT-X-START:?(.*)$/.exec(newLine);

      if (match) {
        event = {
          type: 'tag',
          tagType: 'start'
        };

        if (match[1]) {
          event.attributes = parseAttributes(match[1]);
          event.attributes['TIME-OFFSET'] = parseFloat(event.attributes['TIME-OFFSET']);
          event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);
        }

        _this2.trigger('data', event);

        return;
      }

      match = /^#EXT-X-CUE-OUT-CONT:?(.*)?$/.exec(newLine);

      if (match) {
        event = {
          type: 'tag',
          tagType: 'cue-out-cont'
        };

        if (match[1]) {
          event.data = match[1];
        } else {
          event.data = '';
        }

        _this2.trigger('data', event);

        return;
      }

      match = /^#EXT-X-CUE-OUT:?(.*)?$/.exec(newLine);

      if (match) {
        event = {
          type: 'tag',
          tagType: 'cue-out'
        };

        if (match[1]) {
          event.data = match[1];
        } else {
          event.data = '';
        }

        _this2.trigger('data', event);

        return;
      }

      match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(newLine);

      if (match) {
        event = {
          type: 'tag',
          tagType: 'cue-in'
        };

        if (match[1]) {
          event.data = match[1];
        } else {
          event.data = '';
        }

        _this2.trigger('data', event);

        return;
      }

      match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);

      if (match && match[1]) {
        event = {
          type: 'tag',
          tagType: 'skip'
        };
        event.attributes = parseAttributes(match[1]);

        if (event.attributes.hasOwnProperty('SKIPPED-SEGMENTS')) {
          event.attributes['SKIPPED-SEGMENTS'] = parseInt(event.attributes['SKIPPED-SEGMENTS'], 10);
        }

        if (event.attributes.hasOwnProperty('RECENTLY-REMOVED-DATERANGES')) {
          event.attributes['RECENTLY-REMOVED-DATERANGES'] = event.attributes['RECENTLY-REMOVED-DATERANGES'].split(TAB);
        }

        _this2.trigger('data', event);

        return;
      }

      match = /^#EXT-X-PART:(.*)$/.exec(newLine);

      if (match && match[1]) {
        event = {
          type: 'tag',
          tagType: 'part'
        };
        event.attributes = parseAttributes(match[1]);
        ['DURATION'].forEach(function (key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseFloat(event.attributes[key]);
          }
        });
        ['INDEPENDENT', 'GAP'].forEach(function (key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = /YES/.test(event.attributes[key]);
          }
        });

        if (event.attributes.hasOwnProperty('BYTERANGE')) {
          event.attributes.byterange = parseByterange(event.attributes.BYTERANGE);
        }

        _this2.trigger('data', event);

        return;
      }

      match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);

      if (match && match[1]) {
        event = {
          type: 'tag',
          tagType: 'server-control'
        };
        event.attributes = parseAttributes(match[1]);
        ['CAN-SKIP-UNTIL', 'PART-HOLD-BACK', 'HOLD-BACK'].forEach(function (key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseFloat(event.attributes[key]);
          }
        });
        ['CAN-SKIP-DATERANGES', 'CAN-BLOCK-RELOAD'].forEach(function (key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = /YES/.test(event.attributes[key]);
          }
        });

        _this2.trigger('data', event);

        return;
      }

      match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);

      if (match && match[1]) {
        event = {
          type: 'tag',
          tagType: 'part-inf'
        };
        event.attributes = parseAttributes(match[1]);
        ['PART-TARGET'].forEach(function (key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseFloat(event.attributes[key]);
          }
        });

        _this2.trigger('data', event);

        return;
      }

      match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);

      if (match && match[1]) {
        event = {
          type: 'tag',
          tagType: 'preload-hint'
        };
        event.attributes = parseAttributes(match[1]);
        ['BYTERANGE-START', 'BYTERANGE-LENGTH'].forEach(function (key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseInt(event.attributes[key], 10);
            var subkey = key === 'BYTERANGE-LENGTH' ? 'length' : 'offset';
            event.attributes.byterange = event.attributes.byterange || {};
            event.attributes.byterange[subkey] = event.attributes[key]; // only keep the parsed byterange object.

            delete event.attributes[key];
          }
        });

        _this2.trigger('data', event);

        return;
      }

      match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);

      if (match && match[1]) {
        event = {
          type: 'tag',
          tagType: 'rendition-report'
        };
        event.attributes = parseAttributes(match[1]);
        ['LAST-MSN', 'LAST-PART'].forEach(function (key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseInt(event.attributes[key], 10);
          }
        });

        _this2.trigger('data', event);

        return;
      } // unknown tag type


      _this2.trigger('data', {
        type: 'tag',
        data: newLine.slice(4)
      });
    });
  }
  /**
   * Add a parser for custom headers
   *
   * @param {Object}   options              a map of options for the added parser
   * @param {RegExp}   options.expression   a regular expression to match the custom header
   * @param {string}   options.customType   the custom type to register to the output
   * @param {Function} [options.dataParser] function to parse the line into an object
   * @param {boolean}  [options.segment]    should tag data be attached to the segment object
   */
  ;

  _proto.addParser = function addParser(_ref) {
    var _this3 = this;

    var expression = _ref.expression,
        customType = _ref.customType,
        dataParser = _ref.dataParser,
        segment = _ref.segment;

    if (typeof dataParser !== 'function') {
      dataParser = function dataParser(line) {
        return line;
      };
    }

    this.customParsers.push(function (line) {
      var match = expression.exec(line);

      if (match) {
        _this3.trigger('data', {
          type: 'custom',
          data: dataParser(line),
          customType: customType,
          segment: segment
        });

        return true;
      }
    });
  }
  /**
   * Add a custom header mapper
   *
   * @param {Object}   options
   * @param {RegExp}   options.expression   a regular expression to match the custom header
   * @param {Function} options.map          function to translate tag into a different tag
   */
  ;

  _proto.addTagMapper = function addTagMapper(_ref2) {
    var expression = _ref2.expression,
        map = _ref2.map;

    var mapFn = function mapFn(line) {
      if (expression.test(line)) {
        return map(line);
      }

      return line;
    };

    this.tagMappers.push(mapFn);
  };

  return ParseStream;
}(_videojs_vhs_utils_es_stream_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

var camelCase = function camelCase(str) {
  return str.toLowerCase().replace(/-(\w)/g, function (a) {
    return a[1].toUpperCase();
  });
};

var camelCaseKeys = function camelCaseKeys(attributes) {
  var result = {};
  Object.keys(attributes).forEach(function (key) {
    result[camelCase(key)] = attributes[key];
  });
  return result;
}; // set SERVER-CONTROL hold back based upon targetDuration and partTargetDuration
// we need this helper because defaults are based upon targetDuration and
// partTargetDuration being set, but they may not be if SERVER-CONTROL appears before
// target durations are set.


var setHoldBack = function setHoldBack(manifest) {
  var serverControl = manifest.serverControl,
      targetDuration = manifest.targetDuration,
      partTargetDuration = manifest.partTargetDuration;

  if (!serverControl) {
    return;
  }

  var tag = '#EXT-X-SERVER-CONTROL';
  var hb = 'holdBack';
  var phb = 'partHoldBack';
  var minTargetDuration = targetDuration && targetDuration * 3;
  var minPartDuration = partTargetDuration && partTargetDuration * 2;

  if (targetDuration && !serverControl.hasOwnProperty(hb)) {
    serverControl[hb] = minTargetDuration;
    this.trigger('info', {
      message: tag + " defaulting HOLD-BACK to targetDuration * 3 (" + minTargetDuration + ")."
    });
  }

  if (minTargetDuration && serverControl[hb] < minTargetDuration) {
    this.trigger('warn', {
      message: tag + " clamping HOLD-BACK (" + serverControl[hb] + ") to targetDuration * 3 (" + minTargetDuration + ")"
    });
    serverControl[hb] = minTargetDuration;
  } // default no part hold back to part target duration * 3


  if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {
    serverControl[phb] = partTargetDuration * 3;
    this.trigger('info', {
      message: tag + " defaulting PART-HOLD-BACK to partTargetDuration * 3 (" + serverControl[phb] + ")."
    });
  } // if part hold back is too small default it to part target duration * 2


  if (partTargetDuration && serverControl[phb] < minPartDuration) {
    this.trigger('warn', {
      message: tag + " clamping PART-HOLD-BACK (" + serverControl[phb] + ") to partTargetDuration * 2 (" + minPartDuration + ")."
    });
    serverControl[phb] = minPartDuration;
  }
};
/**
 * A parser for M3U8 files. The current interpretation of the input is
 * exposed as a property `manifest` on parser objects. It's just two lines to
 * create and parse a manifest once you have the contents available as a string:
 *
 * ```js
 * var parser = new m3u8.Parser();
 * parser.push(xhr.responseText);
 * ```
 *
 * New input can later be applied to update the manifest object by calling
 * `push` again.
 *
 * The parser attempts to create a usable manifest object even if the
 * underlying input is somewhat nonsensical. It emits `info` and `warning`
 * events during the parse if it encounters input that seems invalid or
 * requires some property of the manifest object to be defaulted.
 *
 * @class Parser
 * @extends Stream
 */


var Parser = /*#__PURE__*/function (_Stream) {
  (0,_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(Parser, _Stream);

  function Parser() {
    var _this;

    _this = _Stream.call(this) || this;
    _this.lineStream = new LineStream();
    _this.parseStream = new ParseStream();

    _this.lineStream.pipe(_this.parseStream);
    /* eslint-disable consistent-this */


    var self = (0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__["default"])(_this);
    /* eslint-enable consistent-this */


    var uris = [];
    var currentUri = {}; // if specified, the active EXT-X-MAP definition

    var currentMap; // if specified, the active decryption key

    var _key;

    var hasParts = false;

    var noop = function noop() {};

    var defaultMediaGroups = {
      'AUDIO': {},
      'VIDEO': {},
      'CLOSED-CAPTIONS': {},
      'SUBTITLES': {}
    }; // This is the Widevine UUID from DASH IF IOP. The same exact string is
    // used in MPDs with Widevine encrypted streams.

    var widevineUuid = 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed'; // group segments into numbered timelines delineated by discontinuities

    var currentTimeline = 0; // the manifest is empty until the parse stream begins delivering data

    _this.manifest = {
      allowCache: true,
      discontinuityStarts: [],
      segments: []
    }; // keep track of the last seen segment's byte range end, as segments are not required
    // to provide the offset, in which case it defaults to the next byte after the
    // previous segment

    var lastByterangeEnd = 0; // keep track of the last seen part's byte range end.

    var lastPartByterangeEnd = 0;

    _this.on('end', function () {
      // only add preloadSegment if we don't yet have a uri for it.
      // and we actually have parts/preloadHints
      if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) {
        return;
      }

      if (!currentUri.map && currentMap) {
        currentUri.map = currentMap;
      }

      if (!currentUri.key && _key) {
        currentUri.key = _key;
      }

      if (!currentUri.timeline && typeof currentTimeline === 'number') {
        currentUri.timeline = currentTimeline;
      }

      _this.manifest.preloadSegment = currentUri;
    }); // update the manifest with the m3u8 entry from the parse stream


    _this.parseStream.on('data', function (entry) {
      var mediaGroup;
      var rendition;
      ({
        tag: function tag() {
          // switch based on the tag type
          (({
            version: function version() {
              if (entry.version) {
                this.manifest.version = entry.version;
              }
            },
            'allow-cache': function allowCache() {
              this.manifest.allowCache = entry.allowed;

              if (!('allowed' in entry)) {
                this.trigger('info', {
                  message: 'defaulting allowCache to YES'
                });
                this.manifest.allowCache = true;
              }
            },
            byterange: function byterange() {
              var byterange = {};

              if ('length' in entry) {
                currentUri.byterange = byterange;
                byterange.length = entry.length;

                if (!('offset' in entry)) {
                  /*
                   * From the latest spec (as of this writing):
                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.2
                   *
                   * Same text since EXT-X-BYTERANGE's introduction in draft 7:
                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-07#section-3.3.1)
                   *
                   * "If o [offset] is not present, the sub-range begins at the next byte
                   * following the sub-range of the previous media segment."
                   */
                  entry.offset = lastByterangeEnd;
                }
              }

              if ('offset' in entry) {
                currentUri.byterange = byterange;
                byterange.offset = entry.offset;
              }

              lastByterangeEnd = byterange.offset + byterange.length;
            },
            endlist: function endlist() {
              this.manifest.endList = true;
            },
            inf: function inf() {
              if (!('mediaSequence' in this.manifest)) {
                this.manifest.mediaSequence = 0;
                this.trigger('info', {
                  message: 'defaulting media sequence to zero'
                });
              }

              if (!('discontinuitySequence' in this.manifest)) {
                this.manifest.discontinuitySequence = 0;
                this.trigger('info', {
                  message: 'defaulting discontinuity sequence to zero'
                });
              }

              if (entry.duration > 0) {
                currentUri.duration = entry.duration;
              }

              if (entry.duration === 0) {
                currentUri.duration = 0.01;
                this.trigger('info', {
                  message: 'updating zero segment duration to a small value'
                });
              }

              this.manifest.segments = uris;
            },
            key: function key() {
              if (!entry.attributes) {
                this.trigger('warn', {
                  message: 'ignoring key declaration without attribute list'
                });
                return;
              } // clear the active encryption key


              if (entry.attributes.METHOD === 'NONE') {
                _key = null;
                return;
              }

              if (!entry.attributes.URI) {
                this.trigger('warn', {
                  message: 'ignoring key declaration without URI'
                });
                return;
              }

              if (entry.attributes.KEYFORMAT === 'com.apple.streamingkeydelivery') {
                this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.

                this.manifest.contentProtection['com.apple.fps.1_0'] = {
                  attributes: entry.attributes
                };
                return;
              }

              if (entry.attributes.KEYFORMAT === 'com.microsoft.playready') {
                this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.

                this.manifest.contentProtection['com.microsoft.playready'] = {
                  uri: entry.attributes.URI
                };
                return;
              } // check if the content is encrypted for Widevine
              // Widevine/HLS spec: https://storage.googleapis.com/wvdocs/Widevine_DRM_HLS.pdf


              if (entry.attributes.KEYFORMAT === widevineUuid) {
                var VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR', 'SAMPLE-AES-CENC'];

                if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {
                  this.trigger('warn', {
                    message: 'invalid key method provided for Widevine'
                  });
                  return;
                }

                if (entry.attributes.METHOD === 'SAMPLE-AES-CENC') {
                  this.trigger('warn', {
                    message: 'SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead'
                  });
                }

                if (entry.attributes.URI.substring(0, 23) !== 'data:text/plain;base64,') {
                  this.trigger('warn', {
                    message: 'invalid key URI provided for Widevine'
                  });
                  return;
                }

                if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === '0x')) {
                  this.trigger('warn', {
                    message: 'invalid key ID provided for Widevine'
                  });
                  return;
                } // if Widevine key attributes are valid, store them as `contentProtection`
                // on the manifest to emulate Widevine tag structure in a DASH mpd


                this.manifest.contentProtection = this.manifest.contentProtection || {};
                this.manifest.contentProtection['com.widevine.alpha'] = {
                  attributes: {
                    schemeIdUri: entry.attributes.KEYFORMAT,
                    // remove '0x' from the key id string
                    keyId: entry.attributes.KEYID.substring(2)
                  },
                  // decode the base64-encoded PSSH box
                  pssh: (0,_videojs_vhs_utils_es_decode_b64_to_uint8_array_js__WEBPACK_IMPORTED_MODULE_4__["default"])(entry.attributes.URI.split(',')[1])
                };
                return;
              }

              if (!entry.attributes.METHOD) {
                this.trigger('warn', {
                  message: 'defaulting key method to AES-128'
                });
              } // setup an encryption key for upcoming segments


              _key = {
                method: entry.attributes.METHOD || 'AES-128',
                uri: entry.attributes.URI
              };

              if (typeof entry.attributes.IV !== 'undefined') {
                _key.iv = entry.attributes.IV;
              }
            },
            'media-sequence': function mediaSequence() {
              if (!isFinite(entry.number)) {
                this.trigger('warn', {
                  message: 'ignoring invalid media sequence: ' + entry.number
                });
                return;
              }

              this.manifest.mediaSequence = entry.number;
            },
            'discontinuity-sequence': function discontinuitySequence() {
              if (!isFinite(entry.number)) {
                this.trigger('warn', {
                  message: 'ignoring invalid discontinuity sequence: ' + entry.number
                });
                return;
              }

              this.manifest.discontinuitySequence = entry.number;
              currentTimeline = entry.number;
            },
            'playlist-type': function playlistType() {
              if (!/VOD|EVENT/.test(entry.playlistType)) {
                this.trigger('warn', {
                  message: 'ignoring unknown playlist type: ' + entry.playlist
                });
                return;
              }

              this.manifest.playlistType = entry.playlistType;
            },
            map: function map() {
              currentMap = {};

              if (entry.uri) {
                currentMap.uri = entry.uri;
              }

              if (entry.byterange) {
                currentMap.byterange = entry.byterange;
              }

              if (_key) {
                currentMap.key = _key;
              }
            },
            'stream-inf': function streamInf() {
              this.manifest.playlists = uris;
              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;

              if (!entry.attributes) {
                this.trigger('warn', {
                  message: 'ignoring empty stream-inf attributes'
                });
                return;
              }

              if (!currentUri.attributes) {
                currentUri.attributes = {};
              }

              (0,_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_2__["default"])(currentUri.attributes, entry.attributes);
            },
            media: function media() {
              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;

              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {
                this.trigger('warn', {
                  message: 'ignoring incomplete or missing media group'
                });
                return;
              } // find the media group, creating defaults as necessary


              var mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];
              mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};
              mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']]; // collect the rendition metadata

              rendition = {
                default: /yes/i.test(entry.attributes.DEFAULT)
              };

              if (rendition.default) {
                rendition.autoselect = true;
              } else {
                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);
              }

              if (entry.attributes.LANGUAGE) {
                rendition.language = entry.attributes.LANGUAGE;
              }

              if (entry.attributes.URI) {
                rendition.uri = entry.attributes.URI;
              }

              if (entry.attributes['INSTREAM-ID']) {
                rendition.instreamId = entry.attributes['INSTREAM-ID'];
              }

              if (entry.attributes.CHARACTERISTICS) {
                rendition.characteristics = entry.attributes.CHARACTERISTICS;
              }

              if (entry.attributes.FORCED) {
                rendition.forced = /yes/i.test(entry.attributes.FORCED);
              } // insert the new rendition


              mediaGroup[entry.attributes.NAME] = rendition;
            },
            discontinuity: function discontinuity() {
              currentTimeline += 1;
              currentUri.discontinuity = true;
              this.manifest.discontinuityStarts.push(uris.length);
            },
            'program-date-time': function programDateTime() {
              if (typeof this.manifest.dateTimeString === 'undefined') {
                // PROGRAM-DATE-TIME is a media-segment tag, but for backwards
                // compatibility, we add the first occurence of the PROGRAM-DATE-TIME tag
                // to the manifest object
                // TODO: Consider removing this in future major version
                this.manifest.dateTimeString = entry.dateTimeString;
                this.manifest.dateTimeObject = entry.dateTimeObject;
              }

              currentUri.dateTimeString = entry.dateTimeString;
              currentUri.dateTimeObject = entry.dateTimeObject;
            },
            targetduration: function targetduration() {
              if (!isFinite(entry.duration) || entry.duration < 0) {
                this.trigger('warn', {
                  message: 'ignoring invalid target duration: ' + entry.duration
                });
                return;
              }

              this.manifest.targetDuration = entry.duration;
              setHoldBack.call(this, this.manifest);
            },
            start: function start() {
              if (!entry.attributes || isNaN(entry.attributes['TIME-OFFSET'])) {
                this.trigger('warn', {
                  message: 'ignoring start declaration without appropriate attribute list'
                });
                return;
              }

              this.manifest.start = {
                timeOffset: entry.attributes['TIME-OFFSET'],
                precise: entry.attributes.PRECISE
              };
            },
            'cue-out': function cueOut() {
              currentUri.cueOut = entry.data;
            },
            'cue-out-cont': function cueOutCont() {
              currentUri.cueOutCont = entry.data;
            },
            'cue-in': function cueIn() {
              currentUri.cueIn = entry.data;
            },
            'skip': function skip() {
              this.manifest.skip = camelCaseKeys(entry.attributes);
              this.warnOnMissingAttributes_('#EXT-X-SKIP', entry.attributes, ['SKIPPED-SEGMENTS']);
            },
            'part': function part() {
              var _this2 = this;

              hasParts = true; // parts are always specifed before a segment

              var segmentIndex = this.manifest.segments.length;
              var part = camelCaseKeys(entry.attributes);
              currentUri.parts = currentUri.parts || [];
              currentUri.parts.push(part);

              if (part.byterange) {
                if (!part.byterange.hasOwnProperty('offset')) {
                  part.byterange.offset = lastPartByterangeEnd;
                }

                lastPartByterangeEnd = part.byterange.offset + part.byterange.length;
              }

              var partIndex = currentUri.parts.length - 1;
              this.warnOnMissingAttributes_("#EXT-X-PART #" + partIndex + " for segment #" + segmentIndex, entry.attributes, ['URI', 'DURATION']);

              if (this.manifest.renditionReports) {
                this.manifest.renditionReports.forEach(function (r, i) {
                  if (!r.hasOwnProperty('lastPart')) {
                    _this2.trigger('warn', {
                      message: "#EXT-X-RENDITION-REPORT #" + i + " lacks required attribute(s): LAST-PART"
                    });
                  }
                });
              }
            },
            'server-control': function serverControl() {
              var attrs = this.manifest.serverControl = camelCaseKeys(entry.attributes);

              if (!attrs.hasOwnProperty('canBlockReload')) {
                attrs.canBlockReload = false;
                this.trigger('info', {
                  message: '#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false'
                });
              }

              setHoldBack.call(this, this.manifest);

              if (attrs.canSkipDateranges && !attrs.hasOwnProperty('canSkipUntil')) {
                this.trigger('warn', {
                  message: '#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set'
                });
              }
            },
            'preload-hint': function preloadHint() {
              // parts are always specifed before a segment
              var segmentIndex = this.manifest.segments.length;
              var hint = camelCaseKeys(entry.attributes);
              var isPart = hint.type && hint.type === 'PART';
              currentUri.preloadHints = currentUri.preloadHints || [];
              currentUri.preloadHints.push(hint);

              if (hint.byterange) {
                if (!hint.byterange.hasOwnProperty('offset')) {
                  // use last part byterange end or zero if not a part.
                  hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;

                  if (isPart) {
                    lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;
                  }
                }
              }

              var index = currentUri.preloadHints.length - 1;
              this.warnOnMissingAttributes_("#EXT-X-PRELOAD-HINT #" + index + " for segment #" + segmentIndex, entry.attributes, ['TYPE', 'URI']);

              if (!hint.type) {
                return;
              } // search through all preload hints except for the current one for
              // a duplicate type.


              for (var i = 0; i < currentUri.preloadHints.length - 1; i++) {
                var otherHint = currentUri.preloadHints[i];

                if (!otherHint.type) {
                  continue;
                }

                if (otherHint.type === hint.type) {
                  this.trigger('warn', {
                    message: "#EXT-X-PRELOAD-HINT #" + index + " for segment #" + segmentIndex + " has the same TYPE " + hint.type + " as preload hint #" + i
                  });
                }
              }
            },
            'rendition-report': function renditionReport() {
              var report = camelCaseKeys(entry.attributes);
              this.manifest.renditionReports = this.manifest.renditionReports || [];
              this.manifest.renditionReports.push(report);
              var index = this.manifest.renditionReports.length - 1;
              var required = ['LAST-MSN', 'URI'];

              if (hasParts) {
                required.push('LAST-PART');
              }

              this.warnOnMissingAttributes_("#EXT-X-RENDITION-REPORT #" + index, entry.attributes, required);
            },
            'part-inf': function partInf() {
              this.manifest.partInf = camelCaseKeys(entry.attributes);
              this.warnOnMissingAttributes_('#EXT-X-PART-INF', entry.attributes, ['PART-TARGET']);

              if (this.manifest.partInf.partTarget) {
                this.manifest.partTargetDuration = this.manifest.partInf.partTarget;
              }

              setHoldBack.call(this, this.manifest);
            }
          })[entry.tagType] || noop).call(self);
        },
        uri: function uri() {
          currentUri.uri = entry.uri;
          uris.push(currentUri); // if no explicit duration was declared, use the target duration

          if (this.manifest.targetDuration && !('duration' in currentUri)) {
            this.trigger('warn', {
              message: 'defaulting segment duration to the target duration'
            });
            currentUri.duration = this.manifest.targetDuration;
          } // annotate with encryption information, if necessary


          if (_key) {
            currentUri.key = _key;
          }

          currentUri.timeline = currentTimeline; // annotate with initialization segment information, if necessary

          if (currentMap) {
            currentUri.map = currentMap;
          } // reset the last byterange end as it needs to be 0 between parts


          lastPartByterangeEnd = 0; // prepare for the next URI

          currentUri = {};
        },
        comment: function comment() {// comments are not important for playback
        },
        custom: function custom() {
          // if this is segment-level data attach the output to the segment
          if (entry.segment) {
            currentUri.custom = currentUri.custom || {};
            currentUri.custom[entry.customType] = entry.data; // if this is manifest-level data attach to the top level manifest object
          } else {
            this.manifest.custom = this.manifest.custom || {};
            this.manifest.custom[entry.customType] = entry.data;
          }
        }
      })[entry.type].call(self);
    });

    return _this;
  }

  var _proto = Parser.prototype;

  _proto.warnOnMissingAttributes_ = function warnOnMissingAttributes_(identifier, attributes, required) {
    var missing = [];
    required.forEach(function (key) {
      if (!attributes.hasOwnProperty(key)) {
        missing.push(key);
      }
    });

    if (missing.length) {
      this.trigger('warn', {
        message: identifier + " lacks required attribute(s): " + missing.join(', ')
      });
    }
  }
  /**
   * Parse the input string and update the manifest object.
   *
   * @param {string} chunk a potentially incomplete portion of the manifest
   */
  ;

  _proto.push = function push(chunk) {
    this.lineStream.push(chunk);
  }
  /**
   * Flush any remaining input. This can be handy if the last line of an M3U8
   * manifest did not contain a trailing newline but the file has been
   * completely received.
   */
  ;

  _proto.end = function end() {
    // flush any buffered input
    this.lineStream.push('\n');
    this.trigger('end');
  }
  /**
   * Add an additional parser for non-standard tags
   *
   * @param {Object}   options              a map of options for the added parser
   * @param {RegExp}   options.expression   a regular expression to match the custom header
   * @param {string}   options.type         the type to register to the output
   * @param {Function} [options.dataParser] function to parse the line into an object
   * @param {boolean}  [options.segment]    should tag data be attached to the segment object
   */
  ;

  _proto.addParser = function addParser(options) {
    this.parseStream.addParser(options);
  }
  /**
   * Add a custom header mapper
   *
   * @param {Object}   options
   * @param {RegExp}   options.expression   a regular expression to match the custom header
   * @param {Function} options.map          function to translate tag into a different tag
   */
  ;

  _proto.addTagMapper = function addTagMapper(options) {
    this.parseStream.addTagMapper(options);
  };

  return Parser;
}(_videojs_vhs_utils_es_stream_js__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./node_modules/sha.js/hash.js":
/*!*************************************!*\
  !*** ./node_modules/sha.js/hash.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer); // prototype class for hash functions


function Hash(blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize);
  this._finalSize = finalSize;
  this._blockSize = blockSize;
  this._len = 0;
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8';
    data = Buffer.from(data, enc);
  }

  var block = this._block;
  var blockSize = this._blockSize;
  var length = data.length;
  var accum = this._len;

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize;
    var remainder = Math.min(length - offset, blockSize - assigned);

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i];
    }

    accum += remainder;
    offset += remainder;

    if (accum % blockSize === 0) {
      this._update(block);
    }
  }

  this._len += length;
  return this;
};

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize;
  this._block[rem] = 0x80; // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize

  this._block.fill(0, rem + 1);

  if (rem >= this._finalSize) {
    this._update(this._block);

    this._block.fill(0);
  }

  var bits = this._len * 8; // uint32

  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4); // uint64

  } else {
    var lowBits = (bits & 0xffffffff) >>> 0;
    var highBits = (bits - lowBits) / 0x100000000;

    this._block.writeUInt32BE(highBits, this._blockSize - 8);

    this._block.writeUInt32BE(lowBits, this._blockSize - 4);
  }

  this._update(this._block);

  var hash = this._hash();

  return enc ? hash.toString(enc) : hash;
};

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass');
};

module.exports = Hash;

/***/ }),

/***/ "./node_modules/sha.js/sha1.js":
/*!*************************************!*\
  !*** ./node_modules/sha.js/sha1.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js");

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer);

var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0];
var W = new Array(80);

function Sha1() {
  this.init();
  this._w = W;
  Hash.call(this, 64, 56);
}

inherits(Sha1, Hash);

Sha1.prototype.init = function () {
  this._a = 0x67452301;
  this._b = 0xefcdab89;
  this._c = 0x98badcfe;
  this._d = 0x10325476;
  this._e = 0xc3d2e1f0;
  return this;
};

function rotl1(num) {
  return num << 1 | num >>> 31;
}

function rotl5(num) {
  return num << 5 | num >>> 27;
}

function rotl30(num) {
  return num << 30 | num >>> 2;
}

function ft(s, b, c, d) {
  if (s === 0) return b & c | ~b & d;
  if (s === 2) return b & c | b & d | c & d;
  return b ^ c ^ d;
}

Sha1.prototype._update = function (M) {
  var W = this._w;
  var a = this._a | 0;
  var b = this._b | 0;
  var c = this._c | 0;
  var d = this._d | 0;
  var e = this._e | 0;

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);

  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20);
    var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s] | 0;
    e = d;
    d = c;
    c = rotl30(b);
    b = a;
    a = t;
  }

  this._a = a + this._a | 0;
  this._b = b + this._b | 0;
  this._c = c + this._c | 0;
  this._d = d + this._d | 0;
  this._e = e + this._e | 0;
};

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20);
  H.writeInt32BE(this._a | 0, 0);
  H.writeInt32BE(this._b | 0, 4);
  H.writeInt32BE(this._c | 0, 8);
  H.writeInt32BE(this._d | 0, 12);
  H.writeInt32BE(this._e | 0, 16);
  return H;
};

module.exports = Sha1;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _assertThisInitialized)
/* harmony export */ });
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/extends.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _extends)
/* harmony export */ });
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _inheritsLoose)
/* harmony export */ });
/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(subClass, superClass);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _setPrototypeOf)
/* harmony export */ });
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_peertube_p2p-media-loader-hlsjs_dist_index_js.chunk.js.map